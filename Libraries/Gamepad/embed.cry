import Core;
import Game;
import Math;

namespace Gamepad {
	
	// Button IDs for canonical (read: "XBox"/"PS") controllers.
	// These are used by auto-configure.
	enum ButtonId {
		BUTTON_LEFT = 1,
		BUTTON_RIGHT = 2,
		BUTTON_UP = 3,
		BUTTON_DOWN = 4,
		DPAD_LEFT = 5,
		DPAD_RIGHT = 6,
		DPAD_UP = 7,
		DPAD_DOWN = 8,
		AXIS1 = 9,
		AXIS2 = 10,
		LEFT_TRIGGER = 11,
		RIGHT_TRIGGER = 12,
		LEFT_BUMPER = 13,
		RIGHT_BUMPER = 14,
		START = 15,
		BACK = 16,
	}

	enum XBoxButtonId {
		X = ButtonId.BUTTON_LEFT,
		B = ButtonId.BUTTON_RIGHT,
		Y = ButtonId.BUTTON_UP,
		A = ButtonId.BUTTON_DOWN,
		DPAD_LEFT = ButtonId.DPAD_LEFT,
		DPAD_RIGHT = ButtonId.DPAD_RIGHT,
		DPAD_UP = ButtonId.DPAD_UP,
		DPAD_DOWN = ButtonId.DPAD_DOWN,
		AXIS1 = ButtonId.AXIS1,
		AXIS2 = ButtonId.AXIS2,
		LEFT_TRIGGER = ButtonId.LEFT_TRIGGER,
		RIGHT_TRIGGER = ButtonId.RIGHT_TRIGGER,
		LEFT_BUMPER = ButtonId.LEFT_BUMPER,
		RIGHT_BUMPER = ButtonId.RIGHT_BUMPER,
		START = ButtonId.START,
		BACK = ButtonId.BACK,
	}

	enum PsButtonId {
		SQUARE = ButtonId.BUTTON_LEFT,
		CIRCLE = ButtonId.BUTTON_RIGHT,
		TRIANGLE = ButtonId.BUTTON_UP,
		X = ButtonId.BUTTON_DOWN,
		DPAD_LEFT = ButtonId.DPAD_LEFT,
		DPAD_RIGHT = ButtonId.DPAD_RIGHT,
		DPAD_UP = ButtonId.DPAD_UP,
		DPAD_DOWN = ButtonId.DPAD_DOWN,
		AXIS1 = ButtonId.AXIS1,
		AXIS2 = ButtonId.AXIS2,
		LEFT_BUMPER2 = ButtonId.LEFT_TRIGGER,
		RIGHT_BUMPER2 = ButtonId.RIGHT_TRIGGER,
		LEFT_BUMPER1 = ButtonId.LEFT_BUMPER,
		RIGHT_BUMPER1 = ButtonId.RIGHT_BUMPER,
		START = ButtonId.START,
		SELECT = ButtonId.BACK,
	}

	enum SnesButtonId {
		Y = ButtonId.BUTTON_LEFT,
		A = ButtonId.BUTTON_RIGHT,
		X = ButtonId.BUTTON_UP,
		B = ButtonId.BUTTON_DOWN,
		LEFT = ButtonId.DPAD_LEFT,
		RIGHT = ButtonId.DPAD_RIGHT,
		UP = ButtonId.DPAD_UP,
		DOWN = ButtonId.DPAD_DOWN,
		L = ButtonId.LEFT_BUMPER,
		R = ButtonId.RIGHT_BUMPER,
		START = ButtonId.START,
		SELECT = ButtonId.BACK,
	}

	class GamepadManager {
		
		static field _devices = null;
		static field _isGamepadSupported = $$lib_gamepad_is_supported();
		static field _platformRequiresRefresh = $$lib_gamepad_platform_requires_refresh();
		static field _device_count_checked = false;
		static field _device_by_id_ints = null;
		static field _device_by_id_strings = null;

		static constructor() {
			GameWindow._eventPumpHandlers.add(GamepadManager._eventPump);
		}

		constructor() {
			Core.assert(false); // TODO: private constructors/static classes
		}

		static function isGamepadSupported() {
			return GamepadManager._isGamepadSupported;
		}

		static function platformRequiresRefresh() {
			return GamepadManager._platformRequiresRefresh;
		}

		static function refreshDevices() {
			if (GamepadManager._platformRequiresRefresh) {
				devices = GamepadManager._devices;
				if (devices == null) {
					devices = [];
					GamepadManager._devices = devices;
				}

				$$lib_gamepad_refresh_devices();
				newCount = $$lib_gamepad_current_device_count();
				while (newCount > devices.length) {
					devices.add(new GamepadDevice(devices.length));
				}
			} else if (GamepadManager._devices == null) {
				// For platforms that don't require a refresh, it's okay to ignore successive calls to this function.
				devices = [];
				deviceCount = $$lib_gamepad_current_device_count();
				for (i = 0; i < deviceCount; ++i) {
					devices.add(new GamepadDevice(i));
				}
				GamepadManager._devices = devices;
			}
		}

		static function getDeviceCount() {
			Core.assert(GamepadManager._devices != null, "Cannot get device count without calling refreshDevices.");
			GamepadManager._device_count_checked = true;
			return GamepadManager._devices.length;
		}

		static function getDeviceByIndex(index) {
			Core.assert(GamepadManager._device_count_checked, "Cannot get device by index without checking device count.");
			Core.assert(index >= 0 && index < GamepadManager._devices.length, "Device index out of range.");
			return GamepadManager._devices[index];
		}

		static function getDeviceById(id) {
			Core.assert(GamepadManager._devices != null, "Cannot get device by ID without initializing.");
			sLookup = GamepadManager._device_by_id_strings;
			iLookup = GamepadManager._device_by_id_ints;
			if (sLookup == null) {
				sLookup = {};
				iLookup = {};
				for (device : GamepadManager._devices) {
					id = device._id;
					if (id != null) {
						if (Core.typeof(id) == Core.Type.INTEGER) {
							iLookup[id] = device;
						} else {
							sLookup[id] = device;
						}
					}
				}
				GamepadManager._device_by_id_strings = sLookup;
				GamepadManager._device_by_id_ints = iLookup;
			}

			t = Core.typeof(id);
			if (t == Type.STRING) return sLookup.get(id);
			if (t == Type.INTEGER) return iLookup.get(id);
			return null;
		}

		static function saveSettingsToUserData() {
			
		}

		// Returns a list of player IDs
		static function restoreSettingsFromUserData() {
			
		}

		static function _eventPump(eventsOut) {
			// TODO: add gamepad events to eventsOut
			if (GamepadManager._devices != null) {
				for (device : GamepadManager._devices) {
					device._updatePass(eventsOut);
				}
			}
		}

		// TODO: Determine if a dead zone filter should be global or set on individual gamepads.
	}

	/*
		nativeData[0] -> a pointer of some sort to the device
	*/
	class GamepadDevice {
		field _index;
		field _id = null;
		field _name;
		field _button_count;
		field _axis_1d_count;
		field _axis_2d_count;
		field _hardware_fingerprint;
		field _counter = 0; // incremented each hardware pass. Used to denote if a value was set this frame or a previous frame.

		/*
			List of 5 items:
			- type (0 -> button, 1 -> single dimensional axis, 2 -> 2-dimensional axis X, 3 -> 2-dimensional axis Y)
			- index 
			- mashy_fingerprint
			- state
			- time that the state last changed
		*/
		field _hardware_mashies = [];

		// string to index reverse lookup of the above list, based on mashy_fingerprint
		field _mashy_fingerprint_to_index = {};

		/*
			List of dictionary pairs mapping button ID's to where they come from. 
			In each pair, the first item is integer mappings, and the second item is a string mapping.
			
			The value of each dictionary item is a list that looks like this:
			[
				isDigital (bool),
				dimensionCount (ints 1, 2, or 4),
				x- or - or button source,
				x+ or + source,
				y- source,
				y+ source
			]
			These source values can either be null or a positive or negative integer.
			Null means the value hasn't been bound yet.
			The absolute value of the integer is the index in the _hardware_mashies list
			If the value is negative, that means the negative value of the axis is used.
		*/
		field _config_stack = [];

		constructor(index) {
			this._index = index;
			params = [
				'', // name
				0, // button count
				0, // digital axis count
				0, // analog axis count
			];
			$$lib_gamepad_initialize_device(index, this, params);
			this._name = params[0];
			this._button_count = params[1];
			this._axis_1d_count = params[2];
			this._axis_2d_count = params[3];

			// The index is stored as a positive or negative value which has special meaning.
			// 0 messes that up.
			hardware_sources = [null]; 

			for (i = 0; i < this._button_count; ++i) {
				hardware_sources.add([0, i, 'b:' + i, false, -1]);
			}

			for (i = 0; i < this._axis_2d_count; ++i) {
				hardware_sources.add(
					[2, i, 'h:' + i + ':x', 0, -1],
					[3, i, 'h:' + i + ':y', 0, -1]);
			}

			for (i = 0; i < this._axis_1d_count; ++i) {
				hardware_sources.add([1, i, 'a:' + i, 0.0, -1]);
			}

			this._hardware_mashies = hardware_sources;
			this._mashy_fingerprint_to_index = {};
			for (i = 1; i < this._hardware_mashies.length; ++i) {
				this._mashy_fingerprint_to_index[hardware_sources[i][2]] = i;
			}

			this._hardware_fingerprint = [
				GamepadDevice.stringToHex(this._name),
				this._button_count,
				this._axis_1d_count,
				this._axis_2d_count].join('~');
		}

		static function stringToHex(str) {
			output = [];
			h = '0123456789abcdef';
			for (c : str) {
				n = Core.ord(c) % 256;
				output.add(h[n / 16], h[n % 16]);
			}
			return output.join('');
		}

		static field _hat_check_reusable = [0, 0];

		function _updatePass(eventsOut) {
			$$lib_gamepad_poll_universe();
			counter = this._counter++;
			updated_indices = [];
			for (i = 1; i < this._hardware_mashies.length; ++i) { // skip 0. it is a null placeholder.
				mashy = this._hardware_mashies[i];
				old_value = mashy[3];
				switch (mashy[0]) {
					case 0: // button
						new_value = $$lib_gamepad_get_button_state(this, mashy[1]);
						if (new_value != old_value) {
							mashy[3] = new_value;
							mashy[4] = counter;
							updated_indices.add(i);
						}
						break;

					case 1: // 1D analog axis
						new_value = $$lib_gamepad_get_axis_1d_state(this, mashy[1]);
						if (Math.abs(new_value - old_value) > 0.000001) {
							mashy[3] = new_value;
							mashy[4] = counter;
							updated_indices.add(i);
						}
						break;

					case 2: // 2D digital axis X axis
						// Querying the X axis will return a tuple of X, Y values.
						// Since the config will always have the X and Y values at adjacent indices with the Y value next,
						// go ahead and query both values and set them both.
						$$lib_gamepad_get_axis_2d_state(this, mashy[1], GamepadDevice._hat_check_reusable);
						if (GamepadDevice._hat_check_reusable[0] != mashy[3]) {
							mashy[3] = GamepadDevice._hat_check_reusable[0];
							mashy[4] = counter;
							updated_indices.add(i);
						}
						++i; // go ahead and do Y since we already queried the value from hardware.
						mashy = this._hardware_mashies[i];
						if (GamepadDevice._hat_check_reusable[1] != mashy[3]) {
							mashy[3] = GamepadDevice._hat_check_reusable[1];
							mashy[4] = counter;
							updated_indices.add(i);
						}
						break;

					// case 3 will not occur, as i is incremented and handles 2D axes Y values in case 2
				}
			}

			for (index : updated_indices) {
				mashy = this._hardware_mashies[index];
				switch (mashy[0]) {
					case 0: t = GamepadMashyType.BUTTON; break;
					case 1: t = GamepadMashyType.ANALOG_AXIS; break;
					default: t = GamepadMashyType.DIGITAL_AXIS; break;
				}
				eventsOut.add(new GamepadRawHardwareEvent(
					this, t, index, mashy[3], mashy[2]));
			}
		}

		function getId() {
			return this._id;
		}

		function setId(id) {
			this._id = id;
		}

		function _getStackTop() {
			Core.assert(this._config_stack.length > 0, "Gamepad config stack is empty.");
			return this._config_stack[-1];
		}

		function pushAutoConfigure() {
			this.pushEmptyConfig();
			Core.assert(false, "pushAutoConfigure not implemented.");
		}

		function pushEmptyConfig() {
			this._config_stack.add([{}, {}]);
		}

		function popConfig() {
			this._getStackTop();
			this._config_stack.pop();
		}

		function flattenConfigs() {
			if (this._config_stack.length > 0) {
				this._config_stack = [this._config_stack[-1]];
			}
		}

		function clearBinding(buttonId) {
			this._getStackTop();
			lookup = (Core.typeof(buttonId) == Type.INTEGER) ? this._config_stack[-1][0] : this._config_stack[-1][1];
			if (lookup.contains(buttonId)) {
				lookup.remove(buttonId);
			}
		}

		function clearBindings() {
			t = this._getStackTop();
			t[0].clear();
			t[1].clear();
		}

		function getName() {
			return this._name;
		}

		function getButtonCount() {
			return this._button_count;
		}

		function getDigitalAxisCount() {
			return this._axis_2d_count;
		}

		function getAnalogAxisCount() {
			return this._axis_1d_count;
		}

		function getButtonState(index) {
			if (index >= 0 && index < this._button_count) {
				return $$lib_gamepad_get_button_state(this, index);
			}
			Core.assert(false, "Button index out of range.");
		}

		function getAxis2dState(index) {
			if (index >= 0 && index < this._axis_2d_count) {
				$$lib_gamepad_get_axis_2d_state(this, index, GamepadDevice._hat_check_reusable);
				return GamepadDevice._hat_check_reusable.clone();
			}
			Core.assert(false, "Digital Axis index out of range.");
		}

		function getAxis1dState(index) {
			if (index >= 0 && index < this._axis_1d_count) {
				return $$lib_gamepad_get_axis_1d_state(this, index);
			}
			Core.assert(false, "Analog axis index out of range.");
		}

		function _getLookupForId(buttonId) {
			top = this._getStackTop();
			t = Core.typeof(buttonId);
			if (t == Core.Type.INTEGER) return top[0];
			if (t == Core.Type.STRING) return top[1];
			Core.assert(false, "Invalid button ID type.");
		}

		function _isHardwareMashyBoundAnywhere(index) {
			for (lookup : this._config_stack[-1]) {
				for (value : lookup.values()) {
					for (i = 0; i < value[2]; ++i) {
						if (value[2 + i] == index) {
							return true;
						}
					}
				}
			}
			return false;
		}

		/*
			This is only used in the context of binding a button ID. If the button ID (and dimension) is already bound to something, ignore it.
			Otherwise return the first hardware mashy thing that is currently in its non-default state.
		*/
		function _getIndexOfCurrentlyUnboundMashy(buttonId, dim) {
			lookup = this._getLookupForId(buttonId);
			currentBinding = lookup.get(buttonId);
			if (currentBinding != null) {
				if (currentBinding[1 + dim] != null) {
					return null;
				}
			}

			for (mashy : this._hardware_mashies) {
				switch (mashy[0]) {
					case 0: // button
						if (mashy[3]) {
							if (!this._isHardwareMashyBoundAnywhere(mashy[1])) {
								return mashy[1];
							}
						}
						break;

					case 1: // 1D axis
						if (abs(mashy[3]) > .5) {
							index = mashy[1] * Math.sign(mashy[3]);
							if (!this._isHardwareMashyBoundAnywhere(index)) {
								return index;
							}
						}
						break;

					case 2: // 2D axis X
					case 3: // 2D axis Y
						if (mashy[3] != 0) {
							index = mashy[1] * Math.sign(mashy[3]);
							if (!this._isHardwareMashyBoundAnywhere(index)) {
								return index;
							}
						}
						break;
				}
			}
		}

		function _getOrCreateBindingTuple(buttonId, isDigital, dimensions) {
			lookup = this._getLookupForId(buttonId);
			binding = lookup.get(buttonId);
			if (binding == null) {
				binding = [null] * 6;
			}
			lookup[buttonId] = binding;
			binding[0] = isDigital;
			binding[1] = dimensions;
			return binding;
		}

		function _bindButton(buttonId, isDigital) {
			index = this._getIndexOfCurrentlyUnboundMashy(buttonId, 1);
			if (index != null) {
				binding = this._getOrCreateBindingTuple(buttonId, isDigital, 1);
				binding[2] = index;
				return true;
			}
			return false;
		}

		function _bind1dAxis(buttonId, isPositive, isDigital) {
			index = this._getIndexOfCurrentlyUnboundMashy(buttonId, 2);
			if (index != null) {
				binding = this._getOrCreateBindingTuple(buttonId, isDigital, 2);
				binding[2 + (isPositive ? 1 : 0)] = index;
				return true;
			}
			return false;
		}

		function _bind2dAxis(buttonId, isPositive, isX, isDigital) {
			index = this._getIndexOfCurrentlyUnboundMashy(buttonId, 4);
			if (index != null) {
				binding = this._getOrCreateBindingTuple(buttonId, isDigital, 4);
				binding[2 + (isPositive ? 1 : 0) + (isX ? 0 : 2)] = index;
				return true;
			}
			return false;
		}

		function bindDigitalButton(buttonId) {
			return this._bindButton(buttonId, true);
		}

		function bind1dDigitalAxis(buttonId, isPositive) {
			return this._bind1dAxis(buttonId, isPositive == true, true);
		}

		function bind2dDigitalAxis(buttonId, isX, isPositive) {
			return this._bind2dAxis(buttonId, isPositive == true, isX == true, true);
		}

		function bindAnalogButton(buttonId) {
			return this._bindButton(buttonId, false);
		}

		function bind1dAnalogAxis(buttonId, isPositive) {
			return this._bind1dAxis(buttonId, isPositive == true, false);
		}

		function bind2dAnalogAxis(buttonId, isX, isPositive) {
			return this._bind2dAxis(buttonId, isPositive == true, isX == true, false);
		}

		function _freeAndGetIndex(hardwareId, isPositive) {
			index = this._mashy_fingerprint_to_index.get(hardwareId);
			if (index != null) {
				if (isPositive) {
					index *= -1;
				}

				config = this._getStackTop();
				for (lookup : config) {
					for (i = 2; i < 6; ++i) {
						if (lookup[i] == index) {
							lookup[i] = null;
						}
					}
				}
			}
			return index;
		}

		function _bindButtonByHardwareId(hardwareId, buttonId, isDigital) {
			index = this._freeAndGetIndex(hardwareId, true);
			if (index != null) {
				binding = this._getOrCreateBindingTuple(buttonId, isDigital, 1);
				binding[2] = index;
				return true;
			}
			return false;
		}

		function _bind1dAxisByHardwareId(hardwareId, buttonId, isDigital, isPositive) {
			index = this._freeAndGetIndex(hardwareId * (isPositive ? 1 : -1), isPositive);
			if (index != null) {
				binding = this._getOrCreateBindingTuple(buttonId, isDigital, 2);
				binding[2 + (isPositive ? 1 : 0)] = index;
				return true;
			}
			return false;
		}

		function _bind2dAxisByHardwareId(hardwareId, buttonId, isDigital, isX, isPositive) {
			index = this._freeAndGetIndex(hardwareId * (isPositive ? 1 : -1), isPositive);
			if (index != null) {
				binding = this._getOrCreateBindingTuple(buttonId, isDigital, 4);
				binding[2 + (isPositive ? 1 : 0) + (isX ? 0 : 2)] = index;
				return true;
			}
			return false;
		}

		function bindDigitalButtonByHardwareId(hardwareId, buttonId) {
			return this._bindButtonByHardwareId(hardwareId, buttonId, true);
		}

		function bindAnalogButtonByHardwareId(hardwareId, buttonId) {
			return this._bindButtonByHardwareId(hardwareId, buttonId, false);
		}
		
		function bind1dDigitalAxisByHardwareId(hardwareId, buttonId, isPositive) {
			return this._bind1dAxisByHardwareId(hardwareId, buttonId, true, isPositive == true);
		}

		function bind1dAnalogAxisByHardwareId(hardwareId, buttonId, isPositive) {
			return this._bind1dAxisByHardwareId(hardwareId, buttonId, false, isPositive == true);
		}

		function bind2dDigitalAxisByHardwareId(hardwareId, buttonId, isX, isPositive) {
			return this._bind2dAxisByHardwareId(hardwareId, buttonId, true, isX == true, isPositive == true);
		}

		function bind2dAnalogAxisByHardwareId(hardwareId, buttonId, isX, isPositive) {
			return this._bind2dAxisByHardwareId(hardwareId, buttonId, false, isX == true, isPositive == true);
		}
	}

	class GamepadEvent : Game.Event {
		field device;
		field deviceId;
		field buttonId;
		field value;
		field x;
		field y;

		constructor(device, buttonId, value, x, y) : base(Game.EventType.GAMEPAD) {
			this.device = device;
			this.deviceId = device._id;
			this.buttonId = buttonId;
			this.value = value;
			this.x = x;
			this.y = y;
		}
	}

	enum GamepadMashyType {
		BUTTON,
		ANALOG_AXIS,
		DIGITAL_AXIS,
	}
	class GamepadRawHardwareEvent : Game.Event {
		field device;
		field deviceId;
		field mashyType;
		field mashyIndex;
		field value;
		field isSignificant;
		field hardwareFingerprint;

		constructor(device, mashyType, mashyIndex, value, hardwareFingerprint) : base(Game.EventType.GAMEPAD_HARDWARE) {
			this.device = device;
			this.deviceId = device;
			this.mashyType = mashyType;
			this.mashyIndex = mashyIndex;
			this.value = value;
			if (mashyType == GamepadMashyType.ANALOG_AXIS) {
				this.isSignificant = Math.abs(value) > .5;
			} else {
				this.isSignificant = true;
			}
			this.hardwareFingerprint = hardwareFingerprint;
		}
	}
}
