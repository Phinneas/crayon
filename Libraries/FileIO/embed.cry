import FileIOCommon;

namespace FileIO {
	
	enum TextEncoding {
		UTF8 = FileIOCommon.FiocFileFormat.TEXT_UTF8,
		UTF8_BOM = FileIOCommon.FiocFileFormat.TEXT_UTF8_BOM,
		UTF16 = FileIOCommon.FiocFileFormat.TEXT_UTF16,
		UTF32 = FileIOCommon.FiocFileFormat.TEXT_UTF32,
		ASCII = FileIOCommon.FiocFileFormat.TEXT_ISO_8859,
	}
	
	class _FileIOHelper {
		static field FIOC = new FileIOCommon.FiocHelper('\\', null, false);
	}
	
	function pathJoin(parts) {
		return _FileIOHelper.FIOC.pathJoin(parts);
	}
	
	function pathExists(path) {
		info = _FileIOHelper.FIOC.getPathInfo(path);
		return info[0];
	}
	
	function _validateOutput(statusCode) {
		switch (statusCode) {
			case FileIOCommon.FiocStatus.OK: return;
			case FileIOCommon.FiocStatus.UNKNOWN_ERROR: Core.fail("An unknown error occurred."); break;
			case FileIOCommon.FiocStatus.PATH_WALKED_ABOVE_DOMAIN: Core.fail("Given path walked above allowed domain. Too many ..'s"); break;
			case FileIOCommon.FiocStatus.UNKNOWN_ENCODING: Core.fail("Unknown encoding"); break;
			case FileIOCommon.FiocStatus.NOT_FOUND: Core.fail("The given path was not found."); break;
			case FileIOCommon.FiocStatus.PATH_TO_LONG: Core.fail("The path is longer than the system allows."); break;
			case FileIOCommon.FiocStatus.INVALID_ARGUMENT: Core.fail("The input is invalid."); break;
			case FileIOCommon.FiocStatus.ENCODING_FAIL: Core.fail("The input could not be encoded into that encoding."); break;
			case FileIOCommon.FiocStatus.ACCESS_DENIED: Core.fail("Access to that resources is not allowed."); break;
			case FileIOCommon.FiocStatus.CANNOT_OVERWRITE: Core.fail("A file already exists at that location."); break;
		}
	}
	
	function fileWriteText(path, content, encoding = FileIO.TextEncoding.UTF8) {
		FileIO._validateOutput(_FileIOHelper.FIOC.fileWrite(path, content + '', encoding));
	}
	
	function fileReadText(path) {
		output = [];
		FileIO._validateOutput(_FileIOHelper.FIOC.fileRead(path, false, output));
		return output[0];
	}
	
	function fileReadLines(path) {
		return FileIOCommon.FiocHelper.textToLines(FileIO.fileReadText(path));
	}
	
	function fileWriteBytes(path, bytes) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.fileWrite(path, bytes, FileIOCommon.FiocFileFormat.BINARY));
	}
	
	function fileReadBytes(path) {
		output = [];
		FileIO._validateOutput(_FileIOHelper.FIOC.fileRead(path, true, output));
		return output;
	}
	
	function fileDelete(path) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.fileDelete(path));
	}
	
	function fileMove(pathFrom, pathTo, allowOverwrite = false) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.fileMove(pathFrom, pathTo, false, allowOverwrite));
	}
	
	function fileCopy(pathFrom, pathTo, allowOverwrite = false) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.fileMove(pathFrom, pathTo, true, allowOverwrite));
	}
	
	function directoryList(path, includeFullPath = false) {
		output = [];
		FileIO._validateOutput(_FileIOHelper.FIOC.directoryList(path, includeFullPath, output));
		return output;
	}
	
	function directoryCreate(path, makeParents = false) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.directoryCreate(path, makeParents));
	}
	
	function directoryDelete(path) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.directoryDelete(path));
	}
	
	function directoryMove(pathFrom, pathTo) {
		return FileIO._validateOutput(_FileIOHelper.FIOC.directoryMove(pathFrom, pathTo));
	}
	
	function currentDirectory() {
		return _FileIOHelper.FIOC.currentDirectoryString;
	}
}
