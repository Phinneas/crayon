function @type('int') libGfxGetImageSize(@type('object') imgObj, @type('Array<object>') output) {
	@type('Image') img = $_cast('Image', imgObj);
	$_array_set(output, 1, Image$img.width);
	$_array_set(output, 2, Image$img.height);
	return 0;
}

function @type('object') libGfxGetImgFromInstance(@type('Value') v) {
	@type('ObjectInstance') oi = $_cast('ObjectInstance', Value$v.internalValue);
	return $_array_get(ObjectInstance$oi.nativeData, 0);
}

// TODO: centralize this.
function @type('int') libGfxSetImgOnInstance(@type('Value') inst, @type('object') img) {
	@type('ObjectInstance') oi = $_cast('ObjectInstance', Value$inst.internalValue);
	@type('Array<object>') nd = ObjectInstance$oi.nativeData;
	if (nd == null) {
		nd = $_new_array('object', 1);
		ObjectInstance$oi.nativeData = nd;
	}
	$_array_set(nd, 0, img);
	return 0;
}

function @type('SpriteSheetData') gfxLibGetSpriteSheetData() {
	@type('ProgramData') p = $_get_program_data();
	return ProgramData$p.spriteSheetData;
}

function @type('int') declareSpriteSheet(
		@type('string') sheetName,
		@type('int') sheetIdNum) {
	@type('SpriteSheetData') spriteSheetData = gfxLibGetSpriteSheetData();
	$_dictionary_set(SpriteSheetData$spriteSheetData.filesByGroupId, sheetIdNum, $_new_list('string'));
	$_dictionary_set(SpriteSheetData$spriteSheetData.tileIdsByGroupId, sheetIdNum, $_new_dictionary('int', 'bool'));
	$_dictionary_set(SpriteSheetData$spriteSheetData.groupIdsByName, sheetName, sheetIdNum);
	return 0;
}

function @type('int') declareSpriteSheetImage(
		@type('int') groupId,
		@type('string') imagePath,
		@type('int') tileId, // top left corner
		@type('int') width,
		@type('int') height,
		@type('int') x,
		@type('int') y,
		@type('bool') solitary) {
	@type('SpriteSheetData') spriteSheetData = gfxLibGetSpriteSheetData();
	
	@type('SpriteSheetItemDescriptor') ssid = new SpriteSheetItemDescriptor(
		imagePath,
		groupId,
		0, // this may be unncessary
		tileId,
		solitary,
		x,
		y,
		width,
		height);

	$_dictionary_set(SpriteSheetData$spriteSheetData.files, imagePath, ssid);

	@type('Dictionary<int, bool>') tileIds = $_dictionary_get_guaranteed(SpriteSheetData$spriteSheetData.tileIdsByGroupId, groupId);
	@type('int') colSpan = $_int($_unsafe_integer_division(x % 256 + width - 1, 256)) + 1;
	@type('int') rowSpan = $_int($_unsafe_integer_division(y % 256 + height - 1, 256)) + 1;
	if (solitary) {
		colSpan = 1;
		rowSpan = 1;
	}
	for (@type('int') row = 0; row < rowSpan; row += 1) {
		for (@type('int') col = 0; col < colSpan; col += 1) {
			$_dictionary_set(tileIds, tileId + row * 4 + col, true);
		}
	}
	return 0;
}

function @type('int') lib_gfx_initializeSpriteSheetData(@type('string') spriteSheetManifest) {
	@type('SpriteSheetData') spriteSheetData = gfxLibGetSpriteSheetData();
	if (SpriteSheetData$spriteSheetData.initialized) return 0;
	SpriteSheetData$spriteSheetData.initialized = true;
	@type('Array<string>') lines = $_string_split(spriteSheetManifest, '\n');
	@type('int') i = 0;
	@type('string') t = '';
	while (i < $_array_length(lines)) {
		@type('Array<string>') parts = $_string_split($_string_trim($_array_get(lines, i)), ',');
		if ($_string_equals("0", $_array_get(parts, 0)) && $_array_length(parts) == 3) {
			declareSpriteSheet($_array_get(parts, 2), $_parse_int($_array_get(parts, 1)));
		} else if ($_string_equals("1", $_array_get(parts, 0))) {
			t = $_array_get(parts, 8);
			// in case there are commas in the filename.
			for (@type('int') j = 9; j < $_array_length(parts); j += 1) {
				t += ',';
				t += $_array_get(parts, j);
			}
			declareSpriteSheetImage(
				$_parse_int($_array_get(parts, 1)),
				t,
				$_parse_int($_array_get(parts, 2)),
				$_parse_int($_array_get(parts, 3)),
				$_parse_int($_array_get(parts, 4)),
				$_parse_int($_array_get(parts, 5)),
				$_parse_int($_array_get(parts, 6)),
				$_string_equals('1', $_array_get(parts, 7)));
		}
		i += 1;
	}
	lib_gfx_imageSheetStatusInitialization();
	return 0;
}

function lib_gfx_imageSheetStatusInitialization() {
	@type('ProgramData') p = $_get_program_data();
	@type('ImageSheetStatus') imageUtil = ProgramData$p.imageSheetStatus;
	@type('SpriteSheetData') ssd = ProgramData$p.spriteSheetData;
	@type('Array<string>') groupNames = $_dictionary_get_keys('string', SpriteSheetData$ssd.groupIdsByName);
	@type('int') i = 0;
	@type('int') id = 0;

	// Create a mapping of group names and group IDs.
	// Declare that these sheets are not loaded.
	// Determine which tile IDs are in which groups.
	for (i = 0; i < $_array_length(groupNames); i += 1) {
		@type('string') groupName = $_array_get(groupNames, i);
		id = $_dictionary_get_guaranteed(SpriteSheetData$ssd.groupIdsByName, groupName);
		$_dictionary_set(ImageSheetStatus$imageUtil.groupNameToId, groupName, id);
		$_dictionary_set(ImageSheetStatus$imageUtil.sheetStatus, id, IMAGE_SHEET_STATUS_NOT_LOADED);
		@type('Array<int>') tileIds = $_dictionary_get_keys('int', $_dictionary_get_guaranteed(SpriteSheetData$ssd.tileIdsByGroupId, id));
		@type('Array<int>') tileIdsSorted = $_sorted_copy_of_int_array(tileIds);
		$_dictionary_set(ImageSheetStatus$imageUtil.tilesPerId, id, tileIdsSorted);
	}

	// TODO: I should really add comments to the rest of this.
	@type('Dictionary<string, SpriteSheetItemDescriptor>') filesLookup = SpriteSheetData$ssd.files;
	@type('List<SpriteSheetItemDescriptor>') ssids = $_cast_to_list('SpriteSheetItemDescriptor', $_dictionary_get_values(filesLookup));
	for (i = 0; i < $_list_length(ssids); i += 1) {
		@type('SpriteSheetItemDescriptor') ssid = $_list_get(ssids, i);
		@type('List<SpriteSheetItemDescriptor>') ssidsForGroup = null;
		id = SpriteSheetItemDescriptor$ssid.groupId;
		if ($_dictionary_contains(ImageSheetStatus$imageUtil.spriteSheetItemDescriptorsByGroupId, id)) {
			ssidsForGroup = $_dictionary_get_guaranteed(ImageSheetStatus$imageUtil.spriteSheetItemDescriptorsByGroupId, id);
		} else {
			ssidsForGroup = $_new_list('SpriteSheetItemDescriptor');
			$_dictionary_set(ImageSheetStatus$imageUtil.spriteSheetItemDescriptorsByGroupId, id, ssidsForGroup);
		}
		$_list_push(ssidsForGroup, ssid);
	}

	@type('Array<int>') groupIds = $_dictionary_get_keys('int', SpriteSheetData$ssd.tileIdsByGroupId);
	for (i = 0; i < $_array_length(groupIds); i += 1) {
		id = $_array_get(groupIds, i);
		@type('Array<int>') keys = $_dictionary_get_keys('int', $_dictionary_get_guaranteed(SpriteSheetData$ssd.tileIdsByGroupId, id));
		@type('Array<string>') tileNamesForGroupId = $_new_array('string', $_array_length(keys));
		for (@type('int') j = 0; j < $_array_length(keys); j += 1) {
			@type('string') name = $_string_cast_weak(id) + "_" + $_string_cast_weak($_array_get(keys, j));
			$_array_set(tileNamesForGroupId, j, name);
		}
		$_dictionary_set(
			ImageSheetStatus$imageUtil.generatedTileNamesByGroupId,
			id,
			tileNamesForGroupId);
	}
}

function @type('int') lib_gfx_ensure_sprite_sheet_data_initialized() {
	@type('SpriteSheetData') ssd = gfxLibGetSpriteSheetData();
	if (!SpriteSheetData$ssd.initialized) {
		lib_gfx_initializeSpriteSheetData($_lib_gfx_image_sheet_get_manifest_file());
		SpriteSheetData$ssd.initialized = true;
	}
	return 0;
}

// returns false if the sheet name provided does not exist.
// This populates the entire loader queue for all the required tiles.
// This queue is pumped by the performWorkNugget[Pre|Post]Frame methods.
function @type('bool') lib_gfx_loadImageSheet(@type('string') groupName) {
	lib_gfx_ensure_sprite_sheet_data_initialized();
	@type('ProgramData') p = $_get_program_data();
	@type('ImageSheetStatus') iss = ProgramData$p.imageSheetStatus;
	
	// This group doesn't exist.
	if (!$_dictionary_contains(ImageSheetStatus$iss.groupNameToId, groupName)) {
		return false;
	}

	// Determine group ID.
	@type('int') groupId = $_dictionary_get_guaranteed(ImageSheetStatus$iss.groupNameToId, groupName);

	// Have you loaded this before? No-op.
	if ($_dictionary_get_guaranteed(ImageSheetStatus$iss.sheetStatus, groupId) != IMAGE_SHEET_STATUS_NOT_LOADED) {
		return true;
	}

	// At this point mark the sheet as being actively loaded.
	$_dictionary_set(ImageSheetStatus$iss.sheetStatus, groupId, IMAGE_SHEET_STATUS_LOADING);

	// Okay, so what do we actually need to load?
	@type('Array<int>') tileIds = $_dictionary_get_guaranteed(ImageSheetStatus$iss.tilesPerId, groupId);

	// Is this group empty? Honestly, that would be really weird. But let's check anyway and exit out if it is.
	if ($_array_length(tileIds) == 0) {
		// Mark it as done and exit out. This way it doesn't act like it's loading forever since the image load
		// handler is the thing that marks it as no longer loading.
		$_dictionary_set(ImageSheetStatus$iss.sheetStatus, groupId, IMAGE_SHEET_STATUS_LOADED);
		return true;
	}

	// Go through all the tile IDs and create a loader status object for each.
	// Add them to a queue.
	// This queue is pumped by the workNugget methods.
	for (@type('int') i = 0; i < $_array_length(tileIds); i += 1) {
		@type('int') tileId = $_array_get(tileIds, i);
		@type('string') tileGenName = $_string_cast_weak(groupId) + "_" + $_string_cast_weak(tileId);
		$_list_push(ImageSheetStatus$iss.tileLoadQueue,
			new TileLoadRequest(
				tileGenName,
				IMAGE_SHEET_STATUS_NOT_LOADED,
				groupId,
				groupName,
				tileId,
				null,
				''));
	}

	return true;
}

function lib_gfx_imageSheetPreFrameHandler() {

	@type('ImageSheetStatus') iss = getImageSheetStatus();
	@type('List<TileLoadRequest>') queue = ImageSheetStatus$iss.tileLoadQueue;
	if ($_list_length(queue) > 0) {
		// check to see if any tiles have been loaded.
		for (@type('int') i = 0; i < $_list_length(queue); i += 1) {
			@type('TileLoadRequest') request = $_list_get(queue, i);

			if (!%%%IMAGES_LOAD_INSTANTLY%%%) {
				if (TileLoadRequest$request.status == IMAGE_SHEET_STATUS_LOADING) {
					@type('string') key = TileLoadRequest$request.asyncReferenceKey;
					@type('object') platformImage = $_image_async_download_completed_payload(key);
					if (platformImage != null) {
						TileLoadRequest$request.status = IMAGE_SHEET_STATUS_LOADED;
						TileLoadRequest$request.nativeResource = platformImage;
					}
				}
			}

			if (TileLoadRequest$request.status == IMAGE_SHEET_STATUS_LOADED) {
				// [down]load complete. Add to the ImageSheetStatus and figure out if this was the last one for the group.
				$_dictionary_set(ImageSheetStatus$iss.tilesByName, TileLoadRequest$request.path, TileLoadRequest$request.nativeResource);
				@type('int') groupId = TileLoadRequest$request.groupId;
				if (areAllTilesLoadedForGroupId(iss, groupId)) {
					finalizeGroupLoading(groupId, TileLoadRequest$request.groupName);
				}
				$_list_remove_at(queue, i);
				i -= 1;
			}
		}
	}

	if (!%%%IMAGES_LOAD_INSTANTLY%%%) {
		// Are there any active async downloads?
		if ($_dictionary_size(ImageSheetStatus$iss.autogeneratedAsyncDownloadKeyToUserKeyLoop) > 0) {
			// Check to see if they're done.
			@type('Array<string>') autogenKeys = $_dictionary_get_keys('string', ImageSheetStatus$iss.autogeneratedAsyncDownloadKeyToUserKeyLoop);
			for (@type('int') j = $_array_length(autogenKeys) - 1; j >= 0; j -= 1) {
				@type('string') autogenKey = $_array_get(autogenKeys, j);
				@type('object') imageObject = $_image_async_download_completed_payload(autogenKey);
				if (imageObject != null) {
					// If the image is done, copy it to the userKey -> image resource lookup table and remove the autogen key entry.
					@type('CompositeImage') compositeImage = createCompositeImage(imageObject);
					@type('string') userKey = $_dictionary_get_guaranteed(ImageSheetStatus$iss.autogeneratedAsyncDownloadKeyToUserKeyLoop, autogenKey);
					$_dictionary_set(ImageSheetStatus$iss.resourceImagesByKeys, userKey, compositeImage);
					$_dictionary_remove(ImageSheetStatus$iss.autogeneratedAsyncDownloadKeyToUserKeyLoop, autogenKey);
				}
			}
		}
	}
}

function @type('bool') lib_gfx_initiateTileLoading(@type('TileLoadRequest') request) {
	if (%%%IMAGES_LOAD_INSTANTLY%%%) {
		// In most platforms, this is synchronous...
		TileLoadRequest$request.nativeResource = $_lib_gfx_read_tile_resource(TileLoadRequest$request.path);

		// ...and so you immediately want to mark the status as loaded.
		TileLoadRequest$request.status = IMAGE_SHEET_STATUS_LOADED;
	} else {
		@type('string') key = $_image_initiate_async_download_of_resource('%%%GENERATED_TILE_DIRECTORY%%%/' + TileLoadRequest$request.path + '.png');
		TileLoadRequest$request.asyncReferenceKey = key;
		TileLoadRequest$request.status = IMAGE_SHEET_STATUS_LOADING;
	}
	return true;
}

// Fire requests to load tiles
function lib_gfx_imageSheetPostFrameHandler() {

	@type('ImageSheetStatus') iss = getImageSheetStatus();

	@type('List<TileLoadRequest>') queue = ImageSheetStatus$iss.tileLoadQueue;
	if ($_list_length(queue) > 0) {
		// All requests are populated into the tile load queue when the user invokes the loading of a sheet.
		// This loop ensures that at least IMAGE_SHEET_TILES_LOADED_PER_FRAME downloads are active during the gap between frames.
		@type('int') activeDownloads = 0;
		for (@type('int') i = 0; i < $_list_length(queue) && activeDownloads < IMAGE_SHEET_TILES_LOADED_PER_FRAME; i += 1) {
			@type('TileLoadRequest') request = $_list_get(queue, i);
			if (TileLoadRequest$request.status == IMAGE_SHEET_STATUS_NOT_LOADED) {
				lib_gfx_initiateTileLoading(request);
				activeDownloads += 1;
			} else if (TileLoadRequest$request.status == IMAGE_SHEET_STATUS_LOADED) {
				// TODO: remove this once this has been thoroughly debugged
				$_assert("should not encounter a loaded image here.");
			}
		}
	}
}
