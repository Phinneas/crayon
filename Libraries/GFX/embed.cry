import Core;
import Math;

namespace GFX {

	enum _GFX_ImageLoaderType {
		RESOURCE,
		WEB,
		USER_DATA,
		FILE,
	}

	enum ImageLoaderStatus {
		LOADING = 0,
		OK = 1,
		NOT_STARTED = 2,
		NOT_FOUND = 3,
		INVALID = 4,
		TIMED_OUT = 5,
	}

	class ImageLoader {

		static field ID_ALLOC = 0;

		field _path;
		field _key;
		field _type;

		// TODO: private constructors
		constructor(type, path) {
			this._type = type;
			this._path = path;
			this._key = '' + ImageLoader.ID_ALLOC++;
		}

		static function fromResource(path) {
			loader = new ImageLoader(_GFX_ImageLoaderType.RESOURCE, path);
			$$lib_gfx_image_load_from_resource(loader._key, path);
			return loader;
		}

		static function fromWeb(url) {
			loader = new ImageLoader(_GFX_ImageLoaderType.WEB, url);
			$$lib_gfx_image_load_from_web(loader._key, url);
			return loader;
		}

		function retryWebLoad() {
			$$lib_gfx_image_load_from_web(this._key, this._path);
		}

		static function fromUserData(path) {
			loader = new ImageLoader(_GFX_ImageLoaderType.USER_DATA, path);
			$$lib_gfx_image_load_from_resource(loader._key, path);
			return loader;
		}

		static function fromFile(path) {
			assert(false, "Not implemented.");
		}

		function isDone() {
			return $$lib_gfx_is_image_loaded(this._key);
		}

		function getImage() {
			if (this.isDone()) {
				return new Image(this._key);
			}
			Core.assert(false, "Image not loaded yet.");
		}

		function getStatus() {
			// TODO: check what these values are and convert to the enum above.
			return $$lib_gfx_image_error_code(this._key);
		}
	}

	class Image {
		field width;
		field height;

		/*
			Native data:
			[0] -> raw image object
			[1] -> width
			[2] -> height
		*/
		constructor(_key) {
			// _key == null, or blank image objects, are used internally and are tweaked/populated manually by the library
			if (_key != null) {
				$$lib_gfx_image_get(this, _key); 
				this.width = $$lib_core_native_int(this, 1);
				this.height = $$lib_core_native_int(this, 2);
			}
		}

		// TODO: move all floor functions to inline in translated code.

		function draw(x, y) {
			$$lib_gfx_blit_image(this, floor(x), floor(y));
		}

		function drawPartial(tx, ty, sx, sy, width, height) {
			$$lib_gfx_blit_image_partial(this, tx, ty, sx, sy, width, height);
		}

		function drawStretched(tx, ty, tw, th) {
			return $$lib_gfx_blit_image_partial_at_scale(
				this,
				floor(tx), floor(ty),
				floor(tw), floor(th),
				0, 0,
				this.width, this.height);
		}

		function drawPartialStretched(tx, ty, tw, th, sx, sy, sw, sh) {
			return $$lib_gfx_blit_image_partial_at_scale(
				this,
				floor(tx), floor(ty),
				floor(tw), floor(th),
				floor(sx), floor(sy),
				floor(sw), floor(sh));
		}

		function drawRotated(x, y, theta) {
			// TODO: more efficient type checking
			// force types or crash.
			x = Math.floor(x);
			y = Math.floor(y);
			theta += 0.0;

			return $$lib_gfx_blit_image_rotated(this, x, y, theta);
		}

		function drawWithAlpha(x, y, alpha) {
			return $$lib_gfx_blit_image_with_alpha(this, x, y, alpha);
		}

		function flip(h, v) {
			if (h || v) {
				output = new Image(null);
				output.width = this.width;
				output.height = this.height;
				return $$lib_gfx_flip_image(this, output, h, v);
			}
			return this;
		}

		function scale(w, h) {
			// TODO: should negative scaling be considered flipping?
			w = Math.floor(w);
			h = Math.floor(h);
			assert(w > 0 && h > 0, "Image.scale arguments must be positive integers.");
			if (w == this.width && h == this.height) return this;
			output = new Image(null);
			output.width = w;
			output.height = h;
			return $$lib_gfx_image_scale(this, output, w, h);
		}
	}

	class ImageSheetLoader {

		field _ids;
		constructor(_ids) {
			this._ids = _ids;
		}

		static function fromIds(ids) {
			t = [];
			e = "Image sheet ID must be a string or non-empty list of strings.";
			if (typeof(ids) == Type.STRING) {
				t.add(ids);
			} else if (typeof(ids) == Type.LIST && ids.length > 0) {
				for (id : ids) {
					Core.assert(typeof(id) == Type.STRING, e);
					t.add(id);
				}
			} else {
				Core.assert(false, e);
			}
			$$lib_gfx_image_sheet_load(t);
			return new ImageSheetLoader(t);
		}

		function getProgress() {
			return $$lib_gfx_image_sheet_load_progress(this._ids);
		}

		function isDone() {
			return $$lib_gfx_image_sheet_loaded(this._ids);
		}
		
		function getStatus() {
			// TODO: convert into the same enum as ImageLoader
			return $$lib_gfx_image_sheet_error_code(this._ids);
		}
	}

	namespace Draw {
		function ellipse(left, top, width, height, r, g, b, a = 255) {
			return $$lib_gfx_draw_ellipse(left, top, width, height, r, g, b, a);
		}

		function line(startX, startY, endX, endY, strokeWidth, r, g, b, a = 255) {
			return $$lib_gfx_draw_line(startX, startY, endX, endY, strokeWidth, r, g, b, a);
		}

		function rectangle(left, top, width, height, r, g, b, a = 255) {
			return $$lib_gfx_draw_rectangle(left, top, width, height, r, g, b, a);
		}

		function triangle(ax, ay, bx, by, cx, cy, r, g, b, a = 255) {
			return $$lib_gfx_draw_triangle(ax, ay, bx, by, cx, cy, r, g, b, a);
		}

		function fill(r, g, b) {
			return $$lib_gfx_fill_screen(r, g, b);
		}
	}
}
