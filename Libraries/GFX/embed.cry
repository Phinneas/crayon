import Core;
import Game;
import Math;

namespace GFX {

	enum _GFX_ImageLoaderType {
		RESOURCE,
		WEB,
		USER_DATA,
		FILE,
	}

	enum ImageLoaderStatus {
		LOADING = 0,
		OK = 1,
		NOT_STARTED = 2,
		NOT_FOUND = 3,
		INVALID = 4,
		TIMED_OUT = 5,
	}

	class ImageLoader {

		static field ID_ALLOC = 0;

		field _path;
		field _key;
		field _type;

		// TODO: private constructors
		constructor(type, path) {
			this._type = type;
			this._path = path;
			this._key = '' + ImageLoader.ID_ALLOC++;
		}

		static function fromResource(path) {
			loader = new ImageLoader(_GFX_ImageLoaderType.RESOURCE, path);
			$$lib_gfx_image_load_from_resource(loader._key, path);
			return loader;
		}

		static function fromWeb(url) {
			loader = new ImageLoader(_GFX_ImageLoaderType.WEB, url);
			$$lib_gfx_image_load_from_web(loader._key, url);
			return loader;
		}

		function retryWebLoad() {
			$$lib_gfx_image_load_from_web(this._key, this._path);
		}

		static function fromUserData(path) {
			loader = new ImageLoader(_GFX_ImageLoaderType.USER_DATA, path);
			$$lib_gfx_image_load_from_resource(loader._key, path);
			return loader;
		}

		static function fromFile(path) {
			assert(false, "Not implemented.");
		}

		function isDone() {
			return $$lib_gfx_is_image_loaded(this._key);
		}

		function getImage() {
			if (this.isDone()) {
				return new Image(this._key);
			}
			Core.assert(false, "Image not loaded yet.");
		}

		function getStatus() {
			// TODO: check what these values are and convert to the enum above.
			return $$lib_gfx_image_error_code(this._key);
		}
	}

	enum _ImageDrawParamType {
		/*
			5,
			1,
			x,
			y,
			alpha,
		*/
		SIMPLE = 1,
		
		/*
			5,
			2,
			sourceX,
			sourceY,
			sourceWidth,
			sourceHeight,
			targetX,
			targetY,
			targetWidth,
			targetHeight,
			alpha,
		*/
		SLICE_N_STRETCH = 2,
		
		ROTATE_WITH_OPTIONS = 4,
	}

	class Image {
		field width;
		field height;

		static constructor() {
			$$lib_gfx_renderQueueAction(Draw._queue, 0); // essentially no-ops, but runs the queue initializers. 
		}

		/*
			Native data:
			[0] -> raw image object
			[1] -> width
			[2] -> height
		*/
		constructor(_key) {
			// _key == null, or blank image objects, are used internally and are tweaked/populated manually by the library
			if (_key != null) {
				$$lib_gfx_image_get(this, _key); 
				this.width = $$$('nativeInt', this, 1);
				this.height = $$$('nativeInt', this, 2);
			}
		}

		/*
			[0] -> GFX._DrawCommands.IMAGE,
			
			[1] -> optionFlagsBitMask {
				1 - slice,
				2 - stretch,
				4 - rotate,
				8 - alpha
			}
			
			// used if slice is enabled
			[2] -> sourceX, 
			[3] -> sourceY,
			[4] -> sourceWidth,
			[5] -> sourceHeight,
			
			// used if stretch is enabled
			[6] -> drawWidth,
			[7] -> drawHeight
			
			// these are top left corner unless rotate flag is enabled
			[8] -> targetX, 
			[9] -> targetY,
			
			// used if rotate is enabled
			[10] -> theta * 1048576,
			
			// used if alpha is enabled
			[11] -> alpha value
			
		*/
		function draw(x, y) {
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				0,
				0, 0, 0, 0,
				0, 0,
				x, y,
				0,
				0) ? null : Core.fail("Invalid arguments");
		}

		function drawWithAlpha(x, y, alpha) {
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				8,
				0, 0, 0, 0,
				0, 0,
				x, y,
				0,
				alpha) ? null : Core.fail("Invalid arguments");
		}

		function drawRegion(x, y, sx, sy, width, height) {
			if (width == 0 || height == 0) return;
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				1,
				sx, sy, width, height,
				0, 0,
				x, y,
				0,
				0) ? null : Core.fail("Invalid arguments");
		}

		function drawStretched(x, y, width, height) {
			if (width == 0 || height == 0) return;
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				2,
				0, 0, 0, 0,
				width, height,
				x, y,
				0,
				0) ? null : Core.fail("Invalid arguments");
		}

		function drawRegionStretched(tx, ty, tw, th, sx, sy, sw, sh) {
			if (tw == 0 || th == 0 || sw == 0 || sh == 0) return;
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				1 | 2,
				sx, sy, sw, sh,
				tw, th,
				tx, ty,
				0,
				0) ? null : Core.fail("Invalid arguments");
		}

		function drawRegionStretchedWithAlpha(tx, ty, tw, th, sx, sy, sw, sh, alpha) {
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				1 | 2 | 8,
				sx, sy, sw, sh,
				tw, th,
				tx, ty,
				0,
				0) ? null : Core.fail("Invalid arguments");
		}

		function drawRotated(x, y, theta) {
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				4,
				0, 0, 0, 0,
				0, 0,
				x, y,
				theta,
				0) ? null : Core.fail("Invalid arguments");
		}

		function drawRotatedWithAlpha(x, y, theta, alpha) {
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				4 | 8,
				0, 0, 0, 0,
				0, 0,
				x, y,
				theta,
				alpha) ? null : Core.fail("Invalid arguments");
		}
		
		function drawWithOptions(tx, ty, tw, th, sx, sy, sw, sh, theta, alpha) {
			return $$lib_gfx_addImageRenderEvent(
				GFX.Draw._queue, this,
				1 | 2 | 4 | 8,
				sx, sy, sw, sh,
				tw, th,
				tx, ty,
				theta,
				alpha) ? null : Core.fail("Invalid arguments");
		}

		function flip(h, v) {
			if (h || v) {
				output = new Image(null);
				output.width = this.width;
				output.height = this.height;
				return $$lib_gfx_flip_image(this, output, h, v);
			}
			return this;
		}

		function scale(w, h) {
			// TODO: should negative scaling be considered flipping?
			w = Math.floor(w);
			h = Math.floor(h);
			assert(w > 0 && h > 0, "Image.scale arguments must be positive integers.");
			if (w == this.width && h == this.height) return this;
			output = new Image(null);
			output.width = w;
			output.height = h;
			return $$lib_gfx_image_scale(this, output, w, h);
		}
	}

	class ImageSheetLoader {

		field _ids;
		constructor(_ids) {
			this._ids = _ids;
		}

		static constructor() {
			Game.GameWindow._frameBeginHandlers.add(ImageSheetLoader._framePreHandler);
			Game.GameWindow._frameBeginHandlers.add(ImageSheetLoader._framePostHandler);
		}

		static function _framePreHandler() { return $$lib_gfx_image_sheet_pre_frame_handler(); }
		static function _framePostHandler() { return $$lib_gfx_image_sheet_post_frame_handler(); }
		
		static function fromIds(ids) {
			t = [];
			e = "Image sheet ID must be a string or non-empty list of strings.";
			if (typeof(ids) == Type.STRING) {
				t.add(ids);
			} else if (typeof(ids) == Type.LIST && ids.length > 0) {
				for (id : ids) {
					Core.assert(typeof(id) == Type.STRING, e);
					t.add(id);
				}
			} else {
				Core.assert(false, e);
			}
			$$lib_gfx_image_sheet_load(t);
			return new ImageSheetLoader(t);
		}

		function getProgress() {
			return $$lib_gfx_image_sheet_load_progress(this._ids);
		}

		function isDone() {
			return $$lib_gfx_image_sheet_loaded(this._ids);
		}
		
		function getStatus() {
			// TODO: convert into the same enum as ImageLoader
			return $$lib_gfx_image_sheet_error_code(this._ids);
		}
	}

	enum _DrawCommands {
		RECTANGLE = 1,
		ELLIPSE = 2,
		LINE = 3,
		TRIANGLE = 4,
		
		/*
			5
			
		*/
		IMAGE = 5,
		
	}
	
	class Draw {
		
		static field _queue = new Object();
		static constructor() {
			$$lib_gfx_renderQueueAction(Draw._queue, 0); // essentially no-ops, but runs the queue initializers.
			Game.GameWindow._frameEndHandlers.add(GFX.Draw._renderer);
			Game.GameWindow._frameBeginHandlers.add(GFX.Draw._rendererReset);
		}
		constructor() { Core.fail(); }
		
		static function _renderer() {
			// send the render queue to the platform renderer
			return $$lib_gfx_renderQueueAction(GFX.Draw._queue, 1);
		}
		
		static function _rendererReset() {
			// clear the render queue
			return $$lib_gfx_renderQueueAction(GFX.Draw._queue, 2);
		}
		
		static function ellipse(left, top, width, height, r, g, b, a = 255) {
			return $$$('intQueueWrite16', GFX.Draw._queue,
				_DrawCommands.ELLIPSE,
				left, top, width, height, r, g, b, a);
		}

		static function line(startX, startY, endX, endY, strokeWidth, r, g, b, a = 255) {
			return $$$('intQueueWrite16', GFX.Draw._queue,
				_DrawCommands.LINE,
				startX, startY, endX, endY, strokeWidth, r, g, b, a);
		}

		static function rectangle(left, top, width, height, r, g, b, a = 255) {
			return $$$('intQueueWrite16', GFX.Draw._queue,
				_DrawCommands.RECTANGLE,
				left, top, width, height, r, g, b, a);
		}

		static function triangle(ax, ay, bx, by, cx, cy, r, g, b, a = 255) {
			return $$$('intQueueWrite16', GFX.Draw._queue,
				_DrawCommands.TRIANGLE,
				ax, ay, bx, by, cx, cy, r, g, b, a);
		}

		static function fill(r, g, b) {
			t = Game.GameWindow.instance;
			$$lib_gfx_renderQueueAction(GFX.Draw._queue, 2);
			return GFX.Draw.rectangle(0, 0, t._w, t._h, r, g, b);
		}
	}
}
