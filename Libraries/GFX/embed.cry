import Core;
import Math;

namespace GFX {

	enum _GFX_ImageLoaderType {
		RESOURCE,
		WEB,
		USER_DATA,
		FILE,
	}

	enum ImageLoaderStatus {
		LOADING = 0,
		OK = 1,
		NOT_FOUND = 2,
		INVALID = 3,
		TIMED_OUT = 4,
	}

	class ImageLoader {

		static field ID_ALLOC = 0;

		field _path;
		field _key;
		field _type;

		// TODO: private constructors
		constructor(type, path) {
			this._type = type;
			this._path = path;
			this._key = '' + ImageLoader.ID_ALLOC++;
		}

		static function fromResource(path) {
			loader = new ImageLoader(_GFX_ImageLoaderType.RESOURCE, path);
			$$lib_gfx_image_load_from_resource(loader._key, path);
			return loader;
		}

		static function fromWeb(url) {
			loader = new ImageLoader(_GFX_ImageLoaderType.WEB, url);
			$$lib_gfx_image_load_from_web(loader._key, url);
			return loader;
		}

		function retryWebLoad() {
			$$lib_gfx_image_load_from_web(this._key, this._path);
		}

		static function fromUserData(path) {
			loader = new ImageLoader(_GFX_ImageLoaderType.USER_DATA, path);
			$$lib_gfx_image_load_from_resource(loader._key, path);
			return loader;
		}

		static function fromFile(path) {
			assert(false, "Not implemented.");
		}

		function isDone() {
			return $$lib_gfx_is_image_loaded(this._key);
		}

		function getImage() {
			if (this.isDone()) {
				img = $$lib_gfx_image_get(this._key);
				return new Image(img);
			}
			Core.assert(false, "Image not loaded yet.");
		}

		function getStatus() {
			// TODO: check what these values are and convert to the enum above.
			return $$lib_gfx_image_error_code(this._key);
		}
	}

	class Image {
		field width;
		field height;
		field _native;

		constructor(_native) {
			this._native = _native;
			this.width = $$lib_gfx_image_width(_native);
			this.height = $$lib_gfx_image_height(_native);
		}

		function draw(x, y) {
			$$lib_gfx_blit_image(this._native, x, y);
		}

		function drawPartial(tx, ty, sx, sy, width, height) {
			$$lib_gfx_blit_image_partial(this._native, tx, ty, sx, sy, width, height);
		}

		function drawStretched(tx, ty, tw, th) {
			return $$lib_gfx_blit_image_partial_at_scale(
				this._native,
				tx, ty, 
				tw, th, 
				0, 0,
				this.width, this.height);
		}

		function drawPartialStretched(tx, ty, tw, th, sx, sy, sw, sh) {
			return $$lib_gfx_blit_image_partial_at_scale(
				this._native,
				tx, ty,
				tw, th,
				sx, sy,
				sw, sh);
		}

		function flip(h, v) {
			if (h || v) {
				img = $$lib_gfx_image_flip(this._native, h, v);
				return new Image(img);
			}
			return this;
		}

		function scale(w, h) {
			assert(w > 0 && h > 0, "Image.scale arguments must be positive integers.");
			return $$lib_gfx_image_scale(this._native, Math.floor(w), Math.floor(h));
		}
	}

	class ImageSheetLoader {

		field _ids;
		constructor(_ids) {
			this._ids = _ids;
		}

		function fromIds(ids) {
			$$lib_gfx_image_sheet_load(ids);
			return new ImageSheetLoader(ids);
		}

		function progress() {
			return $$lib_gfx_image_sheet_load_progress(this._ids);
		}

		function isDone() {
			return $$lib_gfx_image_sheet_loaded(this._ids);
		}
		
		function getStatus() {
			// TODO: convert into the same enum as ImageLoader
			return $$lib_gfx_image_sheet_error_code(this._ids);
		}
	}

	namespace Draw {
		function ellipse(left, top, width, height, r, g, b, a = 255) {
			return $$lib_gfx_draw_ellipse(left, top, width, height, r, g, b, a);
		}

		function line(startX, startY, endX, endY, strokeWidth, r, g, b, a = 255) {
			return $$lib_gfx_draw_line(startX, startY, endX, endY, strokeWidth, r, g, b, a);
		}

		function rectangle(left, top, width, height, r, g, b, a = 255) {
			return $$lib_gfx_draw_rectangle(left, top, width, height, r, g, b, a);
		}

		function triangle(ax, ay, bx, by, cx, cy, r, g, b, a = 255) {
			return $$lib_gfx_draw_triangle(ax, ay, bx, by, cx, cy, r, g, b, a);
		}

		function fill(r, g, b) {
			return $$lib_gfx_fill_screen(r, g, b);
		}
	}
}
