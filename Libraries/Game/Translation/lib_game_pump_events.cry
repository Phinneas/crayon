/*
	arg[0] -> a re-usable value list to push event fields onto
*/

import inline "InterpreterSource/FrameworkFunctions/1_arg.cry";

libGamePumpEvents($_cast('List<Value>', Value$arg1.internalValue));
output = arg1;

/*
list1 = $_get_events_raw_list();

// TODO: this will have to be done differently.
// very likely in embeded interpreted code, where the Game library will have to support some sort of 
// event handler to inject the Gamepad events before returning from pump_events. 
if ($_list_length(GamepadStatus$gamepadStatus.hardwareEvents) > 0) {
	list2 = GamepadStatus$gamepadStatus.hardwareEvents;
	for (int1 = 0; int1 < $_list_length(list2); int1 += 1) {
		$_list_push(list1, $_list_get(list2, int1));
	}
	$_list_clear(GamepadStatus$gamepadStatus.hardwareEvents);
}

if ($_list_length(GamepadStatus$gamepadStatus.virtualEvents) > 0) {
	list2 = GamepadStatus$gamepadStatus.virtualEvents;
	for (int1 = 0; int1 < $_list_length(list2); int1 += 1) {
		$_list_push(list1, $_list_get(list2, int1));
	}
	$_list_clear(GamepadStatus$gamepadStatus.virtualEvents);
}//*/

output = arg1;
