package %%%PACKAGE%%%;

import java.awt.geom.AffineTransform;
import java.awt.AlphaComposite;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.awt.Graphics2D;

public final class RenderEngine {

    private static final int BLIT_IMAGE = 1;
    private static final int BLIT_IMAGE_PARTIAL = 2;
    private static final int BLIT_IMAGE_ALPHA = 3;
    private static final int BLIT_IMAGE_ROTATED = 4;
    private static final int DRAW_ELLIPSE = 5;
    private static final int DRAW_LINE = 6;
    private static final int DRAW_RECTANGLE = 7;
    private static final int DRAW_TRIANGLE = 8;
    private static final int FILL_SCREEN = 9;

    private static int[] renderArgs = new int[1000];
    private static int renderArgsVirtualLength = 0;
    private static int renderArgsRealLength = renderArgs.length;

	private static int[] renderEvents = new int[0];
	private static int renderEventsLength = 0;
	private static Object[] renderImages = new Object[0];

    private static AlphaComposite[] alphaComposite = new AlphaComposite[256];

    private RenderEngine() { }

	public static void setRenderQueues(int[] renderEvents, int renderEventsLength, Object[] images) {
		RenderEngine.renderEvents = renderEvents;
		RenderEngine.renderEventsLength = renderEventsLength;
		RenderEngine.renderImages = images;
	}
	
    public static void render(Graphics2D g, int canvasWidth, int canvasHeight) {

        if (alphaComposite[0] == null) {
            for (int i = 0; i < 256; ++i) {
                alphaComposite[i] = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, i / 255f);
            }
        }

        int x, y, sx, sy, width, height, sw, sh, tw, th, red, green, blue, alpha;
        int ax, ay, bx, by, cx, cy;
		int mask;
        int[] xs = new int[3];
        int[] ys = new int[3];
        double angle;
        java.awt.image.BufferedImage image;
		AffineTransform at;
		int[] events = RenderEngine.renderEvents;
		int length = RenderEngine.renderEventsLength;
		Object[] images = RenderEngine.renderImages;
		Object[] textureNativeData;
		Object[] textureResourceNativeData;
		int imagesIndex = 0;

        for (int i = 0; i < renderEventsLength; i += 16) {
            switch (events[i]) {
				case 1: // rectangle
					x = events[i | 1];
					y = events[i | 2];
					width = events[i | 3];
					height = events[i | 4];
					red = events[i | 5];
					green = events[i | 6];
					blue = events[i | 7];
					alpha = events[i | 8];
                    // TODO: need a really fast caching mechanism for colors so I don't always rapidly alloc this
                    g.setColor(new Color(red, green, blue, alpha));
                    g.fillRect(x, y, width, height);
					break;

				case 2: // ellipse
					x = events[i | 1];
					y = events[i | 2];
					width = events[i | 3];
					height = events[i | 4];
					red = events[i | 5];
					green = events[i | 6];
					blue = events[i | 7];
					alpha = events[i | 8];
                    g.setColor(new Color(red, green, blue, alpha));
                    g.fillOval(x, y, width, height);
					break;

				case 3: // line
					break;

				case 4: // triangle
					break;

				case 5: // image
					mask = events[i | 1];
					x = events[i | 8];
					y = events[i | 9];

					textureNativeData = (Object[]) images[imagesIndex++];
					textureResourceNativeData = (Object[]) textureNativeData[0];
					image = (BufferedImage) textureResourceNativeData[3];
					
					if (mask == 0) {
						g.drawImage(image, x, y, null);
					} else {
						
						if ((mask & 1) != 0) {
							sx = events[i | 2];
							sy = events[i | 3];
							sw = events[i | 4];
							sh = events[i | 5];
						} else {
							sx = 0;
							sy = 0;
							sw = image.getWidth();
							sh = image.getHeight();
						}

						if ((mask & 2) != 0) {
							tw = events[i | 6];
							th = events[i | 7];
						} else {
							tw = sw;
							th = sh;
						}

						if ((mask & 8) != 0) {
							alpha = events[i | 11];
						} else {
							alpha = 255;
						}

						if ((mask & 4) != 0) {
							angle = events[i | 10] / 1048576.0;
							at = new AffineTransform();
							at.translate(x - tw / 2, y - th / 2);
							at.translate(tw / 2, th/ 2);
							at.rotate(angle);
							at.translate(tw / -2, th / -2);
							
							if (alpha == 255) {
								g.drawImage(image, at, null);
							} else {
								g.setComposite(alphaComposite[alpha]);
								g.drawImage(image, at, null);
								g.setComposite(alphaComposite[255]);
							}
						} else {
							if (alpha == 255) {
								g.drawImage(image, x, y, x + tw, y + th, sx, sy, sx + sw, sy + sh, null);
							} else {
								g.setComposite(alphaComposite[alpha]);
								g.drawImage(image, x, y, x + tw, y + th, sx, sy, sx + sw, sy + sh, null);
								g.setComposite(alphaComposite[255]);
							}
						}
					}
					break;

                case FILL_SCREEN + 100:
					/*/
                    red = renderArgs[index++];
                    green = renderArgs[index++];
                    blue = renderArgs[index++];
                    
                    g.setColor(new Color(red, green, blue));
                    g.fillRect(-1, -1, canvasWidth + 2, canvasHeight + 2);
					//*/
                    break;

                case BLIT_IMAGE + 100:
					/*/
                    image = images[imagesIndex++];
                    x = renderArgs[index++];
                    y = renderArgs[index++];

                    g.drawImage((java.awt.Image) image.rawResource, x, y, null);
					//*/
                    break;

                case BLIT_IMAGE_ALPHA + 100:
					/*/
                    image = images[imagesIndex++];
                    x = renderArgs[index++];
                    y = renderArgs[index++];
                    alpha = renderArgs[index++];
                    g.setComposite(alphaComposite[alpha]);
                    g.drawImage((java.awt.Image) image.rawResource, x, y, null);
                    g.setComposite(alphaComposite[255]);
					//*/
                    break;

				case BLIT_IMAGE_ROTATED + 100:
					/*/
                    image = images[imagesIndex++];
                    x = renderArgs[index++];
                    y = renderArgs[index++];
                    angle = renderArgs[index++] / 1000000.0;
					at = new AffineTransform();
					width = image.width;
					height = image.height;
					at.translate(x - width / 2, y - height / 2);
					at.translate(width / 2, height / 2);
					at.rotate(angle);
					at.translate(width / -2, height / -2);
					g.drawImage((java.awt.Image) image.rawResource, at, null);
					//*/
					break;
					
                case BLIT_IMAGE_PARTIAL + 100:
					/*/
                    image = images[imagesIndex++];
                    x = renderArgs[index++];
                    y = renderArgs[index++];
                    sx = renderArgs[index++];
                    sy = renderArgs[index++];
                    width = renderArgs[index++];
                    height = renderArgs[index++];
                    g.drawImage((java.awt.Image) image.rawResource, x, y, x + width, y + height, sx, sy, sx + width, sy + height, null);
					//*/
                    break;

                case DRAW_ELLIPSE + 100:
					/*/
                    x = renderArgs[index++];
                    y = renderArgs[index++];
                    width = renderArgs[index++];
                    height = renderArgs[index++];
                    red = renderArgs[index++];
                    green = renderArgs[index++];
                    blue = renderArgs[index++];
                    alpha = renderArgs[index++];
                    g.setColor(new Color(red, green, blue, alpha));
                    g.fillOval(x, y, width, height);
                    //*/
                    break;

                case DRAW_LINE + 100:
					/*/
                    sx = renderArgs[index++];
                    sy = renderArgs[index++];
                    x = renderArgs[index++];
                    y = renderArgs[index++];
                    width = renderArgs[index++];
                    red = renderArgs[index++];
                    green = renderArgs[index++];
                    blue = renderArgs[index++];
                    alpha = renderArgs[index++];
                    g.setColor(new Color(red, green, blue, alpha));
                    g.setStroke(new java.awt.BasicStroke(width));
                    g.drawLine(x, y, sx, sy);
                    //*/
                    break;

                case DRAW_RECTANGLE + 100:
					/*/
                    x = renderArgs[index++];
                    y = renderArgs[index++];
                    width = renderArgs[index++];
                    height = renderArgs[index++];
                    red = renderArgs[index++];
                    green = renderArgs[index++];
                    blue = renderArgs[index++];
                    alpha = renderArgs[index++];

                    // TODO: need a really fast caching mechanism for colors so I don't always rapidly alloc this
                    g.setColor(new Color(red, green, blue, alpha));
                    g.fillRect(x, y, width, height);
                    //*/
                    break;

                case DRAW_TRIANGLE + 100:
					/*/
                    xs[0] = renderArgs[index++];
                    ys[0] = renderArgs[index++];
                    xs[1] = renderArgs[index++];
                    ys[1] = renderArgs[index++];
                    xs[2] = renderArgs[index++];
                    ys[2] = renderArgs[index++];
                    red = renderArgs[index++];
                    green = renderArgs[index++];
                    blue = renderArgs[index++];
                    alpha = renderArgs[index++];

                    g.setColor(new Color(red, green, blue, alpha));
                    g.fillPolygon(xs, ys, 3);
                    //*/
                    break;
            }
        }
    }

	/*
    private static void expandArgsCapacity() {
        int[] newRenderArgs = new int[renderArgsRealLength * 2];
        System.arraycopy(renderArgs, 0, newRenderArgs, 0, renderArgsVirtualLength);
        renderArgs = newRenderArgs;
        renderArgsRealLength = renderArgs.length;
    }

    private static void expandImagesCapacity() {
        Image[] newImages = new Image[imagesRealLength * 2];
        System.arraycopy(images , 0, newImages, 0, imagesVirtualLength);
        images = newImages;
        imagesRealLength = images.length;
    }//*/
}
