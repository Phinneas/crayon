typedef struct DictStringBucket_t {
	String* key;
	int hash_code;
	void* value;
	struct DictStringBucket_t* next;
} DictStringBucket;

typedef struct DictString_t {
	int size;
	int bucket_count;
	int hash_mask;
	DictStringBucket** buckets;
} DictString;

DictString* DictString_new()
{
	DictString* output = (DictString*) malloc(sizeof(DictString));
	output->size = 0;
	output->bucket_count = 0;
	return output;
}

void* DictString_get(DictString* dict, String* key)
{
	int hash_code = key->hash_code == 0 ? String_compute_hash_code(key) : key->hash_code;
	DictStringBucket* bucket = dict->buckets[hash_code & dict->hash_mask];
	while (bucket != NULL)
	{
		if (String_equals(bucket->key, key))
		{
			return bucket->value;
		}
	}
	return NULL;
}

void DictString_add(DictString* dict, String* key, void* value)
{
	if (dict->size == dict->bucket_count)
	{
		if (dict->size == 0)
		{
			dict->bucket_count = 8;
			dict->hash_mask = 3;
			dict->buckets = (DictStringBucket**) malloc(sizeof(DictStringBucket*) * 8);
			for (int i = 0; i < 8; ++i)
			{
				dict->buckets[i] = NULL;
			}
		}
		else
		{
			int old_bucket_count = dict->bucket_count;
			int new_bucket_count = old_bucket_count * 2;
			int old_hash_mask = dict->hash_mask;
			int new_hash_mask = old_hash_mask * 2 + 1;
			DictStringBucket** new_buckets = (DictStringBucket**) malloc(sizeof(DictStringBucket*) * new_bucket_count);
			DictStringBucket** old_buckets = dict->buckets;
			dict->buckets = new_buckets;
			dict->bucket_count = new_bucket_count;
			dict->hash_mask = new_hash_mask;
			dict->size = 0;
			int i = new_bucket_count;
			while (--i >= 0)
			{
				new_buckets[i] = NULL;
			}
			
			DictStringBucket* bucket;
			DictStringBucket* next_bucket;
			int bucket_index;
			for (int i = 0; i < old_bucket_count; ++i)
			{
				bucket = old_buckets[i];
				while (bucket != NULL)
				{
					next_bucket = bucket->next;
					bucket_index = bucket->hash_code & new_hash_mask;
					bucket->next = new_buckets[bucket_index];
					new_buckets[bucket_index] = bucket;
					bucket = next_bucket;
				}
			}

			free(old_buckets);
		}
	}

	int hash_code = key->hash_code;
	if (hash_code == 0) hash_code = String_compute_hash_code(key);
	int bucket_index = hash_code & dict->hash_mask;
	DictStringBucket* existing_bucket = dict->buckets[bucket_index];
	while (existing_bucket != NULL)
	{
		if (String_equals(existing_bucket->key, key))
		{
			// Overwrite existing value
			existing_bucket->value = value;
			return;
		}
		existing_bucket = existing_bucket->next;
	}

	// Existing value not found.
	DictStringBucket* new_bucket = (DictStringBucket*) malloc(sizeof(DictStringBucket));
	new_bucket->key = key;
	new_bucket->hash_code = hash_code;
	new_bucket->value = value;
	new_bucket->next = dict->buckets[bucket_index];
	dict->buckets[bucket_index] = new_bucket;
	dict->size++;
}
