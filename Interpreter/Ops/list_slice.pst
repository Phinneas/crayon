int5 = 0;
if (row[2] == 1) {
	valueStackSize -= 1;
	arg3 = valueStack[valueStackSize];
	if (arg3.type == Types.INTEGER) {
		int3 = ((int) arg3.internalValue);
		if (int3 == 0) {
			int5 = 2;
		}
	} else {
		int5 = 3;
		int3 = 1;
	}
} else {
	int3 = 1;
}
bool1 = int3 > 0;
if (row[1] == 1) {
	valueStackSize -= 1;
	arg2 = valueStack[valueStackSize];
	if (arg2.type == Types.INTEGER) {
		int2 = ((int) arg2.internalValue);
	} else {
		int5 = 3;
	}
} else {
	arg2 = null;
}
if (row[0] == 1) {
	valueStackSize -= 1;
	arg1 = valueStack[valueStackSize];
	if (arg1.type == Types.INTEGER) {
		int1 = ((int) arg1.internalValue);
	} else {
		int5 = 3;
	}
} else {
	arg1 = null;
}
value = valueStack[(valueStackSize - 1)];
if (value.type == Types.STRING) {
	bool2 = true;
	string1 = ((string) value.internalValue);
	int4 = string1.Size();
} else {
	if (value.type == Types.LIST) {
		bool2 = false;
		list1 = ((List<Value>) value.internalValue);
		int4 = list1.Size();
	} else {
		return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, Core.StringConcatAll("Cannot apply slicing to ", getTypeFromId(value.type), ". Must be string or list."));
	}
}
if (int5 >= 2) {
	if (bool2) {
		string1 = "String";
	} else {
		string1 = "List";
	}
	if (int5 == 3) {
		Core.StringAppend(string1, "slice indexes must be integers. Found ");
		if ((arg1 != null) && (arg1.type != Types.INTEGER)) {
			return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, Core.StringConcatAll(string1, getTypeFromId(arg1.type), " for begin index."));
		}
		if ((arg2 != null) && (arg2.type != Types.INTEGER)) {
			return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, Core.StringConcatAll(string1, getTypeFromId(arg2.type), " for end index."));
		}
		if ((arg3 != null) && (arg3.type != Types.INTEGER)) {
			return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, Core.StringConcatAll(string1, getTypeFromId(arg3.type), " for step amount."));
		}
		return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, "Invalid slice arguments.");
	} else {
		return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, Core.StringConcatAll(string1, " slice step cannot be 0."));
	}
}
int5 = canonicalizeListSliceArgs(Core.IntBuffer16, arg1, arg2, int1, int2, int3, int4, bool1);
if (int5 == 1) {
	int1 = Core.IntBuffer16[0];
	int2 = Core.IntBuffer16[1];
	if (bool2) {
		stringList1 = new List<string>();
		if (bool1) {
			while (int1 < int2) {
				stringList1.Add(Core.CharToString(string1[int1]));
				int1 += int3;
			}
		} else {
			while (int1 > int2) {
				stringList1.Add(Core.CharToString(string1[int1]));
				int1 += int3;
			}
		}
		value = buildString(stringList1.Join(""));
	} else {
		list2 = new List<Value>();
		if (bool1) {
			while (int1 < int2) {
				list2.Add(list1[int1]);
				int1 += int3;
			}
		} else {
			while (int1 > int2) {
				list2.Add(list1[int1]);
				int1 += int3;
			}
		}
		value = new Value(Types.LIST, list2);
	}
} else {
	if (int5 == 0) {
		if (bool2) {
			value = VALUE_EMPTY_STRING;
		} else {
			value = new Value(Types.LIST, new List<Value>());
		}
	} else {
		if (int5 == 2) {
			if (!bool2) {
				list2 = new List<Value>();
				for (i = 0; i < int4; i += 1) {
					list2.Add(list1[i]);
				}
				value = new Value(Types.LIST, list2);
			}
		} else {
			if (bool2) {
				string1 = "String";
			} else {
				string1 = "List";
			}
			if (int5 == 3) {
				Core.StringAppend(string1, " slice begin index is out of range.");
			} else {
				if (bool1) {
					Core.StringAppend(string1, " slice begin index must occur before the end index when step is positive.");
				} else {
					Core.StringAppend(string1, " slice begin index must occur after the end index when the step is negative.");
				}
			}
			return Core.GenerateException(CoreExceptionTypes.INDEX_OUT_OF_RANGE, string1);
		}
	}
}
valueStack[(valueStackSize - 1)] = value;
