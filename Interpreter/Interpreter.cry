
function @type('InterpreterResult') errorResult(@type('string') error) {
	return new InterpreterResult(InterpreterResultStatus.FATAL_ERROR, error);
}

function @type('InterpreterResult') uncaughtExceptionResult(@type('Value') exception) {
	return new InterpreterResult(InterpreterResultStatus.FATAL_ERROR, unrollExceptionOutput(exception));
}

function @type('InterpreterResult') suspendInterpreter() {
	return new InterpreterResult(InterpreterResultStatus.SUSPENDED, null);
}

function @type('InterpreterResult') suspendInterpreterWithLock() {
	return new InterpreterResult(InterpreterResultStatus.SUSPENDED_WITH_LOCK, null);
}

function @type('InterpreterResult') interpreterFinished(@type('ExecutionContext') ec) {
	if (ec != null) {
		@type('int') id = ExecutionContext$ec.id;
		@type('ProgramData') p = $_get_program_data();
		if ($_dictionary_contains(ProgramData$p.executionContexts, id)) {
			$_dictionary_remove(ProgramData$p.executionContexts, id);
		}
	}
	return new InterpreterResult(InterpreterResultStatus.FINISHED, null);
}

// This will push a stack frame onto the stack as though _LIB_CORE_generateExeption(type, message) is being called.
// But then it will return an REINVOKE status. The idea is this will be called with a return from interpretImpl.
function @type('InterpreterResult') generateException(
		@type('StackFrame') stack,
		@type('int') pc,
		@type('int') valueStackSize,
		@type('ExecutionContext') ec,
		@type('int') type,
		@type('string') message) {

	ExecutionContext$ec.currentValueStackSize = valueStackSize;
	StackFrame$stack.pc = pc;
	ExecutionContext$ec.localsStackSetToken = StackFrame$stack.localsStackSetToken + 1;
	@type('ProgramData') p = $_get_program_data();
	@type('MagicNumbers') mn = ProgramData$p.magicNumbers;
	@type('int') generateExceptionFunctionId = MagicNumbers$mn.coreGenerateExceptionFunctionId;
	@type('FunctionInfo') functionInfo = $_array_get(ProgramData$p.functionTable, generateExceptionFunctionId);
	pc = FunctionInfo$functionInfo.pc;
	if ($_array_length(ExecutionContext$ec.localsStack) <= FunctionInfo$functionInfo.localsSize + StackFrame$stack.localsStackOffsetEnd) {
		increaseLocalsStackCapacity(ec, FunctionInfo$functionInfo.localsSize);
	}
	@type('int') localsIndex = StackFrame$stack.localsStackOffsetEnd;
	$_array_set(ExecutionContext$ec.localsStack, localsIndex, buildInteger(type));
	$_array_set(ExecutionContext$ec.localsStack, localsIndex + 1, buildString(message));
	$_array_set(ExecutionContext$ec.localsStackSet, localsIndex, ExecutionContext$ec.localsStackSetToken);
	$_array_set(ExecutionContext$ec.localsStackSet, localsIndex + 1, ExecutionContext$ec.localsStackSetToken);

	ExecutionContext$ec.stackTop = new StackFrame(
		pc + 1, // won't have the end of the interpreter loop to do the +1 for us.
		ExecutionContext$ec.localsStackSetToken,
		StackFrame$stack.localsStackOffsetEnd,
		StackFrame$stack.localsStackOffsetEnd + FunctionInfo$functionInfo.localsSize,
		stack,
		false,
		null,
		valueStackSize,
		0,
		StackFrame$stack.depth + 1,
		PostFinallyBehavior.NOTHING,
		null);
	return new InterpreterResult(InterpreterResultStatus.REINVOKE, null);
}

function @type('InterpreterResult') interpret(@type('int') executionContextId) {
	@type('InterpreterResult') output = interpretImpl(executionContextId);
	while (InterpreterResult$output.status == InterpreterResultStatus.REINVOKE) {
		output = interpretImpl(executionContextId);
	}
	return output;
}

function @type('ExecutionContext') interpreterGetExecutionContext(@type('int') executionContextId) {
	@type('ProgramData') p = $_get_program_data();
	@type('Dictionary<int, ExecutionContext>') executionContexts = ProgramData$p.executionContexts;
	if (!$_dictionary_contains(executionContexts, executionContextId)) {
		return null;
	}
	return $_dictionary_get_guaranteed(executionContexts, executionContextId);
}

function @omitReturn @type('InterpreterResult') interpretImpl(@type('int') executionContextId) {

	@type('ProgramData') p = $_get_program_data();

	@type('Dictionary<int, ExecutionContext>') executionContexts = ProgramData$p.executionContexts;
	@type('ExecutionContext') ec = interpreterGetExecutionContext(executionContextId);
	if (ec == null) {
		// Stale context ID's may possibly be invoked. Pretend that they run and finish.
		return interpreterFinished(null);
	}

	ExecutionContext$ec.executionCounter += 1;

	@type('StackFrame') stack = ExecutionContext$ec.stackTop;
	@type('Array<int>') ops = ProgramData$p.ops;
	@type('Array<Array<int>>') args = ProgramData$p.args;
	@type('Array<string>') stringArgs = ProgramData$p.stringArgs;

	@type('Array<ClassInfo>') classTable = ProgramData$p.classTable;
	@type('Array<FunctionInfo>') functionTable = ProgramData$p.functionTable;
	@type('Array<Value>') literalTable = ProgramData$p.literalTable;
	@type('Array<string>') identifiers = ProgramData$p.identifiers;

	@type('Array<Value>') valueStack = ExecutionContext$ec.valueStack;
	@type('int') valueStackSize = ExecutionContext$ec.currentValueStackSize;
	@type('int') valueStackCapacity = $_array_length(valueStack);

	// declare types...
	@type('int') type = 0;
	@type('int') nameId = 0;
	@type('int') classId = 0;
	@type('int') functionId = 0;
	@type('ClassInfo') classInfo = null;
	@type('int') len = 0;
	@type('Value') root = null;
	@type('Array<int>') row = null;
	@type('int') argCount = 0;
	@type('Array<string>') stringList = null;
	@type('bool') returnValueUsed = false;
	@type('Value') output = null;
	@type('FunctionInfo') functionInfo = null;
	@type('Array<List<Token>>') tokensByPc = null;
	@type('List<Token>') tokens = null;
	@type('int') keyType = 0;
	@type('int') intKey = 0;
	@type('string') stringKey = null;
	@type('Dictionary<int, Value>') dictIntKeyLookup = null;
	@type('Dictionary<int, Value>') dictIntValueLookup = null;
	@type('Dictionary<string, Value>') dictStringKeyLookup = null;
	@type('Dictionary<string, Value>') dictStringValueLookup = null;
	@type('bool') first = false;
	@type('bool') primitiveMethodToCoreLibraryFallback = false;

	// These are all general purpose variables that can be used by any op.
	// Declared once before the interpreter runs to prevent overhead per VM cycle.
	@type('bool') bool1 = false;
	@type('bool') bool2 = false;
	@type('int') int1 = 0;
	@type('int') int2 = 0;
	@type('int') int3 = 0;
	@type('int') int4 = 0;
	@type('int') int5 = 0;
	@type('int') i = 0;
	@type('int') j = 0;
	@type('double') float1 = 0.0;
	@type('double') float2 = 0.0;
	@type('double') float3 = 0.0;
	@type('Array<double>') floatList1 = $_new_array('double', 2);

	@type('Value') value = null;
	@type('Value') value2 = null;
	@type('Value') value3 = null;
	@type('string') string1 = null;
	@type('string') string2 = null;
	@type('string') string3 = null;
	@type('ObjectInstance') objInstance1 = null;
	@type('ObjectInstance') objInstance2 = null;
	@type('object') object1 = null;
	@type('object') object2 = null;
	@type('object') object3 = null;
	@type('List<Value>') list1 = null;
	@type('List<Value>') list2 = null;
	@type('DictImpl') dictImpl = null;
	@type('DictImpl') dictImpl2 = null;
	@type('List<string>') stringList1 = null;
	@type('List<int>') intList1 = null;
	@type('Array<Value>') valueArray1 = null;
	@type('Array<int>') intArray1 = null;
	@type('Array<int>') intArray2 = null;
	@type('Array<object>') objArray1 = null;
	@type('Array<object>') objArray2 = null;
	@type('Array<Array<object>>') objArrayArray1 = null;
	@type('Array<Array<object>>') objArrayArray2 = null;
	@type('FunctionPointer') functionPointer1 = null;
	@type('Dictionary<int, int>') intIntDict1 = null;
	@type('StackFrame') stackFrame2 = null;
	@type('Value') leftValue = null;
	@type('Value') rightValue = null;
	@type('ClassValue') classValue = null;

	@type('int') op = 0;
	@type('object') left = 0;
	@type('object') right = 0;
	@type('int') leftType = 0;
	@type('int') rightType = 0;

	@type('Value') arg1 = null;
	@type('Value') arg2 = null;
	@type('Value') arg3 = null;
	@type('Value') arg4 = null;
	@type('Value') arg5 = null;
	@type('Value') arg6 = null;
	@type('Value') arg7 = null;
	@type('Value') arg8 = null;
	@type('Value') arg9 = null;
	@type('Value') arg10 = null;

	@type('Array<int>') globalNameIdToPrimitiveMethodName = ProgramData$p.globalNameIdToPrimitiveMethodName;
	@type('MagicNumbers') magicNumbers = ProgramData$p.magicNumbers;
	@type('Array<Dictionary<int, int>>') integerSwitches = ProgramData$p.integerSwitchLookups;
	@type('Array<Dictionary<string, int>>') stringSwitches = ProgramData$p.stringSwitchLookups;
	@type('Dictionary<int, int>') integerSwitch = null;
	@type('Dictionary<string, int>') stringSwitch = null;
	@type('Array<Array<int>>') esfData = ProgramData$p.esfData;

	@type('Array<int>') intOutParam = $_new_array('int', 16);
	@type('Array<double>') floatOutParam = $_new_array('double', 16);
	@type('Array<string>') stringOutParam = $_new_array('string', 16);

	@type('Array<Value>') localsStack = ExecutionContext$ec.localsStack;
	@type('Array<int>') localsStackSet = ExecutionContext$ec.localsStackSet;
	@type('int') localsStackSetToken = StackFrame$stack.localsStackSetToken;
	@type('int') localsStackCapacity = $_array_length(localsStack);
	@type('int') localsStackOffset = StackFrame$stack.localsStackOffset;
	@type('Array<Value>') funcArgs = ProgramData$p.funcArgs;

	@type('int') pc = StackFrame$stack.pc;

	// TODO: if (platform == C#) {
	if (object2 == null || intList1 == null || objArray1 == null)
	{
		// Eliminate compilation warnings when there are no imports
	}

	while (true) {
		row = $_array_get(args, pc);
		switch ($_array_get(ops, pc)) {
			case OpCodes.ADD_LITERAL: $_comment('ADD_LITERAL'); import inline 'Ops/add_literal.cry'; break;
			case OpCodes.ADD_NAME: $_comment('ADD_NAME'); import inline 'Ops/add_name.cry'; break;
			case OpCodes.ASSIGN_INDEX: $_comment('ASSIGN_INDEX'); import inline 'Ops/assign_index.cry'; break;
			case OpCodes.ASSIGN_STATIC_FIELD: $_comment('ASSIGN_STATIC_FIELD'); import inline 'Ops/assign_static_field.cry'; break;
			case OpCodes.ASSIGN_STEP: $_comment('ASSIGN_STEP'); import inline 'Ops/assign_step.cry'; break;
			case OpCodes.ASSIGN_THIS_STEP: $_comment('ASSIGN_THIS_STEP'); import inline 'Ops/assign_this_step.cry'; break;
			case OpCodes.ASSIGN_LOCAL: $_comment('ASSIGN_LOCAL'); import inline 'Ops/assign_local.cry'; break;
			case OpCodes.BINARY_OP: $_comment('BINARY_OP'); import inline 'Ops/binary_op.cry'; break;
			case OpCodes.BOOLEAN_NOT: $_comment('BOOLEAN_NOT'); import inline 'Ops/boolean_not.cry'; break;
			case OpCodes.BREAK: $_comment('BREAK'); import inline 'Ops/break.cry'; break;
			case OpCodes.BUILD_SWITCH_INT: $_comment('BUILD_SWITCH_INT'); import inline 'Ops/build_switch_int.cry'; break;
			case OpCodes.BUILD_SWITCH_STRING: $_comment('BUILD_SWITCH_STRING'); import inline 'Ops/build_switch_string.cry'; break;
			case OpCodes.CALL_FUNCTION: $_comment('CALL_FUNCTION'); import inline 'Ops/call_function.cry'; break;
			case OpCodes.CALL_LIB_FUNCTION: $_comment('CALL_LIB_FUNCTION'); import inline 'Ops/call_lib_function.cry'; break;
			case OpCodes.CALL_LIB_FUNCTION_DYNAMIC: $_comment('CALL_LIB_FUNCTION_DYNAMIC'); import inline 'Ops/call_lib_function_dynamic.cry'; break;
			case OpCodes.CLASS_DEFINITION: $_comment('CLASS_DEFINITION'); import inline 'Ops/class_definition.cry'; break;
			case OpCodes.COMMAND_LINE_ARGS: $_comment('COMMAND_LINE_ARGS'); import inline 'Ops/command_line_args.cry'; break;
			case OpCodes.CONTINUE: $_comment('CONTINUE'); import inline 'Ops/continue.cry'; break;
			case OpCodes.CORE_FUNCTION: $_comment('CORE_FUNCTION'); import inline 'Ops/core_function.cry'; break;
			case OpCodes.DEF_DICTIONARY: $_comment('DEF_DICT'); import inline 'Ops/def_dictionary.cry'; break;
			case OpCodes.DEF_LIST: $_comment('DEF_LIST'); import inline 'Ops/def_list.cry'; break;
			case OpCodes.DEF_ORIGINAL_CODE: $_comment('DEF_ORIGINAL_CODE'); import inline 'Ops/def_original_code.cry'; break;
			case OpCodes.DEREF_DOT: $_comment('DEREF_DOT'); import inline 'Ops/deref_dot.cry'; break;
			case OpCodes.DEREF_INSTANCE_FIELD: $_comment('DEREF_INSTANCE_FIELD'); import inline 'Ops/deref_instance_field.cry'; break;
			case OpCodes.DEREF_STATIC_FIELD: $_comment('DEREF_STATIC_FIELD'); import inline 'Ops/deref_static_field.cry'; break;
			case OpCodes.DUPLICATE_STACK_TOP: $_comment('DUPLICATE_STACK_TOP'); import inline 'Ops/duplicate_stack_top.cry'; break;
			case OpCodes.EQUALS: $_comment('EQUALS'); import inline 'Ops/equals.cry'; break;
			case OpCodes.ESF_LOOKUP: $_comment('ESF_LOOKUP'); import inline 'Ops/esf_lookup.cry'; break;
			case OpCodes.EXCEPTION_HANDLED_TOGGLE: $_comment('EXCEPTION_HANDLED_TOGGLE'); import inline 'Ops/exception_handled_toggle.cry'; break;
			case OpCodes.FINALIZE_INITIALIZATION: $_comment('FINALIZE_INITIALIZATION'); import inline 'Ops/finalize_initialization.cry'; break;
			case OpCodes.FINALLY_END: $_comment('FINALLY_END'); import inline 'Ops/finally_end.cry'; break;
			case OpCodes.FUNCTION_DEFINITION: $_comment('FUNCTION_DEFINITION'); import inline 'Ops/function_definition.cry'; break;
			case OpCodes.INDEX: $_comment('INDEX'); import inline 'Ops/index.cry'; break;
			case OpCodes.IS_COMPARISON: $_comment('IS_COMPARISON'); import inline 'Ops/is_comparison.cry'; break;
			case OpCodes.ITERATION_STEP: $_comment('ITERATION_STEP'); import inline 'Ops/iteration_step.cry'; break;
			case OpCodes.JUMP: $_comment('JUMP'); import inline 'Ops/jump.cry'; break;
			case OpCodes.JUMP_IF_EXCEPTION_OF_TYPE: $_comment('JUMP_IF_EXCEPTION_OF_TYPE'); import inline 'Ops/jump_if_exception_of_type.cry'; break;
			case OpCodes.JUMP_IF_FALSE: $_comment('JUMP_IF_FALSE'); import inline 'Ops/jump_if_false.cry'; break;
			case OpCodes.JUMP_IF_FALSE_NO_POP: $_comment('JUMP_IF_FALSE_NON_POP'); import inline 'Ops/jump_if_false_no_pop.cry'; break;
			case OpCodes.JUMP_IF_TRUE: $_comment('JUMP_IF_TRUE'); import inline 'Ops/jump_if_true.cry'; break;
			case OpCodes.JUMP_IF_TRUE_NO_POP: $_comment('JUMP_IF_TRUE_NO_POP'); import inline 'Ops/jump_if_true_no_pop.cry'; break;
			case OpCodes.LIST_SLICE: $_comment('LIST_SLICE'); import inline 'Ops/list_slice.cry'; break;
			case OpCodes.LITERAL: $_comment('LITERAL'); import inline 'Ops/literal.cry'; break;
			case OpCodes.LITERAL_STREAM: $_comment('LITERAL_STREAM'); import inline 'Ops/literal_stream.cry'; break;
			case OpCodes.LOCAL: $_comment('LOCAL'); import inline 'Ops/local.cry'; break;
			case OpCodes.NEGATIVE_SIGN: $_comment('NEGATIVE_SIGN'); import inline 'Ops/negative_sign.cry'; break;
			case OpCodes.POP: $_comment('POP'); import inline 'Ops/pop.cry'; break;
			case OpCodes.POP_IF_NULL_OR_JUMP: $_comment('POP_IF_NULL_OR_JUMP'); import inline 'Ops/pop_if_null_or_jump.cry'; break;
			case OpCodes.PUSH_FUNC_REF: $_comment('PUSH_FUNC_REF'); import inline 'Ops/push_func_ref.cry'; break;
			case OpCodes.RETURN: $_comment('RETURN'); import inline 'Ops/return.cry'; break;
			case OpCodes.STACK_INSERTION_FOR_INCREMENT: $_comment('STACK_INSERTION_FOR_INCREMENT'); import inline 'Ops/stack_insertion_for_increment.cry'; break;
			case OpCodes.STACK_SWAP_POP: $_comment('STACK_SWAP_POP'); import inline 'Ops/stack_swap_pop.cry'; break;
			case OpCodes.SWITCH_INT: $_comment('SWITCH_INT'); import inline 'Ops/switch_int.cry'; break;
			case OpCodes.SWITCH_STRING: $_comment('SWITCH_STRING'); import inline 'Ops/switch_string.cry'; break;
			case OpCodes.THIS: $_comment('THIS'); import inline 'Ops/this.cry'; break;
			case OpCodes.THROW: $_comment('THROW'); import inline 'Ops/throw.cry'; break;
			case OpCodes.TOKEN_DATA: $_comment('TOKEN_DATA'); import inline 'Ops/token_data.cry'; break;
			case OpCodes.USER_CODE_START: $_comment('USER_CODE_START'); import inline 'Ops/user_code_start.cry'; break;
			case OpCodes.VALUE_STACK_DEPTH: $_comment('VALUE_STACK_DEPTH'); import inline 'Ops/value_stack_depth.cry'; break;
			case OpCodes.VERIFY_TYPE_IS_ITERABLE: $_comment('VERIFY_TYPE_IS_ITERABLE'); import inline 'Ops/verify_type_is_iterable.cry'; break;
			default:
				$_comment('THIS SHOULD NEVER HAPPEN');
				return $_exception(CoreExceptionTypes.FATAL, $_string_concat("Bad op code: ", $_int_to_string($_array_get(ops, pc))));
		}

		if ($_has_increment()) {
			$_prefix_increment(pc);
		} else {
			pc += 1;
		}
	}
}

// returns a status code:
// 0 - list is empty
// 1 - list has contents
// 2 - list is a simple clone
// 3 - start index is out of bounds
// 4 - start index occurs after begin index (relative to direction)
function @type('int') canonicalizeListSliceArgs(
	@type('Array<int>') outParams,
	@type('Value') beginValue,
	@type('Value') endValue,
	@type('int') beginIndex,
	@type('int') endIndex,
	@type('int') stepAmount,
	@type('int') length,
	@type('bool') isForward) {

	if (beginValue == null) {
		if (isForward) beginIndex = 0;
		else beginIndex = length - 1;
	}
	if (endValue == null) {
		if (isForward) endIndex = length;
		else endIndex = -1 - length; // if it were -1, it'll get canonicalized into length - 1.
	}

	if (beginIndex < 0) beginIndex += length;
	if (endIndex < 0) endIndex += length;

	if (beginIndex == 0 && endIndex == length && stepAmount == 1) return 2;

	if (isForward) {
		if (beginIndex >= length) return 0;
		if (beginIndex < 0) return 3;
		if (endIndex < beginIndex) return 4;
		if (beginIndex == endIndex) return 0;
		if (endIndex > length) endIndex = length;
	} else {
		if (beginIndex < 0) return 0;
		if (beginIndex >= length) return 3;
		if (endIndex > beginIndex) return 4;
		if (beginIndex == endIndex) return 0;
		if (endIndex < -1) endIndex = -1;
	}
	$_array_set(outParams, 0, beginIndex);
	$_array_set(outParams, 1, endIndex);
	return 1;
}

function @type('List<Token>') generateTokenListFromPcs(@type('List<int>') pcs) {
	@type('List<Token>') output = $_new_list('Token');
	@type('ProgramData') p = $_get_program_data();
	@type('Array<List<Token>>') tokensByPc = ProgramData$p.tokenData;
	@type('Token') token = null;
	@type('int') i = 0;
	while (i < $_list_length(pcs)) {
		@type('List<Token>') localTokens = $_array_get(tokensByPc, $_list_get(pcs, i));
		if (localTokens == null) {
			if ($_list_length(output) > 0) { // Don't push null token data if there is no data. This is the root scope that invokes main.
				$_list_push(output, null);
			}
		} else {
			token = $_list_get(localTokens, 0);
			if (%%%IS_RELEASE%%%) {
				if ($_list_length(output) > 0 ||
					(token != null &&
					!tokenHelplerIsFilePathLibrary(Token$token.fileId, ProgramData$p.sourceCode))) {
					$_list_push(output, token);
				}
			} else {
				$_list_push(output, token);
			}
		}
		i += 1;
	}

	if (%%%IS_RELEASE%%%) {
		// On release builds, pop the top of the stack such that the exception appears to originate from user code.
		@type('int') length = $_list_length(output);
		while (length > 0) {
			 token = $_list_get(output, length - 1); // top token
			 if (token != null && tokenHelplerIsFilePathLibrary(Token$token.fileId, ProgramData$p.sourceCode)) {
				$_list_pop(output);
				length -= 1;
			 } else {
				length = -1; // cheesy break
			 }
		}
	}

	return output;
}

function @type('List<string>') tokenHelperConvertPcsToStackTraceStrings(@type('List<int>') pcs) {
	@type('ProgramData') p = $_get_program_data();
	@type('List<Token>') tokens = generateTokenListFromPcs(pcs);
	@type('Array<string>') files = ProgramData$p.sourceCode;
	@type('List<string>') output = $_new_list('string');
	for (@type('int') i = 0; i < $_list_length(tokens); i += 1) {
		@type('Token') token = $_list_get(tokens, i);
		if (token == null) {
			$_list_push(output, "[No stack information]");
		} else {
			@type('int') line = Token$token.lineIndex;
			@type('int') col = Token$token.colIndex;
			
			@type('string') fileData = $_array_get(files, Token$token.fileId);
			@type('Array<string>') lines = $_string_split(fileData, '\n');
			@type('string') filename = $_array_get(lines, 0);
			@type('string') linevalue = $_array_get(lines, line + 1);
		
			$_list_push(
				output,
				$_string_concat(filename, ", Line: ", $_int_to_string(line + 1), ", Col: ", $_int_to_string(col + 1)));
		}
	}

	return output;
}

function @type('string') tokenHelperGetFormattedPointerToToken(@type('Token') token) {
	@type('string') line = tokenHelperGetFileLine(Token$token.fileId, Token$token.lineIndex + 1);
	if (line == null) return null;
	@type('int') columnIndex = Token$token.colIndex;
	@type('int') lineLength = $_string_length(line);
	line = $_string_ltrim(line);
	line = $_string_replace(line, '\t', ' ');
	@type('int') offset = lineLength - $_string_length(line);
	columnIndex -= offset;
	@type('string') line2 = "";
	while (columnIndex > 0) {
		columnIndex -= 1;
		line2 = $_string_concat(line2, ' ');
	}
	line2 = $_string_concat(line2, '^');
	return $_string_concat(line, "\n", line2);
}

function @type('string') tokenHelperGetFileLine(@type('int') fileId, @type('int') lineNum) {
	@type('ProgramData') p = $_get_program_data();
	@type('string') sourceCode = $_array_get(ProgramData$p.sourceCode, fileId);
	if (sourceCode == null) return null;
	return $_array_get($_string_split(sourceCode, "\n"), lineNum);
}

function @type('bool') tokenHelplerIsFilePathLibrary(@type('int') fileId, @type('Array<string>') allFiles) {
	@type('string') filename = tokenHelperGetFileLine(fileId, 0); // line 0 is the file name
	return !$_string_endswith($_string_lower(filename), ".cry");
}

// This saves the state of the interpreter so that it's ready to have
// interpret() called again. Even though this is only called once directly
// in the translated crayon interpreter code, certain platforms will need
// to call this manually.
function @type('int') prepareToSuspend(
	@type('ExecutionContext') ec,
	@type('StackFrame') stack,
	@type('int') valueStackSize,
	@type('int') currentPc) {

	ExecutionContext$ec.stackTop = stack;
	ExecutionContext$ec.currentValueStackSize = valueStackSize;
	StackFrame$stack.pc = currentPc + 1;
	return 0;
}

function @type('int') valueStackIncreaseCapacity(@type('ExecutionContext') ec) {
	@type('Array<Value>') stack = ExecutionContext$ec.valueStack;
	@type('int') oldCapacity = $_array_length(stack);
	@type('int') newCapacity = oldCapacity * 2;
	@type('Array<Value>') newStack = $_new_array('Value', newCapacity);
	for (@type('int') i = oldCapacity - 1; i >= 0; i -= 1) {
		$_array_set(newStack, i, $_array_get(stack, i));
	}
	ExecutionContext$ec.valueStack = newStack;
	return 0;
}

function @type('string') unrollExceptionOutput(@type('Value') exceptionInstance) {
	@type('ObjectInstance') objInstance = $_cast('ObjectInstance', Value$exceptionInstance.internalValue);
	@type('ProgramData') p = $_get_program_data();
	@type('ClassInfo') classInfo = $_array_get(ProgramData$p.classTable, ObjectInstance$objInstance.classId);
	@type('List<int>') pcs = $_cast('List<int>', $_array_get(ObjectInstance$objInstance.nativeData, 1));
	@type('string') codeFormattedPointer = '';
	
	@type('string') exceptionName = ClassInfo$classInfo.fullyQualifiedName;
	@type('string') message = valueToString($_array_get(ObjectInstance$objInstance.members, 1));
	@type('List<string>') trace = tokenHelperConvertPcsToStackTraceStrings(pcs);
	$_list_pop(trace);
	$_list_push(trace, "Stack Trace:");
	$_list_reverse_in_place(trace);
	
	@type('List<Token>') tokensAtPc = $_array_get(ProgramData$p.tokenData, $_list_get(pcs, 0));
	if (tokensAtPc != null) {
		codeFormattedPointer = $_string_concat("\n\n", tokenHelperGetFormattedPointerToToken($_list_get(tokensAtPc, 0)));
	}

	@type('string') stackTrace = $_list_join(trace, "\n");
	return $_string_concat(stackTrace, codeFormattedPointer, "\n", exceptionName, ": ", message);
}

function @type('bool') isPcFromCore(@type('int') pc) {
	@type('ProgramData') p = $_get_program_data();
	@type('List<Token>') tokens = $_array_get(ProgramData$p.tokenData, pc);
	if (tokens == null) return false;
	@type('Token') token = $_list_get(tokens, 0);
	@type('string') filename = tokenHelperGetFileLine(Token$token.fileId, 0);
	return $_string_equals("[Core]", filename);
}
