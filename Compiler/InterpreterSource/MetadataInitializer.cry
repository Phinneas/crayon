function @type('int') initializeFunction(@type('ProgramData') p, @type('Array<int>') args, @type('int') currentPc) {

	@type('int') functionId = $_array_get(args, 0);
	@type('int') nameId = $_array_get(args, 1);
	@type('int') minArgCount = $_array_get(args, 2);
	@type('int') maxArgCount = $_array_get(args, 3);
	@type('int') functionType = $_array_get(args, 4);
	@type('int') classId = $_array_get(args, 5);
	@type('int') localsCount = $_array_get(args, 6);
	@type('int') pcJump = $_array_get(args, 7);
	@type('int') numPcOffsetsForOptionalArgs = $_array_get(args, 8);
	
	@type('Array<int>') pcOffsetsForOptionalArgs = $_new_array('int', numPcOffsetsForOptionalArgs);
	for (@type('int') i = 0; i < numPcOffsetsForOptionalArgs; i += 1) {
		$_array_set(pcOffsetsForOptionalArgs, i, $_array_get(args, 9 + i));
	}

	@type('Array<FunctionInfo2>') functionTable = getFunctionTable(p, functionId);
	$_array_set(functionTable, functionId, new FunctionInfo2(
		functionId,
		nameId,
		currentPc, // Store the function body's PC - 1 which coincidently is the current PC.
		minArgCount,
		maxArgCount,
		functionType,
		classId,
		localsCount,
		pcOffsetsForOptionalArgs));

	return pcJump;
}

function @type('Array<FunctionInfo2>') getFunctionTable(@type('ProgramData') p, @type('int') functionId) {
	@type('Array<FunctionInfo2>') oldTable = ProgramData$p.functionTable;
	@type('int') oldLength = $_array_length(oldTable);

	if (functionId < oldLength) return oldTable;

	@type('int') newLength = oldLength * 2;
	if (functionId >= newLength) newLength = functionId + 100;

	@type('Array<FunctionInfo2>') newTable = $_new_array('FunctionInfo2', newLength);
	for (@type('int') i = 0; i < oldLength; i += 1) {
		$_array_set(newTable, i, $_array_get(oldTable, i));
	}

	ProgramData$p.functionTable = newTable;
	return newTable;
}

/*
	Note that static methods do not appear anywhere in the class metadata as they all get (mostly) converted
	into normal function calls (annotated with the class ID to trigger static initializers).

	args[0] -> class ID
	args[1] -> base class ID or -1 if no parent
	args[2] -> global name ID for class (potentially not unique)
	args[3] -> constructor function ID
	args[4] -> Jump amount after initialization complete
	args[5] -> static constructor function ID or -1
	args[6] -> number of static fields
	args[n .. n+5] -> fields and methods that are declared in this class.
		n + 0 -> 0 if field, 1 if method
		n + 1 -> member ID (numbering starts after base class member ID's
		n + 2 -> global name ID
		for fields:
			n + 3 -> initialization instruction 
				0: use a literal
				1: use an empty list
				2: use an empty dictionary
			n + 4 -> literal ID or ignored
		for methods:
			n + 3 -> function ID
			n + 4 -> not used
*/
function @type('int') initializeClass(@type('int') pc, @type('ProgramData') p, @type('Array<int>') args) {
	@type('int') i = 0;
	@type('int') memberId = 0;
	@type('int') globalId = 0;
	@type('int') functionId = 0;
	@type('int') t = 0;

	@type('int') classId = $_array_get(args, 0);
	@type('int') baseClassId = $_array_get(args, 1);
	@type('int') globalNameId = $_array_get(args, 2);
	@type('int') constructorFunctionId = $_array_get(args, 3);
	@type('int') pcJumpAfterDone = $_array_get(args, 4);
	@type('bool') initializerPresent = pcJumpAfterDone != 0;
	@type('int') staticConstructorFunctionId = $_array_get(args, 5);
	@type('int') staticInitializationState = 0;
	if (staticConstructorFunctionId == -1) {
		staticInitializationState = 2;
	}
	@type('int') staticFieldCount = $_array_get(args, 6); // just static fields. no static methods. those function IDs are resolved inline at compile time
	@type('Dictionary<int, int>') globalNameIdToMemberId = $_new_dictionary('int', 'int');

	@type('ClassInfo2') classInfo = new ClassInfo2(
		classId,
		globalNameId,
		baseClassId,
		staticInitializationState,
		null, // static fields array. This is set during general runtime by the static constructor
		staticConstructorFunctionId,
		constructorFunctionId,
		null, // field initializer PC list with base-most class first.
		0, // member count
		null, // Array of member ID -> function IDs (with -1 fallback)
		null, // Field initialization command by member ID
		null, // Literal starting value by member ID
		globalNameIdToMemberId);
	
	@type('Array<ClassInfo2>') classTable = getClassTable(p, classId);

	$_array_set(classTable, classId, classInfo);

	@type('List<ClassInfo2>') classChain = $_new_list('ClassInfo2');
	$_list_push(classChain, classInfo);
	@type('int') classIdWalker = baseClassId;
	while (classIdWalker != -1) {
		@type('ClassInfo2') walkerClass = $_array_get(classTable, classIdWalker);
		$_list_push(classChain, walkerClass);
		classIdWalker = ClassInfo2$walkerClass.baseClassId;
	}

	@type('ClassInfo2') baseClass = null;
	if (baseClassId != -1) {
		baseClass = $_list_get(classChain, 1);
	}

	// create the field initializer PC list
	@type('List<int>') fieldInitializerPcs = $_new_list('int');
	if (initializerPresent) {
		$_list_push(fieldInitializerPcs, pc);
	}
	if (baseClass != null) {
		@type('Array<int>') baseFieldInitializerPcs = ClassInfo2$baseClass.fieldInitializerPcs;
		for (i = 0; i < $_array_length(baseFieldInitializerPcs); i += 1) {
			$_list_push(fieldInitializerPcs, $_array_get(baseFieldInitializerPcs, i));
		}
	}
	ClassInfo2$classInfo.fieldInitializerPcs = $_convert_list_to_array('int', fieldInitializerPcs);

	// populate all the members. basically just copy the member lookups for the base class and then
	// overlay the current classes value on top of it.
	// Note that the current class may re-define some methods with the same member ID as a parent class.

	// initialize members
	@type('List<int>') functionIds = $_new_list('int');
	@type('List<int>') fieldInitializationCommand = $_new_list('int');
	@type('List<Value>') fieldInitializationLiteral = $_new_list('Value');

	// copy from base class
	if (baseClass != null) {
		for (i = 0; i < ClassInfo2$baseClass.memberCount; i += 1) {
			$_list_push(functionIds, $_array_get(ClassInfo2$baseClass.functionIds, i));
			$_list_push(fieldInitializationCommand, $_array_get(ClassInfo2$baseClass.fieldInitializationCommand, i));
			$_list_push(fieldInitializationLiteral, $_array_get(ClassInfo2$baseClass.fieldInitializationLiteral, i));
		}

		@type('Array<int>') keys = $_dictionary_get_keys('int', ClassInfo2$baseClass.globalIdToMemberId);
		for (i = 0; i < $_array_length(keys); i += 1) {
			t = $_array_get(keys, i);
			$_dictionary_set(globalNameIdToMemberId, t, $_dictionary_get_guaranteed(ClassInfo2$baseClass.globalIdToMemberId, t));
		}
	}

	// and now add the overrides and appends
	for (i = 7; i < $_array_length(args); i += 5) {
		memberId = $_array_get(args, i + 1);
		globalId = $_array_get(args, i + 2);
		while (memberId >= $_list_length(functionIds)) {
			$_list_push(functionIds, -1);
			$_list_push(fieldInitializationCommand, -1);
			$_list_push(fieldInitializationLiteral, null);
		}
		$_dictionary_set(globalNameIdToMemberId, globalId, memberId); // potentially override previous entries
		if ($_array_get(args, i) == 0) { // field
			$_list_set(fieldInitializationCommand, memberId, $_array_get(args, i + 3));
			t = $_array_get(args, i + 4); // literal ID or -1 for NULL
			if (t == -1) {
				$_list_set(fieldInitializationLiteral, memberId, VALUE_NULL);
			} else {
				$_list_set(fieldInitializationLiteral, memberId, $_array_get(ProgramData$p.literalTable, t));
			}
		} else { // method
			functionId = $_array_get(args, i + 3);
			$_list_set(functionIds, memberId, functionId);
		}
	}

	ClassInfo2$classInfo.functionIds = $_convert_list_to_array('int', functionIds);
	ClassInfo2$classInfo.fieldInitializationCommand = $_convert_list_to_array('int', fieldInitializationCommand);
	ClassInfo2$classInfo.fieldInitializationLiteral = $_convert_list_to_array('Value', fieldInitializationLiteral);

	return pcJumpAfterDone;
}

function @type('Array<ClassInfo2>') getClassTable(@type('ProgramData') p, @type('int') classId) {
	@type('Array<ClassInfo2>') oldTable = ProgramData$p.classTable2;
	@type('int') oldLength = $_array_length(oldTable);
	if (classId < oldLength) return oldTable;
	@type('int') newLength = oldLength * 2;
	if (classId >= newLength) {
		newLength = classId + 100;
	}

	@type('Array<ClassInfo2>') newTable = $_new_array('ClassInfo2', newLength);
	for (@type('int') i = oldLength - 1; i >= 0; i -= 1) {
		$_array_set(newTable, i, $_array_get(oldTable, i));
	}

	ProgramData$p.classTable2 = newTable;
	return newTable;
}

function @type('int') resetLocalsStackTokens(@type('StackFrame') stack, @type('Array<int>') localsStackSet, @type('Array<Value>') localsStack) {
	
	@type('int') i = StackFrame$stack.localsStackOffsetEnd;
	while (i < $_array_length(localsStackSet)) {
		$_array_set(localsStackSet, i, 0);
		$_array_set(localsStack, i, null);
	}

	@type('StackFrame') stackWalker = stack;
	
	while (stackWalker != null) {
		@type('int') token = StackFrame$stackWalker.localsStackSetToken;
		for (i = StackFrame$stackWalker.localsStackOffset; i < StackFrame$stackWalker.localsStackOffsetEnd; i += 1) {
			if ($_array_get(localsStackSet, i) == token) {
				$_array_set(localsStackSet, i, 1);
			} else {
				$_array_set(localsStackSet, i, 0);
				$_array_set(localsStack, i, null);
			}
		}
		stackWalker = StackFrame$stackWalker.previous;
	}
	
	return -1;
}
