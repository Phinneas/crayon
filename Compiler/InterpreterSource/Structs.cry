// TODO: it's probably time to split this file up into a structs folder with a different file for each individual struct.

struct Code {
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs
}

// Dictionaries in Crayon can only have 3 types of keys: integers, strings, and objects
// Dictionaries can hold any of these, but only hold one type at a time
struct DictImpl {
	@type('Dictionary<int, Value>') keyIntLookup,
	@type('Dictionary<int, Value>') valueIntLookup,
	@type('Dictionary<string, Value>') keyStringLookup,
	@type('Dictionary<string, Value>') valueStringLookup,
	@type('int') size,
	@type('int') keyType
}

struct SpriteSheetItemDescriptor {
	@type('string') filePath,
	@type('int') groupId,
	@type('int') spillId,
	@type('int') tileId,
	@type('bool') solitary,
	@type('int') x,
	@type('int') y,
	@type('int') width,
	@type('int') height
}

struct SpriteSheetData {
	@type('Dictionary<string, SpriteSheetItemDescriptor>') files,
	@type('Dictionary<int, List<string>>') filesByGroupId,
	@type('Dictionary<int, Dictionary<int, bool>>') tileIdsByGroupId,
	@type('Dictionary<string, int>') groupIdsByName
}

struct ProgramData {
	@type('StackFrame') stackTop,
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs,
	//@type('Array<Array<int>>') specialCache,
	@type('Array<string>') identifiers,
	@type('List<string>') identifiersBuilder,
	@type('Dictionary<string, int>') inv_identifiers,
	@type('Array<Value>') literalTable,
	@type('List<Value>') literalTableBuilder,
	@type('Array<ClassInfo>') classTable,
	@type('Array<Dictionary<int, MethodDefinition>>') classMethods,
	@type('bool') tickerRegistered,
	@type('Array<List<Token>>') tokenData,
	@type('int') userCodeStart,
	@type('Array<string>') sourceCode,
	@type('List<string>') sourceCodeBuilder,
	@type('Array<Dictionary<int, int>>') integerSwitchLookups,
	@type('List<Dictionary<int, int>>') integerSwitchLookupsBuilder,
	@type('Array<Dictionary<string, int>>') stringSwitchLookups,
	@type('List<Dictionary<string, int>>') stringSwitchLookupsBuilder,
	@type('int') instanceCounter,
	@type('SpriteSheetData') spriteSheetData,
	@type('ImageSheetStatus') imageSheetStatus,
	@type('SoundStatus') soundStatus,
	@type('bool') initializationComplete,
	@type('GamepadStatus') gamepadStatus,
	@type('int') gameCounter,

	@type('int') valueStackSize,
	@type('int') valueStackCapacity,
	@type('Array<Value>') valueStack,

	@type('Array<ClassInfo2>') classTable2,
	@type('Array<FunctionInfo2>') functionTable,
	@type('List<int>') classStaticInitializationStack,
	@type('Array<int>') globalNameIdToPrimitiveMethodName,
	@type('Array<Value>') localsStack,
	@type('Array<int>') localsStackSet,
	@type('Array<Value>') funcArgs,

	@type('int') lengthId,
}

struct StackFrame {
	@type('int') pc,
	@type('int') localsStackSetToken, // if localsStackSet[i + offset] has this value, then that means localsStack[i + offset] is valid.
	@type('int') localsStackOffset, // offset local ID by this to get the value in localsStack
	@type('int') localsStackOffsetEnd, // ending offset of the locals stack
	@type('StackFrame') previous,
	@type('bool') returnValueUsed,
	@type('Value') objectContext,
	@type('int') valueStackSize,
	@type('int') markClassAsInitialized,
}

struct Token {
	@type('int') lineIndex,
	@type('int') colIndex,
	@type('int') fileId
}

struct Value {
	@type('int') type,
	@type('object') internalValue
}

struct MethodInstance {
	@type('Value') context,
	@type('int') pc,
	@type('int') maxArgs
}

struct MethodDefinition {
	@type('int') nameId,
	@type('int') maxArgs,
	@type('int') pc
}

struct SystemMethod {
	@type('Value') context,
	@type('int') id
}

struct ClassInfo {
	@type('int') nameId,
	@type('int') constructorPc,
	@type('int') constructorMaxArgCount,
	@type('int') baseClassId,
	@type('bool') baseConstructorRequired,
	@type('bool') initialized
}

/*
	When a class is about to be referenced, static initialization state is checked.
	If it is 0, then check to see if the base class chain has any 0's and initialize the last class
	up the chain. Class intializations work like function invocations where the return PC points to the
	exact same spot where the intialization was triggered, so that the code continues to run normally
	despite the interrupt of the static constructor.

	When a class is initialized, a new Array<Value> is allocated with length of .memberCount.
	Then a loop runs through all member ID/indexes and checks the fieldInitializationCommand.
	If it's a literal, it copies the value directly from the fieldInitializationLiteral in the class metadata here.
	If it's a LIST or DICT, then it creates an empty instance of those. 
	LIST or DICT is only used if the field is initialized to an _empty_ List or Dictionary. Otherwise NULL is used.
	If it's a SYSTEM_NULL the value of null (not a Value, but an actual native null) is applied to that slot. This 
	indicates that the member is actually referencing a method. This is lazily populated at runtime if a function
	reference without invocation is ever made.

	At this point in CALL_FUNCTION, local arguments are pushed onto the locals stack and the constructor's stack
	frame is pushed with the PC pointing at the proper optional argument. But before execution resumes, more stack 
	frames are pushed...

	In the byte code, the CLASS_INITIALIZER is followed by some code that has all the field default values individually
	followed by ASSIGN_FIELD (for anything that isn't a literal, empty list, or empty dictionary) followed by RETURN.
	After the constructor's args have been pushed to the local stack and the constructor's stack frame is initialized, 
	the call stack pushes ALL the PC's that appear in fieldInitializerPcs onto the stack in order, which results in
	the root parent last. As these return, they will end up back at the child constructor.

	One of the side effects of this system is all fields (even in base classes) that have literal values will be 
	initialized first before anything else happens. After that all other fields and constructors are invoked in the
	traditional order, which is a change in behavior from languages like Java and C#. But if your code explicitly is
	expecting a default null value in a field that is initialized with another literal before your other field that
	is initialized with a function invocation, then you're asking for trouble anyway. The performance of the copying 
	from the array of literals has better performance than putting all field initializers in the field initializer
	code chunk.
	
*/
struct ClassInfo2 {
	@type('int') id,
	@type('int') nameId,
	@type('int') baseClassId, // or -1 if no base class
	@type('int') staticInitializationState, // 0 - not initialized, 1 - in progress, 2 - done
	@type('Array<Value>') staticFields,
	@type('int') staticConstructorFunctionId,
	@type('int') constructorFunctionId,
	
	// A list of PC offsets (from this class to its parent root) that should be pushed onto the stack
	// to initialize fields.
	@type('Array<int>') fieldInitializerPcs,

	@type('int') memberCount, // total number of fields and methods, flattened.
	// The following lists contain data on all flattened fields and methods indexed by member ID.
	// These values are replicated in children classes where the child class' members appear at the end of the list.
	@type('Array<int>') functionIds, // function ID or -1
	@type('Array<int>') fieldInitializationCommand, // 0 - USE_LITERAL, 1 - LIST, 2 - DICT, 3 - SYSTEM NULL (reserved for method)
	@type('Array<Value>') fieldInitializationLiteral,

	// TODO: It might actually be good to create two of these, one that's global ID to all member ID's, and another 
	// for global ID to assignable member ID's. This would eliminate a couple of CPU cycles and also partially pave 
	// the road for private/protected/public modifiers.
	@type('Dictionary<int, int>') globalIdToMemberId,

	// TODO: another thought is to allocate an array for all global ID's to map to member ID's. This would be a lot of
	// space O(class count * number of var names), but not all that ridiculous. Several kilobytes in memory for an average sized 
	// codebase.
}

struct FunctionInfo2 {
	@type('int') id,
	@type('int') nameId,
	@type('int') pc,
	@type('int') minArgs,
	@type('int') maxArgs,
	@type('int') type, // 0 - function, 1 - method, 2 - static method, 3 - constructor, 4 - static constructor
	@type('int') associatedClassId,
	@type('int') localsSize,
	@type('Array<int>') pcOffsetsForOptionalArgs,
}

struct FunctionDefinition {
	@type('int') pc,
	@type('int') maxArgCount,
	@type('string') name,
}

struct ObjectInstance {
	@type('int') classId,
	@type('int') objectId,
	@type('Array<Value>') members,

	// system libraries can attach arbitrary values to objects, which can be operated on more efficiently than values, and
	// are inherently inaccessible by user code.
	@type('Array<object>') nativeData,
}

struct FunctionPointer {
	@type('int') type, // Enum value: FunctionPointerType
	@type('Value') context,
	@type('int') classId,
	@type('int') functionId,
}

struct CompositeImage {
	@type('object') nativeBitmap,
	@type('int') width,
	@type('int') height,
	@type('int') glTextureId,
	@type('bool') loaded
}

struct ImageSheetVirtualizationGrid {
	@type('Dictionary<string, Array<int>>') imageLocations,
	@type('Dictionary<int, CompositeImage>') sheets,
	@type('string') groupName,
	@type('int') groupId,
	@type('Array<string>') paths,
	@type('bool') loadCompletionChecked
}

/*
 * Either compositeResource or rawResource will be null depending on the platform.
 */
struct Image {
	@type('CompositeImage') compositeResource, // Composite image this image is located in
	@type('object') rawResource, // native platform bitmap if image compositing is not used
	@type('int') sourceX,
	@type('int') sourceY,
	@type('int') sourceWidth,
	@type('int') sourceHeight,
	@type('int') width,
	@type('int') height,
	@type('float') textureLeft,
	@type('float') textureTop,
	@type('float') textureRight,
	@type('float') textureBottom
}

struct ImageSheetStatus {
	@type('Dictionary<string, string>') autogeneratedAsyncDownloadKeyToUserKeyLoop,
	@type('Dictionary<string, object>') downloadedImagesByKey,
	@type('Dictionary<string, int>') downloadedImagesErrorCodes,
	@type('Dictionary<string, TileLoadRequest>') downloadsInFlight, // key is generated tile name
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') fileToVirtualizationGrid,
	@type('Dictionary<int, Array<string>>') generatedTileNamesByGroupId,
	@type('Dictionary<string, int>') groupNameToId,
	@type('bool') isBackgroundLoaderActive,
	@type('Dictionary<string, Image>') loadedImagesByKey,
	@type('Dictionary<string, CompositeImage>') resourceImagesByKeys,
	@type('Dictionary<int, int>') sheetStatus,
	@type('Dictionary<int, List<SpriteSheetItemDescriptor>>') spriteSheetItemDescriptorsByGroupId,
	@type('Dictionary<string, Array<int>>') texturePartitioningInformation,
	@type('List<TileLoadRequest>') tileLoadQueue,
	@type('Dictionary<string, object>') tilesByName,
	@type('Dictionary<int, Array<int>>') tilesPerId,
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') virtualizationGrids
}

struct SoundInstance {
	@type('string') userFilePath, // path in the original project (consistent across platforms)
	@type('object') nativeObject, // native sound object.
	@type('string') realFilePath, // path on the actual disk
	@type('double') volume, // volume for this particular music instance (combined with master volume)
	@type('bool') isLoaded, // true if the music is loaded and ready to play
}

struct MusicInstance {
	@type('string') userFilePath, // path in the original project (consistent across platforms)
	@type('object') nativeObject, // native sound object, if necessary (SDL platforms use file paths directly, so this will be null)
	@type('string') realFilePath, // path on the actual disk
	@type('double') volume, // volume for this particular music instance (combined with master volume)
	@type('bool') isLoaded, // true if the music is loaded and ready to play (for SDL, this is unknown and is assumed to be true despite the fact that it may take a few ticks to start playing)
}

// Enqueued in the SoundStatus.soundEventQueue
// Dequeued by the work unit pump
// If the sound or music for an event isn't loaded, it'll 
struct SoundEvent {
	@type('int') type, // FADE_MUSIC, PLAY_MUSIC, PAUSE_MUSIC, PLAY_SOUND
	@type('SoundInstance') sound, 
	@type('MusicInstance') music,
	@type('bool') fadeOutEstablished, // set to true once the endFade timestamp is established.
	@type('bool') musicLoops, // true if the music should loop.

	// These are set when the event is created. These are in seconds.
	@type('double') fadeOutDuration, 

	// These are all blank when the event is created. 
	// When the music has loaded, these are set to the relative timestamps from the current time using the
	// durations listed above. These are all 1970 epoch timestamps.
	@type('double') fadeStart,
	@type('double') fadeMiddle,
	@type('double') fadeEnd,
}

struct SoundStatus {
	@type('List<SoundEvent>') soundEventQueue,
	@type('MusicInstance') currentMusic,
	@type('double') masterSoundVolume,
	@type('double') masterMusicVolume,
	@type('double') fadeVolumeRatio,
	@type('double') lastSetMusicVolume,
	@type('bool') forceVolumeSet,
}

struct TileLoadRequest {
	@type('string') path,
	@type('int') status,
	@type('int') groupId,
	@type('string') groupName,
	@type('int') tileId,
	@type('object') nativeResource,
	@type('string') asyncReferenceKey, // for JS, the key for which to refer back to the downloader.
}

/*
 * The imagette is an image that is defined by a width, height, and series of blits of native platform bitmaps.
 * These are used during the compositing phase of the image sheet tile loading. This allows that guts of the code logic to be written
 * in Crayon without the extensive use of native methods. The Imagettes, containing straightforward bitmap data, are then flushed to 
 * native platform bitmaps at the end.
 */
struct Imagette {
	@type('int') width,
	@type('int') height,
	@type('List<object>') nativeBitmaps,
	@type('List<int>') xs,
	@type('List<int>') ys,
}

/*
 * All native objects have this as an internal value.
 * The value field here is the actual native object.
 * This allows the native object to be consistently identified with the subtype marker.
 */
struct NativeObjectWrapper {
	@type('int') subType,
	@type('object') value,
}

/*
 * This is the wrapped native object value used for events.
 */
struct GameEvent {
	@type('string') specificType, // { mouseleftdown | mouserightdown | mouseleftup | mouserightup | mousemove | mousescroll | keydown | keyup | quit-x | quit-altf4 }
	@type('string') vagueType, // { mouse | key | hardware | quit } <-- technically these are redundant information with above, but allow for quick checks to see if specific fields are valid on the event object.
	@type('int') x, // re-used by hardware events for device index
	@type('int') y, // re-used by hardware events for 1 or 0 for is_significant
	@type('double') amount,
	@type('bool') down,
	@type('string') arg, // used for keyboard key, mouse button, or quit type
	@type('Value') argValue, // used for player ID for gamepad hardware events
	@type('Value') argValue2, // used for axis or button value in gamepad events
	@type('Value') argValue3, // used for button alias in gamepad events
}

struct GamepadStatus {
	// Whether the gamepad list has been populated...which happens on $game_initialize_screen
	@type('bool') isInitialized,

	// List of all the gamepads that are available on startup, regardless of whether they are enabled.
	// This list does not change.
	@type('List<GamepadDeviceInfo>') devices,
	@type('List<Value>') deviceValues, // parallel list to above, wrapped as NativeObject Values.
	@type('List<GamepadHardwarePushy>') hardwarePushies,
	@type('List<GamepadAtomicPushy>') atomicPushies,

	// Objects to be added to the event queue.
	@type('List<Value>') hardwareEvents,
	@type('List<Value>') virtualEvents,
}

struct GamepadDeviceInfo {
	// Basic info
	@type('int') deviceIndex,
	@type('object') nativeDevice,
	@type('string') name,
	@type('string') configFingerprint,

	// player ID and enabled state
	@type('Value') playerId, // null indicates the gamepad is not enabled.

	// some hardware information to identify this
	@type('int') axisCount,
	@type('int') hatCount,
	@type('int') buttonCount,

	// where are the pushies defined in the lists?
	@type('int') hardwarePushyStartIndex,
	@type('int') hardwarePushyCount,
	@type('int') atomicPushyStartIndex,
	@type('int') atomicPushyCount,

	// a lookup of pushies by their user defined ID
	@type('Dictionary<string, GamepadVirtualPushy>') stringVirtualPushies,
	@type('Dictionary<int, GamepadVirtualPushy>') intVirtualPushies,
	// the order in which virtual pushies were declared
	@type('List<string>') stringVirtualPushyIds,
	@type('List<int>') intVirtualPushyIds,
}

/*
	The term "pushy" is used instead of "button" because it refers to buttons, axes, and hats, as 
	opposed to just boolean buttons.
	There are 3 kinds of pushies described here:
	- Hardware pushy: an actual button, axis, or hat as described by the hardware driver. i.e. axis #3.
	- Atomic pushy: one specific subcomponent of a hardware pushy that can be identified as one action
	  examples:
		button #4
		hat #2 in the negative X direction
		axis #1 in the positive direction
	- Virtual pushy: a 0, 1, or 2 dimensional description of a collection of pushies that has been given
	  an alias by the user code.
	  examples:
		"jump" -> button #2
		"move" --> X+: Axis #0 in positive direction, X-: Axis #0 in negative direction, Y+: Axis #1 in negative direction, Y-: Axis #1 in positive direction
		"throttle" --> Positive: Hat #0 in positive X direction, Negative: Hat #0 in negative X direction
	
	All pushy types are saved in the GamepadState struct. At the end of each frame, the gamepad update phase occurs.
	
	Pass 1:
	During the update phase, a pass is made over all enabled joysticks which goes through and updates the individual
	hardware pushies. If the value is different, then the hardware pushy is updated to reflect this. Also the clock 
	counter is applied to the hardware pushy to indicate that it has been updated this frame.

	Pass 2:
	After the hardware pushies have been updated, a pass is made over all the atomic pushies. The atomic pushy is checked
	against its hardware pushy counterpart. If the value has changed, a hardware event is added to the next event queue to fire. 
	
	Pass 3:
	A pass is made across all virtual pushies. If any of the constituent atomic pushies that make up the virtual pushy has
	been updated this frame, then a user gamepad event is also added to the event queue.
*/
struct GamepadHardwarePushy {
	@type('int') deviceIndex,
	@type('int') type, // { 0 - button, 1 - axis, 2 - hat }
	@type('int') hardwareIndex, // the 4 in "axis #4"
	@type('bool') buttonValue,
	@type('double') axisValue,
	@type('int') hatXValue,
	@type('int') hatYValue,
	@type('int') buttonGameCounter,
	@type('int') axisPositiveGameCounter,
	@type('int') axisNegativeGameCounter,
	@type('int') hatXPositiveGameCounter,
	@type('int') hatYPositiveGameCounter,
	@type('int') hatXNegativeGameCounter,
	@type('int') hatYNegativeGameCounter,
}

struct GamepadAtomicPushy {
	@type('int') hardwarePushyIndex,
	@type('int') subtype, // {0 - button, 1 - axis+, 2 - axis-, 3 - hat X+, 4 - hat X-, 5 - hat Y+, 6 - hat Y-
	@type('bool') value,
	@type('double') valueF,
	@type('int') gameCounter,
	@type('string') descriptorId, // a string that uniquely identifies the hardware profile of this.
	@type('bool') isConfigured, // true if this is used as a virtual configuration
}

/*
	Virtual Buttons registered as digital will return:
	dim 0 - boolean
	dim 1 - -1, 0, or 1
	dim 2 - a list of size 2 of -1, 0, or 1

	Virtual buttons registered as analog will always return
	dim 0 - float from 0 to 1
	dim 1 - float from -1 to 1
	dim 2 - a list of 2 floats from -1 to 1
*/
struct GamepadVirtualPushy {
	@type('Value') alias, // user-defined int or string denoting this event type
	@type('int') dimensionality, // 0, 1, or 2
	@type('bool') isDigital, // true if this should fire digital events
	@type('int') atomicIndex1, // button, or 1D positive, or 2D X+
	@type('int') atomicIndex2, // 1D negative or 2D X-
	@type('int') atomicIndex3, // 2D Y+
	@type('int') atomicIndex4, // 2D Y-
	@type('int') gameCounter, // most recent game counter of constituents
}

struct HttpRequest {
	@type('int') statusCode,
	@type('string') status,
	@type('Dictionary<string, Array<string>>') headers,
	@type('string') body,
}

struct GlRenderState {
	@type('int') mode,
	@type('int') textureId,
	@type('int') r,
	@type('int') g,
	@type('int') b,
	@type('int') a
}
