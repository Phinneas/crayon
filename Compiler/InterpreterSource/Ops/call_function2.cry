
/*
	All function calls (even constructor invocations and primitive metthods) go through this op code, with the exception 
	of static constructors that are implicitly called from dereferencing a static field. However, implicit static constructor
	invocations that occur as a result of a static method invocation goes through this op as well.

	Generally, any ambiguous function invocation (such as invoking a field on a variable of unknown type) is resolved into
	a known invocation, and then follows through the rest of the shared codepath.

	Here are the values of FunctionInvocationType, and what they do in this op...
		
		NORMAL_FUNCTION
		Nothing special. Function is invoked.
		
		STATIC_METHOD
		Check to see if the class is staticly initialized. If it isn't (or not in progress), don't pop the args, subtract
		1 from the PC, and then change the invocation type to STATIC_CONSTRUCTOR. When it returns, it'll return to the previous
		PC and then resume this op again and it'll be initialized.
		
		LOCAL_METHOD
		At the final invocation phase, functionId and value must be set. 
		
		POINTER_PROVIDED
		Pop the stack, look at the pointer, and figure out what this is. Change type accordingly.
		This happens before final invocation time.
		
		FIELD_INVOCATION
		Pop the stack, look at the pointer, look at the field name, then resolve this into one of the following:
		LOCAL_METHOD, POINTER_PROVIDED (i.e. it's a function pointer that was set on a normal field of a class, or
		PRIMITIVE_METHOD
		
		CONSTRUCTOR

		BASE_CONSTRUCTOR
		
		STATIC_CONSTRUCTOR
		This is never invoked from the byte code. It is always invoked as a result of STATIC_METHOD.
		When it is invoked, it must mark the stack frame as having a static initalization resolution, so that when it's popped,
		the class is marked as fully initialized.
		
		PRIMITIVE_METHOD
		This is the only function invocation that does not result in stack changes. The value is computed 
		synchronously and immediately pushed back to the stack.
		There may be an exception to this in the future thoough, when list.sort(key_function_pointer) is added,
		in which case, this primitive method call may possibly be resolved into a NORMAL_FUNCTION call referring a
		function in the core library.
	}

	args:
	row[0] --> type (see above)
	row[1] --> args passed by user.
	row[2] --> functionID if known (available for all types except POINTER_PROVIDED)
	row[3] --> 1 if output is used
	row[4] --> class ID if method or constructor of any type.

*/

type = $_array_get(row, 0);
argCount = $_array_get(row, 1);
returnValueUsed = $_array_get(row, 3) == 1;
classId = $_array_get(row, 4);

// Check to see if a static initialization is required.
if (type == FunctionInvocationType.STATIC_METHOD) {
	classInfo2 = $_array_get(ProgramData$p.classTable2, classId);
	if (ClassInfo2$classInfo2.staticInitializationState > 0) {
		bool1 = false; // should call static constructor?
		if (ClassInfo2$classInfo2.staticInitializationState == 2) {
			ClassInfo2$classInfo2.staticInitializationState = 1;
			$_list_push(ProgramData$p.classStaticInitializationStack, classId);
		} else { // initialization of the class being called is in progress
			intList1 = ProgramData$p.classStaticInitializationStack;
			if ($_list_get(intList, $_list_length(intList1) - 1) != classId) { // is it somewhere else in the stack?
				return killExecution(stack, pc, "Static initialization cycle detected. See stack trace for cycle details.");
			}
		}

		if (bool1) {
			// Static constructor needs to be called before this method can be invoked.
			type = FunctionInvocationType.STATIC_CONSTRUCTOR;
			pc -= 1; // when the static constructor is done, you want the PC to start back on this same op and retry the static method invocation.
			argCount = 0;
			returnValueUsed = false;
		}
	}
}

// Note that if a static constructor is invoked, the args of the previous static method are safe because argCount was set to 0.
if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
	// creating an array of fixed length is fast in C# and Java
	funcArgs = $_new_array('Value', argCount);
	while (argCount > 0) {
		argCount -= 1;
		valueStackSize -= 1;
		$_array_set(funcArgs, argCount, $_array_get(valueStack, valueStackSize));
	}
} else {
	// Building a list from 0 is faster in Python and JavaScript
	// Note that this code uses a list instead of an array even though the rest of this op treats funcArgs as an array.
	// This is because this is currently only being used on Python/JavaScript where those are the same thing.
	funcArgs = $_new_list('Value');
	while (argCount > 0) {
		valueStackSize -= 1;
		$_list_push(funcArgs, $_array_get(valueStack, valueStackSize));
		argCount -= 1;
	}
	if ($_list_length(funcArgs) > 1) {
		$_list_reverse_in_place(funcArgs);
	}
}


if (type == FunctionInvocationType.FIELD_INVOCATION) {
	// provided pointers have no risk of requiring a static initialization because the pointer can only be 
	// provided from a source that would have already triggered it.

	// Pop the stack and see what we have.
	value = $_array_get(valueStack, valueStackSize - 1);
	valueStackSize -= 1;

	// If this is a field invocation on an object instance, resolve it into a LOCAL_METHOD or POINTER_PROVIDED.
	if (type == FunctionInvocationType.FIELD_INVOCATION) {
		switch (Value$value.type) {
			case Types.INSTANCE:
				objInstance = $_cast('ObjectInstance', Value$value.internalValue);
				int1 = ObjectInstance$objInstance.classId; // note that classId has the field name ID and so this is sort of confusing
				classInfo2 = $_array_get(classTable2, int1);
				if ($_dictionary_contains(ClassInfo2$classInfo2.globalIdToMemberId, classId)) {
					int1 = $_dictionary_get_guaranteed(ClassInfo2$classInfo2.globalIdToMemberId, classId); // int1 is now the member ID.
					// now that we have the member ID, check to see if this is a field or a known method.
					functionId = $_array_get(ClassInfo2$classInfo2.functionIdsByMemberId, int1); // get the function ID, if present
					if (functionId > 0) {
						// This is a local method. 'value' already contains the context.
						type = FunctionInvocationType.LOCAL_METHOD;
					} else {
						// This is just a field which is a pointer to something. Dereference the field into 'value' and change type to POINTER_PROVIDED.
						// Since there are unverified POINTER_PROVIDED codepaths at this point, don't do verification that it is a FunctionPointer here 
						// as it will be done redundantly later.
						value = $_array_get(ObjectInstance$objInstance.members, int1);
						type = FunctionInvocationType.POINTER_PROVIDED;
					}
				} else {
					return killExecution(stack, pc, "Unknown field."); // TODO: use the class name and field name.
				}
				break;
			default:
				// resolve a primitive method
				functionId = resolvePrimitiveMethodName2(p, Value$value.type, classId); // enum value in PrimitiveMethodName
				if (functionId == 0) {
					return killExecution(stack, pc, "Unknown primitive method.");
				}
				type = FunctionInvocationType.PRIMITIVE_METHOD;
				break;
		}
	}
}

if (type == FunctionInvocationType.POINTER_PROVIDED) {
	if (Value$value.type == Types.FUNCTION) {
		functionPointer1 = $_cast('FunctionPointer', Value$value.internalValue);
		switch (FunctionPointer$functionPointer1.type) {
			case FunctionPointerType.FUNCTION:
				functionId = FunctionPointer$functionPointer1.functionId;
				type = FunctionInvocationType.NORMAL_FUNCTION;
				break;
			case FunctionPointerType.METHOD:
				functionId = FunctionPointer$functionPointer1.functionId;
				value = FunctionPointer$functionPointer1.context;
				type = FunctionInvocationType.LOCAL_METHOD;
				break;
			case FunctionPointerType.STATIC_METHOD:
				functionId = FunctionPointer$functionPointer1.functionId;
				classId = FunctionPointer$functionPointer1.classId;
				type = FunctionInvocationType.STATIC_METHOD;
				break;
			case FunctionPointerType.PRIMITIVE_METHOD:
				value = FunctionPointer$functionPointer1.context;
				functionId = FunctionPointer$functionPointer1.functionId;
				type = FunctionInvocationType.PRIMITIVE_METHOD;
				break;
			default: break; // this should not happen.
		}
	} else {
		return killExecution(stack, pc, "This type cannot be invoked like a function.");
	}
}

// should invoke function. Set to false if PRIMITIVE_METHOD, although some primitive methods that take in a function pointer and need to
// run in general execution are implemented as byte code in a library. 
bool1 = true; 

if (type == FunctionInvocationType.PRIMITIVE_METHOD) {
	bool1 = false;
	output = null;
	switch (Value$value.type) {
		case Types.STRING:
			string1 = $_cast('string', Value$value.internalValue);
			switch (functionId) {
				case PrimitiveMethodName.CONTAINS:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement string.contains");
					}
					break;
				case PrimitiveMethodName.ENDS_WITH:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement string.endsWith");
					}
					break;
				case PrimitiveMethodName.INDEX_OF:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement string.indexOf");
					}
					break;
				case PrimitiveMethodName.LOWER:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement string.lower");
					}
					break;
				case PrimitiveMethodName.REPLACE:
					if (argCount == 2) {
						return killExecution(stack, pc, "TODO: re-implement string.replace(old, new)");
					} else if (argCount == 3) {
						return killExecution(stack, pc, "TODO: re-implement string.replace(old, new, replaceLimit)");
					}
					break;
				case PrimitiveMethodName.REVERSE:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement string.reverse");
					}
					break;
				case PrimitiveMethodName.SPLIT:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement string.split()");
					} else if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement string.split(sep)");
					} else if (argCount == 2) {
						return killExecution(stack, pc, "TODO: re-implement string.split(sep, splitLimit)");
					}
					break;
				case PrimitiveMethodName.STARTS_WITH:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement string.startsWith(str)");
					}
					break;
				case PrimitiveMethodName.TRIM:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement string.trim()");
					}
					break;
				case PrimitiveMethodName.UPPER:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement string.upper()");
					}
					break;
				default:
					break;
			}
			break;
		case Types.LIST:
			list1 = $_cast('List<Value>', Value$value.internalValue);
			switch (functionId) {
				case PrimitiveMethodName.ADD:
					for (i = 0; i < argCount; i += 1) {
						$_list_push(list1, $_array_get(funcArgs, i));
					}
					output = VALUE_NULL;
					break;
				case PrimitiveMethodName.CLEAR:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement list.clear");
					}
					break;
				case PrimitiveMethodName.CLONE:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement list.clone");
					}
					break;
				case PrimitiveMethodName.CONCAT:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement list.concat");
					}
					break;
				case PrimitiveMethodName.CONTAINS:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement list.contains");
					}
					break;
				case PrimitiveMethodName.INSERT:
					if (argCount == 2) {
						return killExecution(stack, pc, "TODO: re-implement list.insert");
					}
					break;
				case PrimitiveMethodName.JOIN:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement list.join");
					}
					break;
				case PrimitiveMethodName.REMOVE:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement list.remove");
					}
					break;
				case PrimitiveMethodName.REVERSE:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement list.reverse");
					}
					break;
				case PrimitiveMethodName.SHUFFLE:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement list.shuffle()");
					}
					break;
				case PrimitiveMethodName.SORT:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement list.sort()");
					} else if (argCount == 1) {
						value2 = $_array_get(funcArgs, 0);
						if (Value$value2.type == Types.FUNCTION) {

							bool1 = true;
							type = FunctionInvocationType.NORMAL_FUNCTION;
							functionId = 0; // TODO: figure out the function ID of the Core.listSort(fp, list)
							// TODO: push the list onto the funcArgs list.
						} else {
							return killExecution(stack, pc, "list.sort(get_key_function) requires a function pointer as its argument.");
						}
					}
					break;
				default: break;
			}
			break;
		case Types.DICTIONARY:
			switch (functionId) {
				case PrimitiveMethodName.CLEAR:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.clear()");
					}
					break;
				case PrimitiveMethodName.CLONE:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.clone()");
					}
					break;
				case PrimitiveMethodName.CONTAINS:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.contains()");
					}
					break;
				case PrimitiveMethodName.GET:
					if (argCount == 2) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.get(key, fallback)");
					} else if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.get(key)");
					}
					break;
				case PrimitiveMethodName.KEYS:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.keys()");
					}
					break;
				case PrimitiveMethodName.REMOVE:
					if (argCount == 1) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.remove(key)");
					}
					break;
				case PrimitiveMethodName.VALUES:
					if (argCount == 0) {
						return killExecution(stack, pc, "TODO: re-implement dictionary.values()");
					}
					break;
				default: break;
			}
			break;

		default: break;
	}
	
	if (!bool1) {
		if (output == null) {
			return killExecution(stack, pc, "primitive method not found.");
		} else {
			import inline "InterpreterSource/ValueStackCapacityCheck.cry";
			$_array_set(valueStack, valueStackSize, output);
			valueStackSize += 1;
		}
	}
}

if (bool1) {
	
	StackFrame$stack.pc = pc;

	// Set the following variables...
	// pc --> since pc is now saved, put the new PC into the 'pc' variable.
	// classId --> for static constructors, set this to the class ID to mark as initialization-completed, 0 otherwise
	// value --> the value of 'this' in the next function
	switch (type) {
		case FunctionInvocationType.NORMAL_FUNCTION:
			functionInfo2 = $_array_get(functionTable2, functionId);
			pc = FunctionInfo2$functionInfo2.pc;
			value = null;
			classId = 0;
			break;
		case FunctionInvocationType.STATIC_METHOD:
			// classId already set
			functionInfo2 = $_array_get(functionTable2, functionId);
			pc = FunctionInfo2$functionInfo2.pc;
			value = null;
			break;
		case FunctionInvocationType.LOCAL_METHOD:
			functionInfo2 = $_array_get(functionTable2, functionId);
			pc = FunctionInfo2$functionInfo2.pc;
			classId = 0;
			// value already set
			break;
		case FunctionInvocationType.CONSTRUCTOR:
			ProgramData$p.instanceCounter += 1;
			classInfo2 = $_array_get(classTable2, classId);
			valueArray1 = $_new_array('Value', ClassInfo2$classInfo2.memberCount);
			for (i = $_list_length(valueArray1) - 1; i >= 0; i -= 1) {
				$_array_set(valueArray1, i, VALUE_NULL);
			}
			objInstance1 = new ObjectInstance(
				classId,
				ProgramData$p.instanceCounter,
				valueArray1,
				null);
			value = new Value(Types.INSTANCE, objInstance1);
			functionId = ClassInfo2$classInfo2.constructorFunctionId;
			functionInfo2 = $_array_get(functionTable2, functionId);
			pc = FunctionInfo2$functionInfo2.pc;
			classId = 0;
			if (returnValueUsed) {
				// if the return value is used, push the new constructed object to the stack NOW and then call the function
				// as though the return value is not used.
				returnValueUsed = false;
				import inline "InterpreterSource/ValueStackCapacityCheck.cry";
				$_array_set(valueStack, valueStackSize, value);
				valueStackSize += 1;
			}
			break;
		case FunctionInvocationType.BASE_CONSTRUCTOR:
			value = StackFrame$stack.objectContext;
			classInfo2 = $_array_get(classTable2, classId);
			functionId = ClassInfo2$classInfo2.constructorFunctionId;
			functionInfo2 = $_array_get(functionTable2, functionId);
			pc = FunctionInfo2$functionInfo2.pc;
			classId = 0;
			break;
		case FunctionInvocationType.STATIC_CONSTRUCTOR:
			classInfo2 = $_array_get(classTable2, classId);
			functionId = ClassInfo2$classInfo2.staticConstructorFunctionId;
			functionInfo2 = $_array_get(functionTable2, functionId);
			pc = FunctionInfo2$functionInfo2.pc;
			// classId already set
			value = null;
			break;
		default: break; // this should not happen.
	}

	locals = $_new_dictionary('int', 'Value');
	stack = new StackFrame(pc, locals, funcArgs, stack, returnValueUsed, value, valueStackSize, classId);
}
