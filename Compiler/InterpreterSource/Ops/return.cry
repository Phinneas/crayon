// row[0]: 
//   0 --> no return value on stack, implicit null.
//   1 --> return value is on the stack.

if (StackFrame$stack.previous == null) {
	// returning from the root stack
	return '';
}

if (StackFrame$stack.returnValueUsed) {
	if ($_array_get(row, 0) == 0) {
		// returning null? pop the stack frame stack and push null to the value stack. Capacity check needed.
		valueStackSize = StackFrame$stack.valueStackSize;
		stack = StackFrame$stack.previous;
		import inline "InterpreterSource/ValueStackCapacityCheck.cry"; // edge case: called function didn't push anything to the stack and you happen to be at the valueStack capacity
		$_array_set(valueStack, valueStackSize, VALUE_NULL);
		valueStackSize = StackFrame$stack.valueStackSize + 1;
	} else {
		// everything else, pop the value, pop any garbage (such as foreach loop data) off the value stack along with the stack frame, and push the value back on the stack.
		// no capacity check needed since the value was already on the stack.
		// It's possible to optimize this such that the value unpop and repop could be eliminated if there is no other garbage on the value stack, but the 
		// performance benefits are relatively slim.
		value = $_array_get(valueStack, valueStackSize - 1);
		valueStackSize = StackFrame$stack.valueStackSize;
		stack = StackFrame$stack.previous;
		$_array_set(valueStack, valueStackSize, VALUE_NULL);
		valueStackSize = StackFrame$stack.valueStackSize + 1;
	}
} else {
	// discard the return value. Set the value stack size back the way it was.
	valueStackSize = StackFrame$stack.valueStackSize;
	stack = StackFrame$stack.previous;
}

pc = StackFrame$stack.pc;
localsStackOffset = StackFrame$stack.localsStackOffset;
localsStackSetToken = StackFrame$stack.localsStackSetToken;

