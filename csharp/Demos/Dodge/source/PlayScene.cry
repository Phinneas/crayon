
function random_edge_point() {
	side = $random();
	if (side < .25) { // left
		x = 20;
		y = $random() * (600 - 40) + 20;
	} else if (side < .5) { // right
		x = 800 - 20;
		y = $random() * (600 - 40) + 20;
	} else if (side < .75) {
		x = $random() * (800 - 40) + 20;
		y = 20;
	} else {
		x = $random() * (800 - 40) + 20;
		y = 600 - 20;
	}
	
	return [x, y];
}

class Sprite {
	constructor(type, x, y) {
		this.type = type;
		this.x = x;
		this.y = y;
		this.targetX = null;
		this.targetY = null;
		this.dx = 0;
		this.dy = 0;
		this.dead = false;
		this.lastdir = 's';
		this.v = 4; //type == 'fire' ? 1 : 3;
		this.moving = false;
	}
	
	
	function update_direction(dx, dy) {
		angle = -1 * $arctan2(dy, dx);
		pi = 3.14159265358979;
		angle = (angle * .99) % (2 * pi);
		if (angle < pi / 4 || angle > 7 * pi / 4) {
			this.lastdir = 'e';
		} else if (angle < 3 * pi / 4) {
			this.lastdir = 'n';
		} else if (angle < 5 * pi / 4) {
			this.lastdir = 'w';
		} else {
			this.lastdir = 's';
		}
	}
	
	function update() {
		if (this.type == 'fire' && this.targetX == null) {
			xy = random_edge_point();
			this.targetX = xy[0];
			this.targetY = xy[1];
		}
		
		if (this.targetX != null) {
			this.moving = true;
			dx = this.targetX - this.x;
			dy = this.targetY - this.y;
			distance = (dx * dx + dy * dy) ** .5;
			if (distance < this.v) {
				this.x = this.targetX;
				this.y = this.targetY;
				this.targetX = null;
				this.targetY = null;
			} else {
				ratio = this.v / distance;
				dx *= ratio;
				dy *= ratio;
				this.x += dx;
				this.y += dy;
			}
			
			if (this.type == 'player') {
				this.update_direction(dx, dy);
			}
		} else {
			this.moving = false;
		}
	}
}

class PlayScene : SceneBase {
	constructor() : base() {
		this.player = new Sprite('player', 400, 300);
		this.sprites = [this.player];
		this.counter = 0;
		this.reset_counter = -1;
		this.fires = 0;
	}
	
	function process_input(events) {
		for (i = 0; i < events.length; ++i) {
			ev = events[i];
			if (ev[0] == 'mouseleftdown') {
				this.player.targetX = ev[1];
				this.player.targetY = ev[2];
			}
		}
	}
	
	function update() {
		this.counter++;
		this.reset_counter--;
		
		if (this.reset_counter == 0) {
			this.next = new PlayScene();
		}
		
		if (this.player.dead && this.reset_counter < 0) {
			this.reset_counter = 50;
			this.sprites.add(new Sprite('body', this.player.x, this.player.y));
		}
		
		if (this.counter % 20 == 0) {
			pt = random_edge_point();
			fire = new Sprite('fire', pt[0], pt[1]);
			pt = random_edge_point();
			fire.targetX = pt[0];
			fire.targetY = pt[1];
			this.sprites.add(fire);
			if (this.reset_counter < 0) {
				this.fires++;
			}
		}
		
		px = this.player.x;
		py = this.player.y;
		
		new_sprites = [];
		for (i = 0; i < this.sprites.length; ++i) {
			sprite = this.sprites[i];
			sprite.update();
			if (!sprite.dead) {
				new_sprites.add(sprite);
			}
			
			if (sprite.type == 'fire') {
				dx = px - sprite.x;
				dy = py - sprite.y;
				if ((dx * dx + dy * dy) < 20 * 20) {
					this.player.dead = true;
				}
			}
		}
		this.sprites = new_sprites;
		
	}
	
	function render(imgLib) {
		for (i = 0; i < this.sprites.length; ++i) {
			sprite = this.sprites[i];
			x = $floor(sprite.x) - 20;
			y = $floor(sprite.y) - 20;
			if (sprite.type == 'player') {
				frame = 1;
				if (sprite.moving) {
					frame = (this.counter / 3) % 4;
					frame += 1;
					if (frame == 4) {
						frame = 2;
					}
				}
				img = imgLib.images['player/' + sprite.lastdir + frame];
			} else if (sprite.type == 'body') {
				img = imgLib.images['player/dead'];
			} else {
				img = imgLib.images['fire' + ((this.counter / 3) % 2 + 1)];
			}
			$blit_image(img, x, y);
		}
		
		num = this.fires + '';
		x = 10;
		y = 500;
		for (i = 0; i < num.length; ++i) {
			c = num[i];
			img = imgLib.images['numbers/num' + c];
			$blit_image(img, x, y);
			x += 50;
		}
	}
}