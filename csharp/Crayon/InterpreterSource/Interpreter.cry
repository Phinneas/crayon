
function @omitReturn @type('string') interpret(
		@type('StackFrame') stack,
		@type('Array<int>') ops,
		@type('Array<Array<int>>') args,
		@type('Array<string>') stringArgs,
		@type('Array<string>') identifiers,
		@type('Dictionary<string, int>') inv_identifiers,
		@type('Array<Value>') literalTable,
		@type('Array<ClassInfo>') classTable,
		@type('Array<Dictionary<int, MethodDefinition>>') classMethods,
		@type('Array<Array<int>>') specialCache,
		@type('Dictionary<int, Value>') globals) {

	@type('Stack<Value>') valueStack = StackFrame$stack.valueStack;
	@type('Dictionary<int, Value>') locals = StackFrame$stack.locals;
	@type('int') LENGTH_ID = -999;
	if ($_dictionary_contains(inv_identifiers, 'length')) {
		LENGTH_ID = $_dictionary_get_guaranteed(inv_identifiers, 'length');
	}
	@type('ProgramData') p = $_get_program_data();

	if (ProgramData$p.initializationComplete) {
		performWorkNuggetPreFrame();
	}

	// declare types...
	@type('int') type = 0;
	@type('int') nameId = 0;
	@type('int') classId = 0;
	@type('ClassInfo') classInfo = null;
	@type('int') len = 0;
	@type('Value') root = null;
	@type('Array<int>') row = null;
	@type('int') pc = 0;
	@type('int') argCount = 0;
	@type('Array<Value>') funcArgs = null;
	@type('Array<string>') stringList = null;
	@type('bool') returnValueUsed = false;
	@type('Value') output = null;
	@type('Value') func = null;
	@type('SystemMethod') sysMethod = null;
	@type('string') error = null;
	@type('MethodInstance') methodInstance = null;
	@type('MethodDefinition') methodDefinition = null;
	@type('Dictionary<int, MethodDefinition>') methodDefinitionLookup = null;
	@type('FunctionDefinition') funcDef = null;
	@type('ObjectInstance') objInstance = null;
	@type('ObjectInstance') objInstance2 = null;
	@type('object') object1 = null;
	@type('DictImpl') dictImpl = null;
	@type('Array<List<Token>>') tokensByPc = null;
	@type('List<Token>') tokens = null;
	@type('int') keyType = 0;
	@type('int') intKey = 0;
	@type('string') stringKey = null;
	@type('Dictionary<int, Value>') dictIntKeyLookup = null;
	@type('Dictionary<int, Value>') dictIntValueLookup = null;
	@type('Dictionary<string, Value>') dictStringKeyLookup = null;
	@type('Dictionary<string, Value>') dictStringValueLookup = null;
	@type('bool') first = false;

	@type('int') int1 = 0;
	@type('int') int2 = 0;
	@type('int') int3 = 0;
	@type('int') int4 = 0;
	@type('int') i = 0;
	@type('double') float1 = 3.14;
	@type('double') float2 = 2.718;
	@type('Value') value = null;
	@type('Value') value2 = null;
	@type('Value') value3 = null;
	@type('string') string1 = null;
	@type('string') string2 = null;
	@type('string') string3 = null;
	@type('List<Value>') list1 = null;
	@type('bool') bool1 = false;
	@type('bool') bool2 = false;
	@type('List<int>') intList1 = null;
	@type('NativeObjectWrapper') nativeObject = null;
	@type('Image') image1 = null;
	@type('GameEvent') gameEvent = null;
	@type('SoundInstance') sound1 = null;
	@type('GamepadDevice') gamepad1 = null;
	@type('HttpRequest') httpRequest1 = null;
	@type('Array<double>') floatList1 = $_new_array('double', 2);

	// binary op variables...
	@type('int') op = 0;
	@type('Value') leftValue = null;
	@type('Value') rightValue = null;
	@type('object') left = null;
	@type('object') right = null;
	@type('int') leftType = 0;
	@type('int') rightType = 0;

	// args...
	@type('Value') arg1 = null;
	@type('Value') arg2 = null;
	@type('Value') arg3 = null;
	@type('Value') arg4 = null;
	@type('Value') arg5 = null;
	@type('Value') arg6 = null;
	@type('Value') arg7 = null;
	@type('Value') arg8 = null;
	@type('Value') arg9 = null;

	@type('Array<Dictionary<int, int>>') integerSwitches = ProgramData$p.integerSwitchLookups;
	@type('Array<Dictionary<string, int>>') stringSwitches = ProgramData$p.stringSwitchLookups;
	@type('Dictionary<string, int>') primitiveMethodLookup = ProgramData$p.primitiveMethodLookup;
	@type('Dictionary<int, int>') integerSwitch = null;
	@type('Dictionary<string, int>') stringSwitch = null;

	@type('SpriteSheetData') spriteSheetData = ProgramData$p.spriteSheetData;

	while (true) {
		row = $_array_get(args, StackFrame$stack.pc);
		switch ($_array_get(ops, StackFrame$stack.pc)) {

			case OpCodes.ADD_LITERAL:
				$_comment('ADD_LITERAL');
				type = $_array_get(row, 0);
				if (type == Types.NULL) {
					$_list_push(ProgramData$p.literalTableBuilder, VALUE_NULL);
				} else if (type == Types.BOOLEAN) {
					if ($_array_get(row, 1) == 1) {
						$_list_push(ProgramData$p.literalTableBuilder, VALUE_TRUE);
					} else {
						$_list_push(ProgramData$p.literalTableBuilder, VALUE_FALSE);
					}
				} else if (type == Types.INTEGER) {
					$_list_push(ProgramData$p.literalTableBuilder, buildInteger($_array_get(row, 1)));
				} else if (type == Types.FLOAT) {
					$_list_push(ProgramData$p.literalTableBuilder, buildFloat($_string_parse_float($_array_get(stringArgs, StackFrame$stack.pc))));
				} else if (type == Types.STRING) {
					$_list_push(ProgramData$p.literalTableBuilder, buildCommonString($_array_get(stringArgs, StackFrame$stack.pc)));
				}
				break;

			case OpCodes.ADD_NAME:
				$_comment('ADD_NAME');
				string1 = $_array_get(stringArgs, StackFrame$stack.pc); // actual name vaule
				int1 = $_list_length(ProgramData$p.identifiersBuilder); // name ID (sequentially allocated so it happens to be the length of the list at the time of declaration)
				$_dictionary_set(inv_identifiers, string1, int1);
				$_list_push(ProgramData$p.identifiersBuilder, string1);
				if (string1 == 'length') {
					LENGTH_ID = int1;
				}
				break;

			case OpCodes.ASSIGN_FUNCTION_ARG:
				$_comment('ASSIGN_FUNCTION_ARG');
				nameId = $_array_get(row, 0);
				i = $_array_get(row, 1);
				if (i >= $_array_length(StackFrame$stack.args)) {
					// pass in previous stack so that it's pointing at the spot where you invoke the function.
					return killExecution(StackFrame$stack.previous, "Not enough arguments supplied.");
				}
				value = $_array_get(StackFrame$stack.args, $_array_get(row, 1));
				$_dictionary_set(locals, nameId, value);
				break;

			case OpCodes.ASSIGN_FUNCTION_ARG_AND_JUMP:
				$_comment('ASSIGN_FUNCTION_ARG_AND_JUMP');
				nameId = $_array_get(row, 0);
				i = $_array_get(row, 1);
				if (i < $_array_length(StackFrame$stack.args)) {
					value = $_array_get(StackFrame$stack.args, i);
					$_dictionary_set(locals, nameId, value);
					StackFrame$stack.pc += $_array_get(row, 2);
				}
				break;

			case OpCodes.ASSIGN_INDEX:
				$_comment('ASSIGN_INDEX');
				value = $_stack_pop(valueStack);
				value2 = $_stack_pop(valueStack); // index
				root = $_stack_pop(valueStack);
				type = Value$root.type;
				bool1 = row[0] == 1; // re-push this onto the stack once it is assigned
				if (type == Types.LIST) {
					if (Value$value2.type == Types.INTEGER) {
						i = $_cast('int', Value$value2.internalValue);
						list1 = $_cast('List<Value>', Value$root.internalValue);
						if (i < 0) {
							return killExecution(stack, "Index must be non-negative.");
						} else if (i >= $_list_length(list1)) {
							return killExecution(stack, "Index is out of range.");
						} else {
							$_list_set(list1, i, value);
						}
					} else {
						return killExecution(stack, "List index must be an integer.");
					}
				} else if (type == Types.DICTIONARY) {
					keyType = Value$value2.type;
					if (keyType == Types.INTEGER) {
						intKey = $_cast('int', Value$value2.internalValue);
					} else if (keyType == Types.STRING) {
						stringKey = $_cast('string', Value$value2.internalValue);
					} else if (keyType == Types.INSTANCE) {
						objInstance = $_cast('ObjectInstance', Value$value2.internalValue);
						intKey = ObjectInstance$objInstance.objectId;
					} else {
						return killExecution(stack, "Invalid key for a dictionary.");
					}

					dictImpl = $_cast('DictImpl', Value$root.internalValue);
					bool2 = DictImpl$dictImpl.size > 0; // already contains stuff
					if (bool2 && DictImpl$dictImpl.keyType != keyType) {
						return killExecution(stack, "Cannot have multiple keys in one dictionary with different types.");
					}
					if (keyType == Types.STRING) {
						if (!$_dictionary_contains(DictImpl$dictImpl.keyStringLookup, stringKey)) {
							$_dictionary_set(DictImpl$dictImpl.keyStringLookup, stringKey, value2);
							DictImpl$dictImpl.size += 1;
							if (!bool2) { // is empty?
								DictImpl$dictImpl.keyType = keyType;
							}
						}
						$_dictionary_set(DictImpl$dictImpl.valueStringLookup, stringKey, value);
					} else {
						if (!$_dictionary_contains(DictImpl$dictImpl.keyIntLookup, intKey)) {
							$_dictionary_set(DictImpl$dictImpl.keyIntLookup, intKey, value2);
							DictImpl$dictImpl.size += 1;
							if (!bool2) { // is empty?
								DictImpl$dictImpl.keyType = keyType;
							}
						}
						$_dictionary_set(DictImpl$dictImpl.valueIntLookup, intKey, value);
					}
				} else {
					return killExecution(stack, getTypeFromId(type) + " type does not support indexing");
				}

				if (bool1) {
					$_stack_push(valueStack, value);
				}

				break;

			case OpCodes.ASSIGN_STEP:
				$_comment('ASSIGN_STEP');
				value = $_stack_pop(valueStack);
				value2 = $_stack_pop(valueStack); // target root
				nameId = $_array_get(row, 0);
				bool1 = $_array_get(row, 1) == 1;
				if (Value$value2.type == Types.INSTANCE) {
					objInstance2 = $_cast('ObjectInstance', Value$value2.internalValue);
					$_dictionary_set(ObjectInstance$objInstance2.fields, nameId, value);
				} else {
					killExecution(stack, "Cannot assign to a field on this type.");
				}

				if (bool1) {
					$_stack_push(valueStack, value);
				}
				break;

			case OpCodes.ASSIGN_THIS_STEP:
				$_comment('ASSIGN_THIS_STEP');
				value2 = StackFrame$stack.objectContext; // value2 will never be null because that is a compile error.
				// TODO: prevent assignment to methods
				value = $_stack_pop(valueStack);
				nameId = $_array_get(row, 0);
				objInstance = $_cast('ObjectInstance', Value$value2.internalValue);
				$_dictionary_set(ObjectInstance$objInstance.fields, nameId, value);
				break;

			case OpCodes.ASSIGN_VAR:
				$_comment('ASSIGN_VAR');
				value = $_stack_pop(valueStack);
				$_dictionary_set(locals, $_array_get(row, 0), value);
				break;

			case OpCodes.BINARY_OP:
				$_comment('BINARY_OP');
				rightValue = $_stack_pop(valueStack);
				leftValue = $_stack_pop(valueStack);

				leftType = Value$leftValue.type;
				rightType = Value$rightValue.type;
				
				left = Value$leftValue.internalValue;
				right = Value$rightValue.internalValue;
				
				// TODO: special switch for when left == right
				op = $_array_get(row, 0);
				value = null;
				if (op == BinaryOps.EQUALS || op == BinaryOps.NOT_EQUALS) {
					if (%%%STRONGLY_TYPED%%%) {
						if (doEqualityComparisonAndReturnCode(leftValue, rightValue) == 1) {
							value = VALUE_TRUE;
						} else {
							value = VALUE_FALSE;
						}
					} else {
						if (leftType == rightType) {
							if (leftType <= Types.DICTIONARY) { // Note that this exists. Changing the ordering of types in the enum definition could ruin ==/!=
								if (left == right) { // may have to change if a platform doesn't support == for strings
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							} else if (leftType == Types.INSTANCE) {
								objInstance = $_cast('ObjectInstance', left);
								objInstance2 = $_cast('ObjectInstance', right);
								if (ObjectInstance$objInstance.objectId == ObjectInstance$objInstance2.objectId) {
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							}
						} else {
							if ((leftType == Types.INTEGER && rightType == Types.FLOAT) || (leftType == Types.FLOAT && rightType == Types.INTEGER)) {
								// does this work on c#? 
								// (object)0.0 == (object)0
								if (left == right) {
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							} else {
								value = VALUE_FALSE;
							}
						}
					}
					
					if (value != null) {
						if (op == BinaryOps.NOT_EQUALS) {
							if ($_cast('bool', Value$value.internalValue)) {
								value = VALUE_FALSE;
							} else {
								value = VALUE_TRUE;
							}
						}
					} else {
						return killExecution(stack, "== and != not defined here yet.");
					}
				} else if ((leftType == Types.STRING || rightType == Types.STRING) && op == BinaryOps.ADDITION && leftType != Types.NULL && rightType != Types.NULL) {
					value = new Value(Types.STRING, valueToString(leftValue) + valueToString(rightValue));
				} else {
					switch
						{((MAX_TYPE * MAX_OP + MAX_OP) * MAX_TYPE + MAX_TYPE)} // maximum possible value
						((((Value$leftValue.type * MAX_OP) + op) * MAX_TYPE) + Value$rightValue.type) {
						
						// int ** int
						case (Types.INTEGER * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.INTEGER:
							$_comment('int ** int');
							if ($_cast('int', right) == 0) value = $_array_get($_array_get(INTEGERS_CACHE, 0), 1);
							else if ($_cast('int', right) > 0)
								value = buildInteger($_int($_exponent($_cast('int', left), $_cast('int', right))));
							else
								value = buildFloat($_exponent($_cast('int', left), $_cast('int', right)));
							break;

						// int ** float
						case (Types.INTEGER * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.FLOAT:
							$_comment('int ** float');
							value = buildFloat(0.0 + $_exponent($_cast('int', left), $_cast('double', right)));
							break;

						// float ** int
						case (Types.FLOAT * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.INTEGER:
							$_comment('float ** int');
							// add 0.0 just in case underlying platform likes to fall back to integer when possible
							value = buildFloat(0.0 + $_exponent($_cast('double', left), $_cast('int', right)));
							break;

						// float ** float
						case (Types.FLOAT * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.FLOAT:
							$_comment('float ** float');
							value = buildFloat(0.0 + $_exponent($_cast('double', left), $_cast('double', right)));
							break;
						
						// float % float
						case (Types.FLOAT * MAX_OP + BinaryOps.MODULO) * MAX_TYPE + Types.FLOAT:
							$_comment('float % float');
							if ($_cast('double', right) == 0) return killExecution(stack, "Modulo by 0");
							float1 = $_cast('double', left) % $_cast('double', right);
							if (float1 < 0) float1 += $_cast('double', right);
							value = buildFloat(float1);
							break;

						// float % int
						case (Types.FLOAT * MAX_OP + BinaryOps.MODULO) * MAX_TYPE + Types.INTEGER:
							$_comment('float % int');
							if ($_cast('int', right) == 0) return killExecution(stack, "Modulo by 0");
							float1 = $_cast('double', left) % $_cast('int', right);
							if (float1 < 0) float1 += $_cast('int', right);
							value = buildFloat(float1);
							break;

						// int % float
						case (Types.INTEGER * MAX_OP + BinaryOps.MODULO) * MAX_TYPE + Types.FLOAT:
							$_comment('int % float');
							if ($_cast('double', right) == 0) return killExecution(stack, "Modulo by 0");
							float1 = $_cast('int', left) % $_cast('double', right);
							if (float1 < 0) float1 += $_cast('double', right);
							value = buildFloat(float1);
							break;

						// int % int
						case (Types.INTEGER * MAX_OP + BinaryOps.MODULO) * MAX_TYPE + Types.INTEGER:
							$_comment('int % int');
							if ($_cast('int', right) == 0) return killExecution(stack, "Modulo by 0");
							int1 = $_cast('int', left) % $_cast('int', right);
							if (int1 < 0) int1 += $_cast('int', right);
							value = buildInteger(int1);
							break;

						// list + list
						case (Types.LIST * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.LIST:
							$_comment('list + list');
							value = new Value(Types.LIST, $_list_concat($_cast('List<Value>', left), $_cast('List<Value>', right))); break;

						// int + int
						case (Types.INTEGER * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.INTEGER:
							$_comment('int + int');
							value = buildInteger($_cast('int', left) + $_cast('int', right)); break;

						// float + int
						case (Types.FLOAT * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.INTEGER:
							$_comment('float + int');
							value = buildFloat($_cast('double', left) + $_cast('int', right)); break;

						// int + float
						case (Types.INTEGER * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.FLOAT:
							$_comment('int + float');
							value = buildFloat($_cast('int', left) + $_cast('double', right)); break;

						// float + float
						case (Types.FLOAT * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.FLOAT:
							$_comment('float + float');
							value = buildFloat($_cast('double', left) + $_cast('double', right)); break;
							
						// int - int
						case (Types.INTEGER * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.INTEGER:
							$_comment('int - int');
							value = buildInteger($_cast('int', left) - $_cast('int', right)); break;
							
						// int - float
						case (Types.INTEGER * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.FLOAT:
							$_comment('int - float');
							value = buildFloat($_cast('int', left) - $_cast('double', right)); break;
							
						// float - int
						case (Types.FLOAT * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.INTEGER:
							$_comment('float - int');
							value = buildFloat($_cast('double', left) - $_cast('int', right)); break;
							
						// float - float
						case (Types.FLOAT * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.FLOAT:
							$_comment('float - float');
							value = buildFloat($_cast('double', left) - $_cast('double', right)); break;

						// int * int
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('int * int');
							value = buildInteger($_cast('int', left) * $_cast('int', right)); break;

						// float * int
						case (Types.FLOAT * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('float * int');
							value = buildFloat($_cast('double', left) * $_cast('int', right)); break;

						// int * float
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.FLOAT:
							$_comment('int * float');
							value = buildFloat($_cast('int', left) * $_cast('double', right)); break;

						// float * float
						case (Types.FLOAT * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.FLOAT:
							$_comment('float * float');
							value = buildFloat($_cast('double', left) * $_cast('double', right)); break;
							
						// int / int
						case (Types.INTEGER * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.INTEGER:
							$_comment('int / int');
							if ($_cast('int', right) == 0) return killExecution(stack, "Division by 0");
							value = buildInteger($_unsafe_integer_division($_cast('int', left), $_cast('int', right))); break;
							
						// int / float
						case (Types.INTEGER * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.FLOAT:
							$_comment('int / float');
							if ($_cast('double', right) == 0) return killExecution(stack, "Division by 0");
							value = buildFloat($_unsafe_float_division($_cast('int', left), $_cast('double', right))); break;

						// float / int
						case (Types.FLOAT * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.INTEGER:
							$_comment('float / int');
							if ($_cast('int', right) == 0) return killExecution(stack, "Division by 0"); 
							value = buildFloat($_unsafe_float_division($_cast('double', left), $_cast('int', right))); break;

						// float / float
						case (Types.FLOAT * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.FLOAT:
							$_comment('float / float');
							if ($_cast('double', right) == 0) return killExecution(stack, "Division by 0"); 
							value = buildFloat($_unsafe_float_division($_cast('double', left), $_cast('double', right))); break;

						// int < int
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('int < int');
							if ($_cast('int', left) < $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// int <= int
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('int <= int');
							if ($_cast('int', left) <= $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;
							
						// float < int
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('float < int');
							if ($_cast('double', left) < $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float <= int
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('float <= int');
							if ($_cast('double', left) <= $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;
							
						// int < float
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('int < float');
							if ($_cast('int', left) < $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// int <= float
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('int <= float');
							if ($_cast('int', left) <= $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float < float
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('float < float');
							if ($_cast('double', left) < $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float <= float
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('float <= float');
							if ($_cast('double', left) <= $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// int >= int
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('int >= int');
							if ($_cast('int', left) >= $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// int > int
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('int > int');
							if ($_cast('int', left) > $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float >= int
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('float >= int');
							if ($_cast('double', left) >= $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float > int
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('float > int');
							if ($_cast('double', left) > $_cast('int', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// int >= float
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('int >= float');
							if ($_cast('int', left) >= $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// int > float
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('int > float');
							if ($_cast('int', left) > $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float >= float
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('float >= float');
							if ($_cast('double', left) >= $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// float > float
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('float > float');
							if ($_cast('double', left) > $_cast('double', right)) value = VALUE_TRUE; else value = VALUE_FALSE; break;

						// string * int
						case (Types.STRING * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('string * int');
							value = multiplyString(leftValue, $_cast('string', left), $_cast('int', right)); break;

						// int * string
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.STRING:
							$_comment('int * string');
							value = multiplyString(rightValue, $_cast('string', right), $_cast('int', left)); break;

						// list * int
						case (Types.LIST * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('list * int');
							// TODO: throw error if int is negative
							value = new Value(Types.LIST, $_multiply_list($_cast('List<Value>', left), $_cast('int', right)));
							break;
							
						// int * list
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.LIST:
							$_comment('int * list');
							value = new Value(Types.LIST, $_multiply_list($_cast('List<Value>', right), $_cast('int', left)));
							break;

						default:
							$_comment('unrecognized op');
							return killExecution(stack, "The '" + getBinaryOpFromId($_array_get(row, 0)) + "' operator is not supported for these types: " + getTypeFromId(Value$leftValue.type) + " and " + getTypeFromId(Value$rightValue.type));
							break;
					}
				}

				$_stack_push(valueStack, value);
				break;

			case OpCodes.BOOLEAN_NOT:
				$_comment('BOOLEAN_NOT');
				value = $_stack_pop(valueStack);
				if (Value$value.type != Types.BOOLEAN) return killExecution(stack, "Boolean expected.");
				if ($_cast('bool', Value$value.internalValue)) {
					$_stack_push(valueStack, VALUE_FALSE);
				} else {
					$_stack_push(valueStack, VALUE_TRUE);
				}
				break;

			case OpCodes.BUILD_SWITCH_INT:
				$_comment('BUILD_SWITCH_INT');
				@type('Dictionary<int, int>') integerSwitchLookup = $_new_dictionary('int', 'int');
				for (i = 0; i < $_array_length(row); i += 2) {
					$_dictionary_set(integerSwitchLookup, $_array_get(row, i), $_array_get(row, i + 1));
				}
				$_list_push(ProgramData$p.integerSwitchLookupsBuilder, integerSwitchLookup);
				break;

			case OpCodes.BUILD_SWITCH_STRING:
				$_comment('BUILD_SWITCH_STRING');
				@type('List<Dictionary<string, int>>') allStringSwitchLookups = ProgramData$p.stringSwitchLookupsBuilder;
				// int1 is id
				int1 = $_array_get(row, 0);
				while ($_list_length(allStringSwitchLookups) <= int1) {
					$_list_push(allStringSwitchLookups, $_new_dictionary('string', 'int'));
				}
				@type('Dictionary<string, int>') stringSwitchLookup = $_list_get(allStringSwitchLookups, int1);
				string1 = $_array_get(stringArgs, StackFrame$stack.pc);
				$_dictionary_set(stringSwitchLookup, string1, $_array_get(row, 1));
				break;

			case OpCodes.CALL_BASE_CONSTRUCTOR:
				$_comment('CALL_BASE_CONSTRUCTOR');
				classId = $_array_get($_array_get(specialCache, StackFrame$stack.pc), 0);
				classInfo = $_array_get(classTable, classId);
				value = StackFrame$stack.objectContext;
				
				// This is copied identically below in CALL_CONSTRUCTOR
				pc = ClassInfo$classInfo.constructorPc;
				argCount = $_array_get(row, 0);
				if (pc != 0) {
					if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
						funcArgs = $_new_array('Value', argCount);
						while (argCount > 0) {
							argCount -= 1;
							$_array_set(funcArgs, argCount, $_stack_pop(valueStack));
						}
					} else {
						funcArgs = $_new_list('Value');
						while (argCount > 0) {
							$_list_push(funcArgs, $_stack_pop(valueStack));
							argCount -= 1;
						}
						if ($_array_get(row, 0) > 1) {
							$_list_reverse_in_place(funcArgs);
						}
					}

					valueStack = $_new_stack('Value');
					locals = $_new_dictionary('int', 'Value');
					stack = new StackFrame(pc - 1, locals, valueStack, funcArgs, stack, false, value);
				} else {
					$_stack_push(valueStack, value);
				}
				break;

			case OpCodes.CALL_CONSTRUCTOR:
				$_comment('CALL_CONSTRUCTOR');
				classId = $_array_get($_array_get(specialCache, StackFrame$stack.pc), 0);
				ProgramData$p.instanceCounter += 1;
				value = new Value(Types.INSTANCE, new ObjectInstance(classId, $_new_dictionary('int', 'Value'), ProgramData$p.instanceCounter));
				classInfo = $_array_get(classTable, classId);
				if (!ClassInfo$classInfo.initialized) {
					return killExecution(stack, "This class has not been defined yet.");
				}
				pc = ClassInfo$classInfo.constructorPc;
				argCount = $_array_get(row, 0);
				if (pc != 0) {
					returnValueUsed = $_array_get(row, 2) == 1;
					if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
						funcArgs = $_new_array('Value', argCount);
						while (argCount > 0) {
							argCount -= 1;
							$_array_set(funcArgs, argCount, $_stack_pop(valueStack));
						}
					} else {
						funcArgs = $_new_list('Value');
						while (argCount > 0) {
							$_list_push(funcArgs, $_stack_pop(valueStack));
							argCount -= 1;
						}
						if ($_array_get(row, 0) > 1) {
							$_list_reverse_in_place(funcArgs);
						}
					}
					if (returnValueUsed) {
						$_stack_push(valueStack, value);
					}

					valueStack = $_new_stack('Value');
					locals = $_new_dictionary('int', 'Value');
					stack = new StackFrame(pc - 1, locals, valueStack, funcArgs, stack, false, value);
				} else {
					$_stack_push(valueStack, value);
				}
				break;

			case OpCodes.CALL_FRAMEWORK_FUNCTION:
				$_comment('CALL_FRAMEWORK_FUNCTION');
				// TODO: the types for these values must be verified.
				// The arg count is verified to be in the correct range at compile time.
				// However if there are optional arguments, the number of args used in this call are located in row[2]
				output = VALUE_NULL;
				switch ($_array_get(row, 0)) {
					case %%%FF_ABS%%%:
						$_comment('$abs');
						value = $_stack_pop(valueStack);
						if (Value$value.type == Types.INTEGER) {
							if ($_cast('int', Value$value.internalValue) < 0) {
								output = buildInteger(-$_cast('int', Value$value.internalValue));
							} else {
								output = value;
							}
						} else if (Value$value.type == Types.FLOAT) {
							if ($_cast('double', Value$value.internalValue) < 0) {
								output = buildFloat(-$_cast('double', Value$value.internalValue));
							} else {
								output = value;
							}
						} else {
							return killExecution(stack, "$abs requires a number as input.");
						}
						break;

					case %%%FF_ARCCOS%%%:
						$_comment('$arccos');
						// $arccos(theta)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							if (float1 < -1 || float1  > 1) {
								return killExecution(stack, "$arc_cos requires a number in the range of -1 to 1");
							}
							output = buildFloat($_arc_cos(float1));
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							if (int1 < -1 || int1 > 1) {
								return killExecution(stack, "$arc_cos requires a number in the range of -1 to 1");
							}
							output = buildFloat($_arc_cos(int1));
						} else {
							return killExecution(stack, "$arc_cos requires a number as input.");
						}
						break;

					case %%%FF_ARCSIN%%%:
						$_comment('$arcsin');
						// $arcsin(theta)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							if (float1 < -1 || float1  > 1) {
								return killExecution(stack, "$arc_sin requires a number in the range of -1 to 1");
							}
							output = buildFloat($_arc_sin(float1));
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							if (int1 < -1 || int1 > 1) {
								return killExecution(stack, "$arc_sin requires a number in the range of -1 to 1");
							}
							output = buildFloat($_arc_sin(int1));
						} else {
							return killExecution(stack, "$arc_sin requires a number as input.");
						}
						break;
						
					case %%%FF_ARCTAN%%%:
						$_comment('$arctan');
						// $arctan(theta)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							output = buildFloat($_arc_tan(float1, 1.0));
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							output = buildFloat($_arc_tan(int1, 1.0));
						} else {
							return killExecution(stack, "$arc_tan requires a number as input.");
						}
						break;

					case %%%FF_ARCTAN2%%%:
						$_comment('$arctan2');
						// $arctan2(y, x)
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							if (Value$arg2.type == Types.FLOAT) {
								float2 = $_cast('double', Value$arg2.internalValue);
								output = buildFloat($_arc_tan(float1, float2));
							} else if (Value$arg2.type == Types.INTEGER) {
								int2 = $_cast('int', Value$arg2.internalValue);
								output = buildFloat($_arc_tan(float1, int2));
							} else {
								return killExecution(stack, "$arctan2 requires 2 numeric arguments.");
							}
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							if (Value$arg2.type == Types.FLOAT) {
								float2 = $_cast('double', Value$arg2.internalValue);
								output = buildFloat($_arc_tan(int1, float2));
							} else if (Value$arg2.type == Types.INTEGER) {
								int2 = $_cast('int', Value$arg2.internalValue);
								output = buildFloat($_arc_tan(int1, int2));
							} else {
								return killExecution(stack, "$arctan2 requires 2 numeric arguments.");
							}
						} else {
							return killExecution(stack, "$arctan2 requires 2 numeric arguments.");
						}
						break;

					case %%%FF_ASSERT%%%:
						$_comment('$assert');
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.BOOLEAN) {
							return killExecution(stack, "Assertion expression must be a boolean.");
						}
						if (!$_cast('bool', Value$arg1.internalValue)) {
							return killExecution(stack, "Assertion failed: " + valueToString(arg2));
						}
						break;

					case %%%FF_CHR%%%:
						$_comment('$chr');
						arg1 = $_stack_pop(valueStack);
						output = null;
						if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							if (int1 >= 0 && int1 < 256) {
								output = buildCommonString($_chr(int1));
							}
						}
						if (output == null) {
							return killExecution(stack, "$chr requires an integer between 0 and 255");
						}
						break;

					case %%%FF_COS%%%:
						$_comment('$cos');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							output = buildFloat($_cos(float1));
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							output = buildFloat($_cos(int1));
						} else {
							return killExecution(stack, "$cos requires a number argument.");
						}
						break;

					case %%%FF_CURRENT_TIME%%%:
						output = buildFloat($_current_time_seconds());
						break;

					case %%%FF_FLOOR%%%:
						$_comment('$floor');
						// $floor(number)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							if (%%%INT_IS_FLOOR%%%) {
								output = buildInteger($_int(float1));
							} else {
								if (float1 < 0 && float1 % 1 != 0) {
									output = buildInteger($_int(float1) - 1);
								} else {
									output = buildInteger($_int(float1));
								}
							}
						} else if (Value$arg1.type == Types.INTEGER) {
							output = arg1;
						} else {
							return killExecution(stack, "$floor expects a numeric argument.");
						}
						break;

					case %%%FF_GAME_CLOCK_TICK%%%:
						$_comment('$game_clock_tick');

						if (ProgramData$p.initializationComplete) {
							performWorkNuggetPostFrame();
						}

						yieldControl(stack);
						return null;
						// this extra break is not a mistake. Python translation will get confused without the break here. Ultimately I plan to make this smart enough that it'll figure it out, but it's not a high priority.
						break;

					case %%%FF_GAME_INITIALIZE%%%:
						$_comment('$game_initialize_game');
						// $initialize_game(fps)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.INTEGER) {
							float1 = $_cast('int', Value$arg1.internalValue);
						} else if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
						} else {
							return killExecution(stack, "$initialize_game(fps) requiress a numeric argument.");
						}

						if (float1 <= 0) {
							return killExecution(stack, "fps must be a positive number.");
						}
						$_initialize_game_with_fps(float1);
						break;

					case %%%FF_GAME_INITIALIZE_SCREEN%%%:
						$_comment('$game_initialize_screen');
						// $initialize_screen(width, height)
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER) {
							return killExecution(stack, "$initialize_screen requires two integer arguments.");
						}

						int1 = $_cast('int', Value$arg1.internalValue);
						int2 = $_cast('int', Value$arg2.internalValue);
						if (int1 < 1 || int2 < 1) {
							return killExecution(stack, "Screen dimensions must be positive.");
						}

						if (%%%SCREEN_BLOCKS_EXECUTION%%%) {
							yieldControl(stack);
							$_initialize_screen(int1, int2, null, null);
							return '';
						} else {
							$_initialize_screen(int1, int2, null, null);
						}
						break;

					case %%%FF_GAME_INITIALIZE_SCREEN_SCALED%%%:
						$_comment('$game_initialize_screen_scaled');
						// $initialize_screen_scaled(gameWidth, gameHeight, pixelWidth, pixelHeight)
						arg4 = $_stack_pop(valueStack);
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER) {
							return killExecution(stack, "$initialize_screen_scaled requires four integer arguments.");
						}

						int1 = $_cast('int', Value$arg1.internalValue);
						int2 = $_cast('int', Value$arg2.internalValue);
						int3 = $_cast('int', Value$arg3.internalValue);
						int4 = $_cast('int', Value$arg4.internalValue);

						if (int1 < 1 || int2 < 1 || int3 < 1 || int4 < 1) {
							return killExecution(stack, "Screen dimensions must be positive.");
						}

						if (%%%SCREEN_BLOCKS_EXECUTION%%%) {
							yieldControl(stack);
							$_initialize_screen(int1, int2, int3, int4);
							return '';
						} else {
							$_initialize_screen(int1, int2, int3, int4);
						}
						break;

					case %%%FF_GAME_PUMP_EVENTS%%%:
						$_comment('$game_pump_events');
						list1 = $_get_events_raw_list();
						output = new Value(Types.LIST, list1);
						break;

					case %%%FF_GAME_SET_TITLE%%%:
						$_comment('$game_set_title');
						arg1 = $_stack_pop(valueStack);
						string1 = valueToString(arg1);
						$_set_title(string1);
						break;

					case %%%FF_GAMEPAD_BIND_ANALOG_AXIS%%%:
						$_comment('$gamepad_bind_analog_axis');
						arg2 = $_stack_pop(valueStack); // custom id
						arg1 = $_stack_pop(valueStack); // button item
						string1 = gamepadVerifyBindArgs(arg1, arg2);
						if (string1 != null) {
							return killExecution(stack, string1);
						}
						gamepadBindAnalogAxis(arg1, arg2);
						break;

					case %%%FF_GAMEPAD_BIND_BUTTON%%%:
						$_comment('$gamepad_bind_button');
						arg2 = $_stack_pop(valueStack); // custom id
						arg1 = $_stack_pop(valueStack); // button item
						break;

					case %%%FF_GAMEPAD_BIND_DIGITAL_AXIS%%%:
						$_comment('$gamepad_bind_digital_axis');
						arg2 = $_stack_pop(valueStack); // custom id
						arg1 = $_stack_pop(valueStack); // button item
						break;

					case %%%FF_GAMEPAD_DISABLE_DEVICE%%%:
						$_comment('$gamepad_disable_device');
						arg1 = $_stack_pop(valueStack); // device item
						break;

					case %%%FF_GAMEPAD_ENABLE_DEVICE%%%:
						$_comment('$gamepad_enable_device');
						arg1 = $_stack_pop(valueStack); // device item
						break;

					case %%%FF_GAMEPAD_GET_DEVICES%%%:
						$_comment('$gamepad_get_devices');
						output = buildListByWrappingInput(getGamepadDevices());
						break;

					case %%%FF_GAMEPAD_GET_PUSHED_BUTTONS%%%:
						$_comment('$gamepad_get_pushed_buttons');
						arg1 = null;
						break;

					case %%%FF_GFX_BLIT_IMAGE%%%:
						$_comment('$gfx_blit_image');
						// $blit_image(image, x, y)
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						image1 = extractImageFromValue(arg1);
						if (image1 == null) {
							return killExecution(stack, "$blit_image must consume an image as its first argument.");
						}
						if (Value$arg2.type != Types.INTEGER || Value$arg3.type != Types.INTEGER) {
							return killExecution(stack, "$gfx_blit_image coordinates must be integers.");
						}
						$_blit_image(image1, $_cast('int', Value$arg2.internalValue), $_cast('int', Value$arg3.internalValue));
						break;

					case %%%FF_GFX_BLIT_IMAGE_PARTIAL%%%:
						$_comment('$gfx_blit_image_partial');
						// $gfx_blit_image_partial(image, targetX, targetY, sourceX, sourceY, width, height)
						arg7 = $_stack_pop(valueStack);
						arg6 = $_stack_pop(valueStack);
						arg5 = $_stack_pop(valueStack);
						arg4 = $_stack_pop(valueStack);
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						image1 = extractImageFromValue(arg1);

						if (image1 == null ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg3.type != Types.INTEGER ||
							Value$arg4.type != Types.INTEGER ||
							Value$arg5.type != Types.INTEGER ||
							Value$arg6.type != Types.INTEGER ||
							Value$arg7.type != Types.INTEGER) {
							return killExecution(stack, "$gfx_blit_image_partial requires an image object and 6 integer arguments.");
						}
						$_blit_image_partial(
							image1,
							$_cast('int', Value$arg2.internalValue),
							$_cast('int', Value$arg3.internalValue),
							$_cast('int', Value$arg6.internalValue), // w
							$_cast('int', Value$arg7.internalValue), // h
							$_cast('int', Value$arg4.internalValue),
							$_cast('int', Value$arg5.internalValue),
							$_cast('int', Value$arg6.internalValue), // w
							$_cast('int', Value$arg7.internalValue)); // h
						break;

					case %%%FF_GFX_BLIT_IMAGE_PARTIAL_AT_SCALE%%%:
						$_comment('$gfx_blit_image_partial_at_scale');
						// $gfx_blit_image_partial_at_scale(image, targetX, targetY, targetWidth, targetHeight, sourceX, sourceY, sourceWidth, sourceHeight)
						arg9 = $_stack_pop(valueStack);
						arg8 = $_stack_pop(valueStack);
						arg7 = $_stack_pop(valueStack);
						arg6 = $_stack_pop(valueStack);
						arg5 = $_stack_pop(valueStack);
						arg4 = $_stack_pop(valueStack);
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						image1 = extractImageFromValue(arg1);
						
						if (image1 == null ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg3.type != Types.INTEGER ||
							Value$arg4.type != Types.INTEGER ||
							Value$arg5.type != Types.INTEGER ||
							Value$arg6.type != Types.INTEGER ||
							Value$arg7.type != Types.INTEGER ||
							Value$arg8.type != Types.INTEGER ||
							Value$arg9.type != Types.INTEGER) {
							return killExecution(stack, "$gfx_blit_image_partial_at_scale requires an image object and 8 integer arguments.");
						}
						$_blit_image_partial(
							image1,
							$_cast('int', Value$arg2.internalValue),
							$_cast('int', Value$arg3.internalValue),
							$_cast('int', Value$arg4.internalValue),
							$_cast('int', Value$arg5.internalValue),
							$_cast('int', Value$arg6.internalValue),
							$_cast('int', Value$arg7.internalValue),
							$_cast('int', Value$arg8.internalValue),
							$_cast('int', Value$arg9.internalValue));
						break;

					case %%%FF_GFX_DRAW_ELLIPSE%%%:
						$_comment('$gfx_draw_ellipse');
						// $gfx_draw_ellipse(left, top, width, height, red, green, blue, alpha)
						arg8 = $_stack_pop(valueStack);
						arg7 = $_stack_pop(valueStack);
						arg6 = $_stack_pop(valueStack);
						arg5 = $_stack_pop(valueStack);
						arg4 = $_stack_pop(valueStack);
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg3.type != Types.INTEGER ||
							Value$arg4.type != Types.INTEGER ||
							Value$arg5.type != Types.INTEGER ||
							Value$arg6.type != Types.INTEGER ||
							Value$arg7.type != Types.INTEGER ||
							Value$arg8.type != Types.INTEGER) {
							return killExecution(stack, "$draw_ellipse requires 8 integer arguments.");
						}
						$_draw_ellipse(
							$_cast('int', Value$arg1.internalValue),
							$_cast('int', Value$arg2.internalValue),
							$_cast('int', Value$arg3.internalValue),
							$_cast('int', Value$arg4.internalValue),
							$_cast('int', Value$arg5.internalValue),
							$_cast('int', Value$arg6.internalValue),
							$_cast('int', Value$arg7.internalValue),
							$_cast('int', Value$arg8.internalValue));
						break;

					case %%%FF_GFX_DRAW_LINE%%%:
						$_comment('$gfx_draw_line');
						// $draw_line(Ax, Ay, Bx, By, lineWidth, red, green, blue, alpha)
						arg9 = $_stack_pop(valueStack);
						arg8 = $_stack_pop(valueStack);
						arg7 = $_stack_pop(valueStack);
						arg6 = $_stack_pop(valueStack);
						arg5 = $_stack_pop(valueStack);
						arg4 = $_stack_pop(valueStack);
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						
						if (Value$arg1.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg3.type != Types.INTEGER ||
							Value$arg4.type != Types.INTEGER ||
							Value$arg5.type != Types.INTEGER ||
							Value$arg6.type != Types.INTEGER ||
							Value$arg7.type != Types.INTEGER ||
							Value$arg8.type != Types.INTEGER ||
							Value$arg9.type != Types.INTEGER) {
							return killExecution(stack, "$draw_line requires 9 integer arguments.");
						}

						$_draw_line(
							$_cast('int', Value$arg1.internalValue),
							$_cast('int', Value$arg2.internalValue),
							$_cast('int', Value$arg3.internalValue),
							$_cast('int', Value$arg4.internalValue),
							$_cast('int', Value$arg5.internalValue),
							$_cast('int', Value$arg6.internalValue),
							$_cast('int', Value$arg7.internalValue),
							$_cast('int', Value$arg8.internalValue),
							$_cast('int', Value$arg9.internalValue));
						break;

					case %%%FF_GFX_DRAW_RECTANGLE%%%:
						$_comment('$gfx_draw_rectangle');
						// $draw_rectangle(x, y, width, height, red, green, blue, alpha)
						arg8 = $_stack_pop(valueStack);
						arg7 = $_stack_pop(valueStack);
						arg6 = $_stack_pop(valueStack);
						arg5 = $_stack_pop(valueStack);
						arg4 = $_stack_pop(valueStack);
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg3.type != Types.INTEGER ||
							Value$arg4.type != Types.INTEGER ||
							Value$arg5.type != Types.INTEGER ||
							Value$arg6.type != Types.INTEGER ||
							Value$arg7.type != Types.INTEGER ||
							Value$arg8.type != Types.INTEGER) {
							return killExecution(stack, "$draw_rectangle requires 8 integer arguments.");
						}
						$_draw_rectangle(
							$_cast('int', Value$arg1.internalValue),
							$_cast('int', Value$arg2.internalValue),
							$_cast('int', Value$arg3.internalValue),
							$_cast('int', Value$arg4.internalValue),
							$_cast('int', Value$arg5.internalValue),
							$_cast('int', Value$arg6.internalValue),
							$_cast('int', Value$arg7.internalValue),
							$_cast('int', Value$arg8.internalValue));
						break;

					case %%%FF_GFX_FILL_SCREEN%%%:
						$_comment('$gfx_fill_screen');
						// $fill_screen(red, green, blue)
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.INTEGER ||
							Value$arg2.type != Types.INTEGER ||
							Value$arg3.type != Types.INTEGER) {
							return killExecution(stack, "$fill_screen requires 3 integer arguments.");
						}
						$_fill_screen($_cast('int', Value$arg1.internalValue), $_cast('int', Value$arg2.internalValue), $_cast('int', Value$arg3.internalValue));
						break;

					case %%%FF_GFX_FLIP_IMAGE%%%:
						$_comment('$gfx_flip_image');
						// $flip_image(image, shouldFlipX, shouldFlipY)
						arg3 = $_stack_pop(valueStack);
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						image1 = extractImageFromValue(arg1);
						if (image1 == null) {
							return killExecution(stack, "$flip_image requires an image as its first argument.");
						}
						if (Value$arg2.type != Types.BOOLEAN || Value$arg3.type != Types.BOOLEAN) {
							return killExecution(stack, "$flip_image requires an image and two booleans.");
						}
						output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.IMAGE, flipImage(
							image1,
							$_cast('bool', Value$arg2.internalValue),
							$_cast('bool', Value$arg3.internalValue))));
						break;

					case %%%FF_GFX_IMAGE_ERROR_CODE%%%:
						$_comment('$gfx_image_error_code');
						// $image_error_code(image_key)
						// Error codes:
						// 0 - none (success or pending)
						// 1 - file not found
						// 2 - timed out
						// 3 - invalid format
						// 4 - too big
						// 5 - sprite sheet image not initialized
						// 99 - unknown
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$image_error_code requires a string argument.");
						}
						string1 = $_cast('string', Value$arg1.internalValue);
						int1 = getImageErrorCode(string1);
						output = buildInteger(int1);
						break;

					case %%%FF_GFX_IMAGE_GET%%%:
						$_comment('$gfx_image_get');
						// $image_get(image_key)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$image_get requires a string argument.");
						}
						string1 = $_cast('string', Value$arg1.internalValue);
						object1 = getImageByKey(string1);
						if (object1 == null) {
							return killExecution(stack, "No image with the key '" + string1 + "' has been loaded.");
						}
						output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.IMAGE, object1));
						break;

					case %%%FF_GFX_IMAGE_LOAD_FROM_RESOURCE%%%:
						$_comment('$gfx_image_load_from_resource');
						// $image_load_from_resource(key, path)
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
							return killExecution(stack, "$image_load_from_resource requires two string arguments.");
						}
						string1 = $_cast('string', Value$arg2.internalValue);
						int1 = loadImageFromLocalResources($_cast('string', Value$arg1.internalValue), string1);
						if (int1 != 1) {
							if (int1 == 0) {
								return killExecution(stack, "Image resource does not exist: " + string1);
							} else if (int1 == 2) {
								return killExecution(stack, "Image resource was loaded, but it was accessed from an image sheet that was not checked for load completion. Use $gfx_image_sheet_loaded on all image sheets before accessing files from them.");
							}
						}
						break;

					case %%%FF_GFX_IMAGE_LOAD_FROM_WEB%%%:
						$_comment('$gfx_image_load_from_web');
						// $image_load_from_web(key, url)
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
							return killExecution(stack, "$image_load_from_web requires two string arguments.");
						}
						string1 = $_cast('string', Value$arg2.internalValue);
						$_download_image($_cast('string', Value$arg1.internalValue), string1);
						break;

					case %%%FF_GFX_IMAGE_LOAD_FROM_USER_DATA%%%:
						$_comment('$gfx_image_load_from_user_data');
						// $image_load_from_user_data(key, path)
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
							return killExecution(stack, "$image_load_from_user_data requires two string arguments.");
						}
						loadImageFromUserData($_cast('string', Value$arg1.internalValue), $_cast('string', Value$arg2.internalValue));
						break;

					case %%%FF_GFX_IMAGE_POP_SCALE%%%:
						$_comment('$gfx_image_pop_scale');
						// $image_pop_scale()
						intList1 = ProgramData$p.imageScaleStack;
						int1 = $_list_length(intList1);
						if (int1 == 0) {
							return killExecution(stack, "$image_pop_scale() was called but the image scale stack was empty.");
						}
						int2 = $_list_get(intList1, int1 - 1);
						$_list_pop(intList1);
						output = buildInteger(int2);
						if (int1 == 1) {
							int3 = 1;
						} else {
							int3 = $_list_get(intList1, int1 - 2);
						}
						ProgramData$p.imageScaleStackTop = int3;
						break;

					case %%%FF_GFX_IMAGE_PUSH_SCALE%%%:
						$_comment('$gfx_image_push_scale');
						// $image_push_scale(scale)
						intList1 = ProgramData$p.imageScaleStack;
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.INTEGER) {
							if (Value$arg1.type != Types.FLOAT) {
								return killExecution(stack, "$image_push_scale must be called with an integer. Floats are not supported at this time.");
							}
							return killExecution(stack, "$image_push_scale must be called with an integer.");
						}
						int1 = $_cast('int', Value$arg1.internalValue);
						$_list_push(intList1, int1);
						ProgramData$p.imageScaleStackTop = int1;
						break;

					case %%%FF_GFX_IMAGE_SHEET_ERROR_CODE%%%:
						$_comment('$gfx_image_sheet_error_code');
						// $image_sheet_error_code(idOrIds)
						// Error codes: same as $image_error_code
						arg1 = $_stack_pop(valueStack);
						stringList = toStringList(arg1, stringList);
						if (stringList == null) {
							return killExecution(stack, "$image_sheet_error_code argument must either be a string or a list of strings.");
						}
						
						int1 = 0;
						// take the first non-zero entry you find.
						for (i = 0; i < $_array_length(stringList); i += 1) {
							int2 = getSheetErrorCode($_array_get(stringList, i));
							if (int2 > 0) {
								int1 = int2;
								i = $_array_length(stringList);
							}
						}

						output = buildInteger(int1);
						break;

					case %%%FF_GFX_IMAGE_SHEET_LOAD%%%:
						$_comment('$gfx_image_sheet_load');
						// $image_sheet_load(idOrIds)
						arg1 = $_stack_pop(valueStack);
						stringList = toStringList(arg1, stringList);
						if (stringList == null) {
							return killExecution(stack, "$image_sheet_load argument must either be a string or a list of strings.");
						}

						for (i = 0; i < $_array_length(stringList); i += 1) {
							string1 = $_array_get(stringList, i);
							bool1 = loadImageSheet(string1);
							if (!bool1) {
								return killExecution(stack, "'" + string1 + "' was not declared as an image sheet.");
							}
						}
						break;

					case %%%FF_GFX_IMAGE_SHEET_LOAD_PROGRESS%%%:
						$_comment('$gfx_image_sheet_load_progress');
						// $image_sheet_load_progres(idOrIds)
						arg1 = $_stack_pop(valueStack);
						stringList = toStringList(arg1, stringList);
						if (stringList == null) {
							return killExecution(stack, "$image_sheet_load_progress argument must either be a string or a list of strings.");
						}

						int1 = 0; // files loaded
						int2 = 0; // total files to load

						for (i = 0; i < $_array_length(stringList); i += 1) {
							string1 = $_array_get(stringList, i);
							if (getSheetErrorCode(string1) > 0) {
								int2 = 0; // this function should return 1.0
								i += $_array_length(stringList);
							} else {
								int3 = getNumTilesLoaded(string1);
								if (int3 == -1) {
									return killExecution(stack, "'" + string1 + "' is not a valid image sheet.");
								}
								int1 += int3;
								int2 += getNumTiles(string1);
							}
						}

						if (int2 == 0) {
							output = VALUE_FLOAT_ONE;
						} else {
							output = buildFloat($_unsafe_float_division(1.0 * int1, int2));
						}
						break;

					case %%%FF_GFX_IMAGE_SHEET_LOADED%%%:
						$_comment('$gfx_image_sheet_loaded');
						// $image_sheet_loaded(idOrIds)
						arg1 = $_stack_pop(valueStack);
						bool1 = false; // type error encountered
						int1 = 1; // 0 - not done, 1 - success, 2 - failure, this variable is a BIT MASK
						if (Value$arg1.type == Types.LIST) {
							for (i = 0; i < $_list_length(list1); i += 1) {
								value = $_list_get(list1, i);
								if (Value$value.type != Types.STRING) {
									bool1 = true;
									i = $_list_length(list1);
								} else {
									int2 = isImageSheetLoaded($_cast('string', Value$value.internalValue));
									if (int2 == 2) {
										return killExecution(stack, "$gfx_image_sheet_loaded cannot be called on sheet ID's that have not been loaded yet.");
									}

									int1 &= int2;
								}
							}
						} else if (Value$arg1.type == Types.STRING) {
							int1 = isImageSheetLoaded($_cast('string', Value$arg1.internalValue));
						} else {
							bool1 = true;
						}

						if (bool1) {
							return killExecution(stack, "$image_sheet_load arguments must either be a string or a list of strings.");
						}

						if (int1 == 0) {
							output = VALUE_FALSE;
						} else if (int1 == 1) {
							output = VALUE_TRUE;
						} else { // int1 == 2 || int1 == 3
							return killExecution(stack, "$gfx_image_sheet_loaded cannot be called on sheet ID's that have not been loaded yet.");
						}
						break;

					case %%%FF_GFX_IS_IMAGE_LOADED%%%:
						$_comment('$gfx_is_image_loaded');
						// $image_loaded(image_key)
						arg1 = $_stack_pop(valueStack);
						int1 = isImageLoaded($_cast('string', Value$arg1.internalValue));
						if (int1 == 0) {
							return killExecution(stack, "$gfx_is_image_loaded cannot be called on keys where loading has not been initialized.");
						} else if (int1 == 1) {
							output = VALUE_TRUE;
						} else { // int1 == 2
							output = VALUE_FALSE;
						}
						break;

					case %%%FF_HTTP_REQUEST%%%:
						$_comment('$http_request');
						arg4 = $_stack_pop(valueStack); // body
						arg3 = $_stack_pop(valueStack); // http headers
						arg2 = $_stack_pop(valueStack); // URL
						arg1 = $_stack_pop(valueStack); // Method
						bool1 = true;
						if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
							bool1 = false;
						} else if (Value$arg3.type != Types.DICTIONARY && Value$arg3.type != Types.NULL) {
							bool1 = false;
						} else if (Value$arg4.type != Types.STRING && Value$arg4.type != Types.NULL) {
							bool1 = false;
						}

						if (Value$arg3.type == Types.DICTIONARY) {
							// TODO: iterate through dictionary and verify string contents
							return killExecution(stack, "Setting HTTP headers is not supported yet.");
						}
						if (!bool1) {
							return killExecution(stack, "Invalid arguments. $http_request's arguments require 2 strings, a dictionary, and a string.");
						}
						string1 = $_cast('string', Value$arg1.internalValue); // method
						string2 = $_cast('string', Value$arg2.internalValue); // url
						string3 = $_cast('string', Value$arg4.internalValue); // body

						output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.HTTP_REQUEST, makeHttpRequest(string1, string2, string3, null)));
						break;

					case %%%FF_IO_CURRENT_DIRECTORY%%%:
						$_comment('$io_current_directory');
						output = buildString($_io_current_directory());
						break;

					case %%%FF_IO_DIRECTORY_LISTING%%%:
						$_comment('$io_directory_list');
						// $io_directory_list(path)
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$io_directory_list requires a string argument.");
						}
						output = ioDirectoryList($_cast('string', Value$arg1.internalValue));
						if (Value$output.type == Types.STRING) {
							return killExecution(stack, $_cast('string', Value$output.internalValue));
						}
						break;

					case %%%FF_IO_FILE_READ_TEXT%%%:
						$_comment('$io_file_read_text');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$io_file_read_text requires 1 string argument.");
						}
						string1 = $_cast('string', Value$arg1.internalValue); // path
						string2 = ioCheckPathStatus(string1, false, false); // canonicalize the file path if it exists.
						if (string2 == null) {
							return killExecution(stack, "$io_file_read_text failed: File does not exist.");
						}
						string1 = $_io_file_read_text(string2);
						if (string1 == null) {
							return killExecution(stack, "$io_file_read_text failed: unable to read file.");
						}
						output = buildString(string1);
						break;

					case %%%FF_IO_FILE_WRITE_TEXT%%%:
						$_comment('$io_file_write_text');
						arg2 = $_stack_pop(valueStack);
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
							return killExecution(stack, "$io_file_write_text requires 2 string arguments.");
						}
						string1 = $_cast('string', Value$arg1.internalValue); // path
						string2 = $_cast('string', Value$arg2.internalValue); // contents
						string3 = ioCheckPathStatus(string1, true, true); // canonicalize the parent folder if it exists
						if (string3 == null) {
							return killExecution(stack, "Invalid path. Parent directory does not exist.");
						}
						string3 = canonicalizePath(string1, false); // parent exists. now canonicalize the full path.
						int1 = $_io_file_write_text(string3, string2); // int1 is error code
						if (int1 != 0) {
							string1 = "$io_file_write_text failed: ";
							if (int1 == 1) string1 += " Disk is readonly.";
							if (int1 == 2) string1 += " Path is too long.";
							if (int1 == 3) string1 += " IO error.";
							if (int1 == 4) string1 += " Unknown error.";
						}
						break;

					case %%%FF_IO_IS_PATH_DIRECTORY%%%:
						$_comment('$io_is_path_directory');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$io_is_path_directory requires a string argument.");
						}
						string1 = ioIsPathDirectory($_cast('string', Value$arg1.internalValue));
						if (string1 == null) {
							output = VALUE_FALSE;
						} else {
							output = VALUE_TRUE;
						}
						break;

					case %%%FF_IO_PATH_EXISTS%%%:
						$_comment('$io_path_exists');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$io_path_exists requires a string argument.");
						}
						string1 = ioDoesPathExist($_cast('string', Value$arg1.internalValue));
						if (string1 == null) {
							output = VALUE_FALSE;
						} else {
							output = VALUE_TRUE;
						}
						break;

					case %%%FF_IO_PATH_JOIN%%%:
						$_comment('$io_path_join');
						arg1 = $_stack_pop(valueStack);
						bool1 = true;
						list1 = null;
						// generally the number of string components in a path join command are < 5
						// and most commonly just 2. Just iteratively concatenate a string for conciseness.
						// It's okay.
						string1 = ""; 
						// TODO: accept a variable number of string args.
						if (Value$arg1.type != Types.LIST) {
							bool1 = false;
						} else {
							list1 = $_cast('List<Value>', Value$arg1.internalValue);
							string2 = "/";
							if ($_is_windows_program()) {
								string2 = "\\";
							}
							for (i = 0; i < $_list_length(list1); i += 1) {
								value = $_list_get(list1, i);
								if (Value$value.type != Types.STRING) {
									bool1 = false;
									/* break; */ i = $_list_length(list1); // break isn't supported in translate mode.
								} else {
									if (i == 0) {
										string1 += $_cast('string', Value$value.internalValue);
									} else {
										string1 += string2 + $_cast('string', Value$value.internalValue);
									}
								}
							}
						}
						if (!bool1) {
							return killExecution(stack, "$io_path_join requires a list of strings as input.");
						}
						output = buildString(string1);
						break;

					case %%%FF_ORD%%%:
						$_comment('$ord');
						arg1 = $_stack_pop(valueStack);
						output = null;
						if (Value$arg1.type == Types.STRING) {
							string1 = $_cast('string', Value$arg1.internalValue);
							if ($_string_length(string1) == 1) {
								output = buildInteger($_ord(string1));
							}
						}
						if (output == null) {
							return killExecution(stack, "$ord requires a 1 character string.");
						}
						break;

					case %%%FF_PARSE_FLOAT%%%:
						$_comment('$parse_float');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$parse_float requires a string argument.");
						}
						string1 = $_string_trim($_force_parens($_cast('string', Value$arg1.internalValue)));
						$_parse_float(floatList1, string1);
						if ($_array_get(floatList1, 0) < 0) {
							output = VALUE_NULL;
						} else {
							output = buildFloat($_array_get(floatList1, 1));
						}
						break;

					case %%%FF_PARSE_INT%%%:
						$_comment('$parse_int');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$parse_int requires a string argument.");
						}
						string1 = $_string_trim($_force_parens($_cast('string', Value$arg1.internalValue)));
						if ($_is_valid_integer(string1)) {
							output = buildInteger($_parse_int(string1));
						} else {
							output = VALUE_NULL;
						}
						break;

					case %%%FF_PARSE_JSON%%%:
						$_comment('$parse_json');
						// TODO: when you add ability to add optional arguments, add a boolean for failing silently.
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$parse_json requires a string argument.");
						}
						output = $_parse_json($_cast('string', Value$arg1.internalValue));
						if (output == null) {
							return killExecution(stack, "Attempted to parse an invalid JSON string.");
						}
						break;

					case %%%FF_PRINT%%%:
						$_comment('$print');
						arg1 = $_stack_pop(valueStack);
						string1 = valueToString(arg1);
						$_print(string1);
						break;

					case %%%FF_RANDOM%%%:
						$_comment('$random');
						output = buildFloat($_random_float());
						break;

					case %%%FF_RESOURCE_READ_TEXT%%%:
						$_comment('$resource_read_text');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$resource_read_text requires a string path parameter.");
						}
						string1 = $_cast('string', Value$arg1.internalValue);
						// TODO: verify string1 is a well-formed path without '..'
						string2 = $_resource_read_text_file(string1);
						if (string2 == null) {
							return killExecution(stack, "Resource file not found: '" + string1 + "'");
						}
						output = new Value(Types.STRING, string2);
						break;

					case %%%FF_SFX_GET_SOUND%%%:
						$_comment('$sfx_get_sound');
						arg1 = $_stack_pop(valueStack); // key
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$sfx_get_sound requires a string argument.");
						}
						string1 = $_cast('string', Value$arg1.internalValue);
						sound1 = getLoadedSound(string1);
						if (sound1 == null) {
							return killExecution(stack, "No sound has been loaded with the key: '" + string1 + "'.");
						}
						output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.SOUND, sound1));
						break;

					case %%%FF_SFX_IS_SOUND_LOADED%%%:
						$_comment('$sfx_is_sound_loaded');
						arg1 = $_stack_pop(valueStack); // key
						if (Value$arg1.type != Types.STRING) {
							return killExecution(stack, "$sfx_is_sound_loaded requires a string argument.");
						}
						string1 = $_cast('string', Value$arg1.internalValue);
						int1 = isSoundLoaded(string1);
						if (int1 == 2) {
							output = VALUE_TRUE;
						} else if (int1 == 0) {
							output = VALUE_FALSE;
						} else if (int1 == 1) {
							return killExecution(stack, "$sfx_is_sound_loaded cannot be called on a key that hasn't been initialized.");
						}
						break;

					case %%%FF_SFX_LOAD_SOUND_FROM_RESOURCE%%%:
						$_comment('$sfx_load_sound_from_resource');
						arg2 = $_stack_pop(valueStack); // path
						arg1 = $_stack_pop(valueStack); // key
						if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
							return killExecution(stack, "$sfx_load_sound_from_resource requires two string parameters.");
						}
						string1 = $_cast('string', Value$arg1.internalValue);
						string2 = $_cast('string', Value$arg2.internalValue);
						bool1 = loadSoundFromResource(string1, string2); // file exists
						if (!bool1) {
							return killExecution(stack, "The file '" + string2 + "' does not exist in the resources.");
						}
						break;

					case %%%FF_SFX_PLAY_SOUND%%%:
						$_comment('$sfx_play_sound');
						arg1 = $_stack_pop(valueStack); // native sound object.
						sound1 = null;
						if (Value$arg1.type == Types.NATIVE_OBJECT) {
							nativeObject = $_cast('NativeObjectWrapper', Value$arg1.internalValue);
							if (NativeObjectWrapper$nativeObject.subType == NativeObjectSubType.SOUND) {
								sound1 = $_cast('SoundInstance', NativeObjectWrapper$nativeObject.value);
							}
						}

						if (sound1 == null) {
							return killExecution(stack, "$sfx_play_sound requires a sound instance as its argument.");
						}

						playSound(sound1);
						break;

					case %%%FF_SIN%%%:
						$_comment('$sin');
						arg1 = $_stack_pop(valueStack);
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							output = buildFloat($_sin(float1));
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							output = buildFloat($_sin(int1));
						} else {
							return killExecution(stack, "$sin requires a number argument.");
						}
						break;

					case %%%FF_TAN%%%:
						$_comment('$tan');
						arg1 = $_stack_pop(valueStack);
						// I do not check for arg1 == pi/2 because the float arithmetic
						// never produces a true pi/2. The closest a 64 bit floating point number can get
						// to pi/2 produces 16331239353195370. 
						if (Value$arg1.type == Types.FLOAT) {
							float1 = $_cast('double', Value$arg1.internalValue);
							output = buildFloat($_tan(float1));
						} else if (Value$arg1.type == Types.INTEGER) {
							int1 = $_cast('int', Value$arg1.internalValue);
							output = buildFloat($_tan(int1));
						} else {
							return killExecution(stack, "$tan requires a number argument.");
						}
						break;

					case %%%FF_TYPEOF%%%:
						$_comment('$typeof');
						arg1 = $_stack_pop(valueStack);

						switch (Value$arg1.type) {
							case Types.NULL: string1 = "null"; break;
							case Types.INTEGER: string1 = "integer"; break;
							case Types.FLOAT: string1 = "float"; break;
							case Types.STRING: string1 = "string"; break;
							case Types.LIST: string1 = "list"; break;
							case Types.DICTIONARY: string1 = "dictionary"; break;
							case Types.INSTANCE: string1 = "instance"; break;
							case Types.FUNCTION: string1 = "function"; break;
							case Types.METHOD: string1 = "method"; break;
							case Types.SYS_METHOD: string1 = "primitive_method"; break;
							case Types.NATIVE_OBJECT: string1 = "native_system_object"; break;
							default: string1 = "unknown_type"; break;
						}
						output = buildCommonString(string1);
						break;

					default:
						return killExecution(stack, "Invalid framework function: " + $_string_cast_weak($_array_get(row, 0))); 
						break;
				}
				if ($_array_get(row, 1) == 1) {
					$_stack_push(valueStack, output);
				}
				break;

			case OpCodes.CALL_FUNCTION:
				$_comment('CALL_FUNCTION');
				// This is mostly replicated below. Be sure to keep changes in sync.
				func = $_stack_pop(valueStack);
				argCount = $_array_get(row, 0);
				returnValueUsed = $_array_get(row, 1) == 1;
				if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
					funcArgs = $_new_array('Value', argCount);
					while (argCount > 0) {
						argCount -= 1;
						$_array_set(funcArgs, argCount, $_stack_pop(valueStack));
					}
				} else {
					funcArgs = $_new_list('Value');
					while (argCount > 0) {
						$_list_push(funcArgs, $_stack_pop(valueStack));
						argCount -= 1;
					}
					if ($_array_get(row, 0) > 1) {
						$_list_reverse_in_place(funcArgs);
					}
				}
				type = Value$func.type;
				if (type == Types.SYS_METHOD) {
					sysMethod = $_cast('SystemMethod', Value$func.internalValue);
					error = callSystemMethod(
						SystemMethod$sysMethod.id, 
						SystemMethod$sysMethod.context, 
						funcArgs, 
						valueStack, 
						returnValueUsed);
					if (error != null) {
						return killExecution(stack, error);
					}
				} else if (type == Types.METHOD) {
					methodInstance = $_cast('MethodInstance', Value$func.internalValue);
					if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
						if (MethodInstance$methodInstance.maxArgs < $_array_length(funcArgs)) {
							return killExecution(stack, "Too many args were passed in.");
						}
					} else {
						if (MethodInstance$methodInstance.maxArgs < $_list_length(funcArgs)) {
							return killExecution(stack, "Too many args were passed in.");
						}
					}
					valueStack = $_new_stack('Value');
					locals = $_new_dictionary('int', 'Value');
					stack = new StackFrame(
						MethodInstance$methodInstance.pc - 1,
						locals,
						valueStack,
						funcArgs,
						stack,
						returnValueUsed,
						MethodInstance$methodInstance.context);
				} else if (type == Types.FUNCTION) {
					valueStack = $_new_stack('Value');
					locals = $_new_dictionary('int', 'Value');
					funcDef = $_cast('FunctionDefinition', Value$func.internalValue);
					stack = new StackFrame(FunctionDefinition$funcDef.pc, locals, valueStack, funcArgs, stack, returnValueUsed, null);
				} else {
					return killExecution(stack, "Cannot invoke " + getTypeFromId(type) + " like a function.");
				}
				break;

			case OpCodes.CALL_FUNCTION_ON_VARIABLE:
				$_comment('CALL_FUNCTION_ON_VARIABLE');
				// This is mostly replicated above. Be sure to keep changes in sync.
				argCount = $_array_get(row, 1);
				returnValueUsed = $_array_get(row, 2) == 1;
				if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
					funcArgs = $_new_array('Value', argCount);
					while (argCount > 0) {
						argCount -= 1;
						$_array_set(funcArgs, argCount, $_stack_pop(valueStack));
					}
				} else {
					funcArgs = $_new_list('Value');
					while (argCount > 0) {
						$_list_push(funcArgs, $_stack_pop(valueStack));
						argCount -= 1;
					}
					if ($_array_get(row, 1) > 1) {
						$_list_reverse_in_place(funcArgs);
					}
				}

				int1 = $_array_get(row, 0);
				if ($_dictionary_contains(locals, int1)) {
					func = $_dictionary_get_guaranteed(locals, int1);
				} else if ($_dictionary_contains(globals, int1)) {
					func = $_dictionary_get_guaranteed(globals, int1);
				} else {
					func = null;
				}

				if (func != null) {
					type = Value$func.type;
					if (type == Types.FUNCTION) {
						valueStack = $_new_stack('Value');
						locals = $_new_dictionary('int', 'Value');
						funcDef = $_cast('FunctionDefinition', Value$func.internalValue);
						if (argCount > FunctionDefinition$funcDef.maxArgCount) {
							return killExecution(stack, "Too many args passed to " + FunctionDefinition$funcDef.name);
						}
						stack = new StackFrame(FunctionDefinition$funcDef.pc, locals, valueStack, funcArgs, stack, returnValueUsed, null);
					} else if (type == Types.METHOD) {
						methodInstance = $_cast('MethodInstance', Value$func.internalValue);
						if (%%%USE_FIXED_LENGTH_ARG_CONSTRUCTION%%%) {
							if (MethodInstance$methodInstance.maxArgs < $_array_length(funcArgs)) {
								return killExecution(stack, "Too many args were passed in.");
							}
						} else {
							if (MethodInstance$methodInstance.maxArgs < $_list_length(funcArgs)) {
								return killExecution(stack, "Too many args were passed in.");
							}
						}
						valueStack = $_new_stack('Value');
						locals = $_new_dictionary('int', 'Value');
						stack = new StackFrame(
							MethodInstance$methodInstance.pc - 1,
							locals,
							valueStack,
							funcArgs,
							stack,
							returnValueUsed,
							MethodInstance$methodInstance.context);
					} else {
						return killExecution(stack, "Cannot invoke " + getTypeFromId(type) + " types like a function.");
					}
				} else {
					return killExecution(stack, "That function is not defined: '" + $_array_get(identifiers, $_array_get(row, 0)) + "'");
				}
				break;

			case OpCodes.CLASS_DEFINITION:
				$_comment('CLASS_DEFINITION');
				classId = $_array_get($_array_get(specialCache, StackFrame$stack.pc), 0);
				classInfo = $_array_get(classTable, classId);
				ClassInfo$classInfo.initialized = true;
				break;

			case OpCodes.DEF_DICTIONARY:
				$_comment('DEF_DICT');
				dictIntKeyLookup = $_new_dictionary('int', 'Value');
				dictIntValueLookup = $_new_dictionary('int', 'Value');
				dictStringKeyLookup = $_new_dictionary('string', 'Value');
				dictStringValueLookup = $_new_dictionary('string', 'Value');
				len = $_array_get(row, 0);
				type = Types.INTEGER; // always ignored when size is 0
				first = true;
				i = len; // size
				while (i > 0) {
					value = $_stack_pop(valueStack); // value
					value2 = $_stack_pop(valueStack); // key
					if (first) {
						type = Value$value2.type;
						first = false;
					} else if (type != Value$value2.type) {
						return killExecution(stack, "Cannot have multiple key types in one dictionary.");
					}

					if (type == Types.INTEGER) {
						intKey = $_cast('int', Value$value2.internalValue);
					} else if (type == Types.STRING) {
						stringKey = $_cast('string', Value$value2.internalValue);
					} else if (type == Types.INSTANCE) {
						objInstance = $_cast('ObjectInstance', Value$value2.internalValue);
						intKey = ObjectInstance$objInstance.objectId;
					} else {
						return killExecution(stack, "Only integers, strings, and objects can be used as dictionary keys.");
					}

					if (type == Types.STRING) {
						$_dictionary_set(dictStringKeyLookup, stringKey, value2);
						$_dictionary_set(dictStringValueLookup, stringKey, value);
					} else {
						$_dictionary_set(dictIntKeyLookup, intKey, value2);
						$_dictionary_set(dictIntValueLookup, intKey, value);
					}
					i -= 1;
				}

				if (type == Types.STRING) {
					if ($_dictionary_size(dictStringKeyLookup) != len) {
						return killExecution(stack, "Key collision"); // TODO: do a better job of figuring out where this collision is.
					}
				} else {
					if ($_dictionary_size(dictIntKeyLookup) != len) {
						return killExecution(stack, "Key collision"); // TODO: do a better job of figuring out where this collision is.
					}
				}

				value = new Value(Types.DICTIONARY, new DictImpl(
					dictIntKeyLookup,
					dictIntValueLookup,
					dictStringKeyLookup,
					dictStringValueLookup,
					len,
					type));

				$_stack_push(valueStack, value);
				break;

			case OpCodes.DEF_LIST:
				$_comment('DEF_LIST');
				list1 = $_new_list('Value');
				int1 = $_array_get(row, 0);
				while (int1 > 0) {
					$_list_push(list1, $_stack_pop(valueStack));
					int1 -= 1;
				}
				$_list_reverse_in_place(list1);
				$_stack_push(valueStack, new Value(Types.LIST, list1));
				break;

			case OpCodes.DEF_ORIGINAL_CODE:
				int1 = $_array_get(row, 0); // file ID
				string1 = $_array_get(ProgramData$p.stringArgs, StackFrame$stack.pc); // file contents
				@type('List<string>') codeLookup = ProgramData$p.sourceCodeBuilder;
				while ($_list_length(codeLookup) <= int1) {
					$_list_push(codeLookup, null);
				}
				$_list_set(codeLookup, int1, string1);
				break;

			case OpCodes.DEREF_DOT:
				$_comment('DEREF_DOT');
				// TODO: no caching of methods occur here because ideally, I want to create another op for dotStepInvoke which eliminates the need to instantiate the method in 99.5% of cases.
				root = $_stack_pop(valueStack);
				type = Value$root.type;
				nameId = $_array_get(row, 0);
				if (type == Types.INSTANCE) {
					objInstance = $_cast('ObjectInstance', Value$root.internalValue);
					dictIntValueLookup = $_cast('Dictionary<int, Value>', ObjectInstance$objInstance.fields);
					if ($_dictionary_contains(dictIntValueLookup, nameId)) {
						$_stack_push(valueStack, $_dictionary_get_guaranteed(dictIntValueLookup, nameId));
					} else {
						classId = ObjectInstance$objInstance.classId;
						methodDefinitionLookup = $_array_get(classMethods, classId);
						if ($_dictionary_contains(methodDefinitionLookup, nameId)) {
							methodDefinition = $_dictionary_get_guaranteed(methodDefinitionLookup, nameId);
							value = new Value(Types.METHOD,
								new MethodInstance(
									root,
									MethodDefinition$methodDefinition.pc,
									MethodDefinition$methodDefinition.maxArgs));
							$_dictionary_set(ObjectInstance$objInstance.fields, nameId, value);
							$_stack_push(valueStack, value);
						} else {
							return killExecution(stack, "Field used before it was defined.");
						}
					}
				} else if (type == Types.NATIVE_OBJECT) {
					nativeObject = $_cast('NativeObjectWrapper', Value$root.internalValue);
					int1 = NativeObjectWrapper$nativeObject.subType;
					string1 = $_array_get(identifiers, nameId);
					value = VALUE_NULL;
					switch (int1) {
						/*
							vague type | specific type
							-----------+---------------
							key        | keydown
							key        | keyup
							mouse      | mousemove
							mouse      | mouseleftdown
							mouse      | mouseleftup
							mouse      | mouserightdown
							mouse      | mouserightup
							quit       | quit-altf4
							quit       | quit-closebutton
							quit       | quit-context      // context switch on a mobile device, e.g. pressing home on a mobile device
							quit       | quit-back         // back button on an android device
						*/
						case NativeObjectSubType.EVENT:
							gameEvent = $_cast('GameEvent', NativeObjectWrapper$nativeObject.value);
							// This comparison chain is inefficient. :(
							// Need to support string switch statements in translate mode.
							// Or convert string1 into a consistent numbering scheme.

							// TODO: this list of fields is not yet complete.
							if ($_string_equals("button", string1)) {
								if ($_string_equals("mouse", GameEvent$gameEvent.vagueType)) {
									value = buildCommonString(GameEvent$gameEvent.arg);
								} else {
									return killExecution(stack, "Only mouse events have a button field.");
								}
							} else if ($_string_equals("down", string1)) {
								if ($_string_equals("mouse", GameEvent$gameEvent.vagueType) ||
									$_string_equals("key", GameEvent$gameEvent.vagueType)) {
									if ($_string_equals("mousemove", GameEvent$gameEvent.specificType)) {
										return killExecution(stack, "'mousemove' events do not have a 'down' field.");
									} else {
										if (GameEvent$gameEvent.down) {
											value = VALUE_TRUE;
										} else {
											value = VALUE_FALSE;	
										}
									}
								} else {
									return killExecution(stack, "'" + GameEvent$gameEvent.specificType + "' events do not have a 'down' field.");
								}
							} else if ($_string_equals("is_key", string1)) {
								if ($_string_equals("key", GameEvent$gameEvent.vagueType)) {
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							} else if ($_string_equals("is_mouse", string1)) {
								if ($_string_equals("mouse", GameEvent$gameEvent.vagueType)) {
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							} else if ($_string_equals("is_quit", string1)) {
								if ($_string_equals("quit", GameEvent$gameEvent.vagueType)) {
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							} else if ($_string_equals("key", string1)) {
								if ($_string_equals("key", GameEvent$gameEvent.vagueType)) {
									value = buildCommonString(GameEvent$gameEvent.arg);
								} else {
									return killExecution(stack, "Only keyboard events have a key field.");
								}
							} else if ($_string_equals("type", string1)) {
								value = buildCommonString(GameEvent$gameEvent.specificType);
							} else if ($_string_equals("x", string1)) {
								if ($_string_equals("mouse", GameEvent$gameEvent.vagueType)) {
									value = buildInteger(GameEvent$gameEvent.x);
								} else {
									return killExecution(stack, "Only mouse events have an x field.");
								}
							} else if ($_string_equals("y", string1)) {
								if ($_string_equals("mouse", GameEvent$gameEvent.vagueType)) {
									value = buildInteger(GameEvent$gameEvent.y);
								} else {
									return killExecution(stack, "Only mouse events have a y field.");
								}
							} else {
								return killExecution(stack, "Game Event does not have a field called '" + string1 + "'");
							}
							break;

						case NativeObjectSubType.GAMEPAD_DEVICE:
							gamepad1 = $_cast('GamepadDevice', NativeObjectWrapper$nativeObject.value);
							if ($_string_equals('name', string1)) {
								value = buildCommonString(GamepadDevice$gamepad1.name);
							} else if ($_string_equals('enabled', string1)) {
								if (GamepadDevice$gamepad1.enabled) {
									value = VALUE_TRUE;
								} else {
									value = VALUE_FALSE;
								}
							} else if ($_string_equals('buttons', string1)) {
								if (!GamepadDevice$gamepad1.enabled) {
									return killExecution(stack, "Cannot access button states until gamepad is initialized.");
								}
								value = buildListByWrappingInput(gamepadBuildButtonActivityList(gamepad1));
							} else if ($_string_equals('axes', string1)) {
								if (!GamepadDevice$gamepad1.enabled) {
									return killExecution(stack, "Cannot access axes states until gamepad is initialized.");
								}
								value = buildListByWrappingInput(gamepadBuildAxisActivityList(gamepad1));
							} else {
								return killExecution(stack, "Gamepad does not have a field called '" + string1 + "'");
							}
							break;

						case NativeObjectSubType.HTTP_REQUEST:
							httpRequest1 = $_cast('HttpRequest', NativeObjectWrapper$nativeObject.value);
							int1 = HttpRequest$httpRequest1.statusCode;
							if ($_string_equals("completed", string1)) {
								if (int1 == 0) {
									value = VALUE_FALSE;
								} else {
									value = VALUE_TRUE;
								}
							} else if (int1 == 0) {
								// TODO: may reconsider adding an HttpRequest native object field that gets set to true once .completed is called 
								// and returns true so that there won't be any race conditions.
								return killExecution(stack, "Cannot dereference any fields on an incomplete HTTP request other than .completed");
							} else if ($_string_equals("content", string1)) {
								string2 = HttpRequest$httpRequest1.body;
								if (string2 == null) {
									value = VALUE_NULL;
								} else {
									value = buildString(string2);
								}
							} else if ($_string_equals("code", string1)) {
								value = buildInteger(int1);
							}
							break;

						case NativeObjectSubType.IMAGE:
							image1 = $_cast('Image', NativeObjectWrapper$nativeObject.value);
							if ($_string_equals("width", string1)) {
								value = buildInteger(Image$image1.width);
							} else if ($_string_equals("height", string1)) {
								value = buildInteger(Image$image1.height);
							} else {
								return killExecution(stack, "Image does not have a field called '" + string1 + "'");
							}
							break;

						default:
							return killExecution(stack, "Unrecognized field.");
							break;
					}
					$_stack_push(valueStack, value);
				} else if (nameId == LENGTH_ID) { // Length is a field. All other primitive type stuff is not.
					len = -1;
					if (type == Types.LIST) {
						// might need to revisit this if other platforms aren't as easy to do a list implementation?
						list1 = $_cast('List<Value>', Value$root.internalValue);
						len = $_list_length(list1);
					} else if (type == Types.DICTIONARY) {
						dictImpl = $_cast('DictImpl', Value$root.internalValue);
						len = DictImpl$dictImpl.size;
					} else if (type == Types.STRING) {
						string1 = $_cast('string', Value$root.internalValue);
						len = $_string_length(string1);
					} else {
						return killExecution(stack, getTypeFromId(type) + " does not have a length property.");
					}

					if (len < INTEGER_POSITIVE_CACHE) {
						$_stack_push(valueStack, $_array_get($_array_get(INTEGERS_CACHE, 0), len));
					} else {
						$_stack_push(valueStack, new Value(Types.INTEGER, len));
					}
				} else {
					// Everything else will presumably be hit 99% of the time via the DOT_STEP_INVOKE op instead of here, since they're methods. 
					// Therefore I'm not particularly concerned about optimizing the rest of this.

					string1 = $_string_cast_weak(type) + $_array_get(identifiers, nameId);
					if ($_dictionary_contains(primitiveMethodLookup, string1)) {
						int1 = $_dictionary_get_guaranteed(primitiveMethodLookup, string1);
						$_stack_push(
							valueStack, 
							new Value(Types.SYS_METHOD, new SystemMethod(root, int1)));
					} else {
						return killExecution(
							stack, 
							getTypeFromId(type) + " type does not have a field called '" + $_array_get(identifiers, $_array_get(row, 0)) + "'.");
					}
				}
				break;

			case OpCodes.DUPLICATE_STACK_TOP:
				$_comment('DUPLICATE_STACK_TOP');
				if ($_array_get(row, 0) == 1) {
					$_stack_push(valueStack, $_stack_get(valueStack, $_stack_length(valueStack) - 1));
				} else {
					for (i = 0; i < $_array_get(row, 0); i += 1) {
						$_stack_push(valueStack, $_stack_get(valueStack, $_stack_length(valueStack) - $_array_get(row, 0)));
					}
				}
				break;

			case OpCodes.FINALIZE_INITIALIZATION:
				ProgramData$p.identifiers = $_convert_list_to_array('string', ProgramData$p.identifiersBuilder);
				ProgramData$p.literalTable = $_convert_list_to_array('Value', ProgramData$p.literalTableBuilder);
				ProgramData$p.integerSwitchLookups = $_convert_list_to_array('Dictionary<int, int>', ProgramData$p.integerSwitchLookupsBuilder);
				ProgramData$p.stringSwitchLookups = $_convert_list_to_array('Dictionary<string, int>', ProgramData$p.stringSwitchLookupsBuilder);
				ProgramData$p.sourceCode = $_convert_list_to_array('string', ProgramData$p.sourceCodeBuilder);

				ProgramData$p.identifiersBuilder = null;
				ProgramData$p.literalTableBuilder = null;
				ProgramData$p.integerSwitchLookupsBuilder = null;
				ProgramData$p.stringSwitchLookupsBuilder = null;
				ProgramData$p.sourceCodeBuilder = null;

				identifiers = ProgramData$p.identifiers;
				literalTable = ProgramData$p.literalTable;
				integerSwitches = ProgramData$p.integerSwitchLookups;
				stringSwitches = ProgramData$p.stringSwitchLookups;

				if ($_dictionary_contains(inv_identifiers, 'length')) {
					LENGTH_ID = $_dictionary_get_guaranteed(inv_identifiers, 'length');
				}

				imageSheetStatusInitialization();

				ProgramData$p.initializationComplete = true;

				break;

			case OpCodes.FUNCTION_DEFINITION:
				$_comment('FUNCTION_DEFINITION');
				if ($_array_get(row, 3) == 1) {
					// TODO: figure out why I put this if statement here.
				} else {
					funcDef = new FunctionDefinition(
						StackFrame$stack.pc + $_array_get(row, 1), // PC
						$_array_get(row, 2), // max arg count
						$_array_get(identifiers, $_array_get(row, 0))); // name
					$_stack_push(valueStack, new Value(Types.FUNCTION, funcDef));
				}
				break;

			case OpCodes.INDEX:
				$_comment('INDEX');
				value = $_stack_pop(valueStack);
				root = $_stack_pop(valueStack);
				if (Value$root.type == Types.LIST) {
					if (Value$value.type != Types.INTEGER) {
						return killExecution(stack, "List index must be an integer.");
					} else {
						i = $_cast('int', Value$value.internalValue);
						list1 = $_cast('List<Value>', Value$root.internalValue);
						if (i < 0) return killExecution(stack, "List index cannot be negative.");
						else if (i >= $_list_length(list1)) return killExecution(stack, "List index is out of bounds");
						else {
							output = $_list_get(list1, i);
							$_stack_push(valueStack, output);
						}
					}
				} else if (Value$root.type == Types.DICTIONARY) {
					dictImpl = $_cast('DictImpl', Value$root.internalValue);
					keyType = Value$value.type;
					if (keyType != DictImpl$dictImpl.keyType) {
						if (DictImpl$dictImpl.size == 0) {
							return killExecution(stack, "Key not found. Dictionary is empty.");
						}
						return killExecution(stack, "Incorrect key type. This dictionary contains " + getTypeFromId(DictImpl$dictImpl.keyType) + " keys. Provided key is a " + getTypeFromId(keyType) + ".");
					} else {
						if (keyType == Types.INTEGER) {
							intKey = $_cast('int', Value$value.internalValue);
						} else if (keyType == Types.STRING) {
							stringKey = $_cast('string', Value$value.internalValue);
						} else if (keyType == Types.INSTANCE) {
							objInstance = $_cast('ObjectInstance', Value$value.internalValue);
							intKey = ObjectInstance$objInstance.objectId;
						} else {
							if (DictImpl$dictImpl.size == 0) {
								return killExecution(stack, "Key not found. Dictionary is empty.");
							}
							return killExecution(stack, "Key not found.");
						}

						if (keyType == Types.STRING) {
							dictStringValueLookup = $_cast('Dictionary<string, Value>', DictImpl$dictImpl.valueStringLookup);
							if ($_dictionary_contains(dictStringValueLookup, stringKey)) {
								output = $_dictionary_get_guaranteed(dictStringValueLookup, stringKey);
							} else {
								return killExecution(stack, "Key not found: '" + stringKey + "'");
							}
						} else {
							dictIntValueLookup = $_cast('Dictionary<int, Value>', DictImpl$dictImpl.valueIntLookup);
							if ($_dictionary_contains(dictIntValueLookup, intKey)) {
								output = $_dictionary_get_guaranteed(dictIntValueLookup, intKey);
							} else {
								return killExecution(stack, "Key not found.");
							}
						}

						if (output == null) return killExecution(stack, "Key not found.");
							
						$_stack_push(valueStack, output);
					}
				} else if (Value$root.type == Types.STRING) {
					string1 = $_cast('string', Value$root.internalValue);
					if (Value$value.type != Types.INTEGER) {
						return killExecution(stack, "indexes into strings must be integers.");
					}
					int1 = $_cast('int', Value$value.internalValue);
					if (int1 < 0 || int1 >= $_string_length(string1)) {
						return killExecution(stack, "String index out of range.");
					}
					// Single char strings are common.
					$_stack_push(valueStack, buildCommonString($_char_to_string($_string_char_at(string1, int1))));
				} else {
					return killExecution(stack, "Cannot index into this type: " + getTypeFromId(Value$root.type));
				}
				break;

			case OpCodes.ITERATION_STEP:
				$_comment('ITERATION_STEP');
				int1 = $_stack_length(valueStack); // current stack length
				value3 = $_stack_get(valueStack, int1 - 3);
				value2 = $_stack_get(valueStack, int1 - 2); // name ID of iterating variable
				value = $_stack_get(valueStack, int1 - 1); // list
				i = $_cast('int', Value$value3.internalValue); // iterator index
				nameId = $_cast('int', Value$value2.internalValue); // iterating variable name ID
				if (Value$value.type == Types.LIST) {
					list1 = $_cast('List<Value>', Value$value.internalValue); // the actual list
					len = $_list_length(list1);
					bool1 = true;
				} else {
					string1 = $_cast('string', Value$value.internalValue); // the actual string
					len = $_string_length(string1);
					bool1 = false;
				}
				if (i < len) {
					if (bool1) {
						$_dictionary_set(locals, nameId, $_list_get(list1, i));
					} else {
						// Go easy on GC. Single-char strings are going to be common for users that use foreach loops on strings.
						value = buildCommonString($_char_to_string($_string_char_at(string1, i)));
						$_dictionary_set(locals, nameId, value);
					}
				} else {
					StackFrame$stack.pc += $_array_get(row, 0);
				}
				i += 1;
				$_stack_set(valueStack, int1 - 3, buildInteger(i));
				break;

			case OpCodes.JUMP:
				$_comment('JUMP');
				StackFrame$stack.pc += $_array_get(row, 0);
				break;
			
			case OpCodes.JUMP_IF_FALSE:
				$_comment('JUMP_IF_FALSE');
				value = $_stack_pop(valueStack);
				if (Value$value.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if (!$_cast('bool', Value$value.internalValue)) {
					StackFrame$stack.pc += $_array_get(row, 0);
				}
				break;

			case OpCodes.JUMP_IF_FALSE_NO_POP:
				$_comment('JUMP_IF_FALSE_NON_POP');
				value = $_stack_pop(valueStack);
				if (Value$value.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if (!$_cast('bool', Value$value.internalValue)) {
					StackFrame$stack.pc += $_array_get(row, 0);
					$_stack_push(valueStack, VALUE_FALSE);
				}
				break;

			case OpCodes.JUMP_IF_TRUE:
				$_comment('JUMP_IF_TRUE');
				value = $_stack_pop(valueStack);
				if (Value$value.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if ($_cast('bool', Value$value.internalValue)) {
					StackFrame$stack.pc += $_array_get(row, 0);
				}
				break;

			case OpCodes.JUMP_IF_TRUE_NO_POP:
				$_comment('JUMP_IF_TRUE_NO_POP');
				value = $_stack_pop(valueStack);
				if (Value$value.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if ($_cast('bool', Value$value.internalValue)) {
					StackFrame$stack.pc += $_array_get(row, 0);
					$_stack_push(valueStack, VALUE_TRUE);
				}
				break;
				
			case OpCodes.LITERAL:
				$_comment('LITERAL');
				$_stack_push(valueStack, $_array_get(literalTable, $_array_get(row, 0)));
				break;

			case OpCodes.LITERAL_STREAM:
				$_comment('LITERAL_STREAM');
				for (i = $_array_length(row) - 1; i >= 0; i -= 1) {
					$_stack_push(valueStack, $_array_get(literalTable, $_array_get(row, i)));
				}
				break;

			case OpCodes.NEGATIVE_SIGN:
				$_comment('NEGATIVE_SIGN');
				value = $_stack_pop(valueStack);
				type = Value$value.type;
				if (type == Types.INTEGER) {
					value = buildInteger(-$_cast('int', Value$value.internalValue));
				} else if (type == Types.FLOAT) {
					value = buildFloat(-$_cast('double', Value$value.internalValue));
				} else {
					return killExecution(stack, "Negative sign can only be applied to numbers. Found " + getTypeFromId(type) + " instead.");
				}
				$_stack_push(valueStack, value);
				break;

			case OpCodes.POP:
				$_comment('POP');
				$_stack_pop(valueStack);
				break;

			case OpCodes.RETURN:
				$_comment('RETURN');
				value = $_stack_pop(valueStack);
				bool1 = StackFrame$stack.returnValueUsed;
				stack = StackFrame$stack.previous;
				if (stack == null) {
					return '';
				}
				valueStack = StackFrame$stack.valueStack;
				locals = StackFrame$stack.locals;
				if (bool1) {
					$_stack_push(valueStack, value);
				}
				break;

			case OpCodes.RETURN_NULL:
				$_comment('RETURN_NULL');
				// use return value
				bool1 = StackFrame$stack.returnValueUsed;
				stack = StackFrame$stack.previous;
				if (stack == null) {
					return '';
				}
				locals = StackFrame$stack.locals;
				valueStack = StackFrame$stack.valueStack;
				if (bool1) {
					$_stack_push(valueStack, VALUE_NULL);
				}
				break;

			case OpCodes.SPRITE_SHEET_BUILDER:
				$_comment('SPRITE_SHEET_BUILDER');
				int1 = $_array_get(row, 0);

				if (int1 == 0) { // Sprite sheet declaration
					int1 = $_array_get(row, 1); // sprite sheet ID#
					string1 = $_array_get(stringArgs, StackFrame$stack.pc); // sprite sheet name

					$_dictionary_set(SpriteSheetData$spriteSheetData.filesByGroupId, int1, $_new_list('string'));
					$_dictionary_set(SpriteSheetData$spriteSheetData.tileIdsByGroupId, int1, $_new_dictionary('int', 'bool'));
					$_dictionary_set(SpriteSheetData$spriteSheetData.groupIdsByName, string1, int1);

				} else {
					declareSpriteSheetImage(
						spriteSheetData,
						$_array_get(row, 1), // group ID
						$_array_get(stringArgs, StackFrame$stack.pc), // image file path
						$_array_get(row, 2), // tile ID of top left corner
						$_array_get(row, 3), // image width
						$_array_get(row, 4), // image height
						$_array_get(row, 5), // x coordinate within this tile
						$_array_get(row, 6), // y coordinate within this tile
						$_array_get(row, 7) == 1); // solitary image (this tile IS the image, do not do spill calculations)
				}
				break;

			case OpCodes.STACK_INSERTION_FOR_INCREMENT:
				$_comment('STACK_INSERTION_FOR_INCREMENT');
				value = $_stack_pop(valueStack);
				value2 = $_stack_pop(valueStack);
				value3 = $_stack_pop(valueStack);
				$_stack_push(valueStack, value);
				$_stack_push(valueStack, value3);
				$_stack_push(valueStack, value2);
				$_stack_push(valueStack, value);
				break;

			case OpCodes.STACK_SWAP_POP:
				$_comment('STACK_SWAP_POP');
				value = $_stack_pop(valueStack);
				$_stack_pop(valueStack);
				$_stack_push(valueStack, value);
				break;

			case OpCodes.SWITCH_INT:
				$_comment('SWITCH_INT');
				value = $_stack_pop(valueStack);
				if (Value$value.type == Types.INTEGER) {
					int1 = $_cast('int', Value$value.internalValue); // switch ID
					integerSwitch = $_array_get(integerSwitches, $_array_get(row, 0));
					if ($_dictionary_contains(integerSwitch, int1)) {
						StackFrame$stack.pc += $_dictionary_get_guaranteed(integerSwitch, int1);
					} else {
						StackFrame$stack.pc += $_array_get(row, 1); // default
					}
				} else {
					return killExecution(stack, "Switch statement expects an integer.");
				}
				break;

			case OpCodes.SWITCH_STRING:
				$_comment('SWITCH_STRING');
				value = $_stack_pop(valueStack);
				if (Value$value.type == Types.STRING) {
					string1 = $_cast('string', Value$value.internalValue);
					stringSwitch = $_array_get(stringSwitches, $_array_get(row, 0));
					if ($_dictionary_contains(stringSwitch, string1)) {
						StackFrame$stack.pc += $_dictionary_get_guaranteed(stringSwitch, string1);
					} else {
						StackFrame$stack.pc += $_array_get(row, 1); // default
					}
				} else {
					return killExecution(stack, "Switch statement expects a string.");
				}
				break;

			case OpCodes.THIS:
				$_comment('THIS');
				// will never be called outside of a method.
				$_stack_push(valueStack, StackFrame$stack.objectContext);
				break;

			case OpCodes.TOKEN_DATA:
				$_comment('TOKEN_DATA');
				tokensByPc = ProgramData$p.tokenData;
				i = $_array_get(row, 0) + ProgramData$p.userCodeStart; // PC
				int1 = $_array_get(row, 1); // Line
				int2 = $_array_get(row, 2); // Col
				int3 = $_array_get(row, 3); // File ID
				tokens = $_array_get(tokensByPc, i);
				if (tokens == null) {
					tokens = $_new_list('Token');
					$_array_set(tokensByPc, i, tokens);
				}
				$_list_push(tokens, new Token(int1, int2, int3));
				break;

			case OpCodes.USER_CODE_START:
				$_comment('USER_CODE_START');
				int1 = $_array_get(row, 0);
				ProgramData$p.userCodeStart = int1;
				break;

			case OpCodes.VARIABLE:
				$_comment('VARIABLE');
				nameId = $_array_get(row, 0);
				if ($_dictionary_contains(locals, nameId)) {
					value = $_dictionary_get_guaranteed(locals, nameId);
				} else if ($_dictionary_contains(globals, nameId)) {
					value = $_dictionary_get_guaranteed(globals, nameId);
				} else {
					return killExecution(stack, "Variable not defined: " + $_array_get(identifiers, nameId));
				}

				$_stack_push(valueStack, value);
				break;

			case OpCodes.VARIABLE_STREAM:
				$_comment('VARIABLE_STREAM');
				int1 = $_array_get(row, 0);
				for (i = 1; i <= int1; i += 1) {
					nameId = $_array_get(row, i);
					if ($_dictionary_contains(locals, nameId)) {
						value = $_dictionary_get_guaranteed(locals, nameId);
					} else if ($_dictionary_contains(globals, nameId)) {
						value = $_dictionary_get_guaranteed(globals, nameId);
					} else {
						tokens = $_new_list('Token');
						int2 = (i - 1) * 3 + int1 + 1;
						$_list_push(tokens, new Token(
							$_array_get(row, int2),
							$_array_get(row, int2 + 1),
							$_array_get(row, int2 + 2)));
						$_array_set(ProgramData$p.tokenData, StackFrame$stack.pc, tokens);
							
						return killExecution(stack, "Variable not defined: " + $_array_get(identifiers, nameId));
					}

					$_stack_push(valueStack, value);
				}
				break;

			case OpCodes.VERIFY_TYPE_IS_ITERABLE:
				$_comment('VERIFY_TYPE_IS_ITERABLE');
				value = $_stack_pop(valueStack);
				if (Value$value.type != Types.LIST && Value$value.type != Types.STRING) {
					return killExecution(stack, "Expected an iterable type, such as a list or string.");
				}
				$_stack_push(valueStack, value);
				break;

			default:
				$_comment('THIS SHOULD NEVER HAPPEN');
				return killExecution(stack, "Bad op code: " + $_string_cast_weak($_array_get(ops, StackFrame$stack.pc)));
		}
		StackFrame$stack.pc += 1;
	}
}

function @type('int') declareSpriteSheetImage(
		@type('SpriteSheetData') spriteSheetData,
		@type('int') groupId,
		@type('string') imagePath,
		@type('int') tileId, // top left corner
		@type('int') width,
		@type('int') height,
		@type('int') x,
		@type('int') y,
		@type('bool') solitary) {

	@type('SpriteSheetItemDescriptor') ssid = new SpriteSheetItemDescriptor(
		imagePath,
		groupId,
		0, // this may be unncessary
		tileId,
		solitary,
		x,
		y,
		width,
		height);

	$_dictionary_set(SpriteSheetData$spriteSheetData.files, imagePath, ssid);

	@type('Dictionary<int, bool>') tileIds = $_dictionary_get_guaranteed(SpriteSheetData$spriteSheetData.tileIdsByGroupId, groupId);
	@type('int') colSpan = $_int($_unsafe_integer_division(x % 256 + width, 256)) + 1;
	@type('int') rowSpan = $_int($_unsafe_integer_division(y % 256 + height, 256)) + 1;
	if (solitary) {
		colSpan = 1;
		rowSpan = 1;
	}
	for (@type('int') row = 0; row < rowSpan; row += 1) {
		for (@type('int') col = 0; col < colSpan; col += 1) {
			$_dictionary_set(tileIds, tileId + row * 4 + col, true);
		}
	}
	return 0;
}

function @type('string') killExecution(@type('StackFrame') stack, @type('string') message) {
	return killExecutionWithTokenOverride(stack, null, message);
}

function @type('string') killExecutionWithTokenOverride(
		@type('StackFrame') stack, 
		@type('Token') firstTokenOverride, 
		@type('string') message) {
	@type('string') fullMessage = '';
	@type('ProgramData') programData = $_get_program_data(); 
	@type('Array<List<Token>>') allTokens = ProgramData$programData.tokenData;
	@type('List<Token>') tokenList = null;
	@type('Token') token = null;
	@type('Array<string>') allFiles = generateSourceFiles();
	@type('bool') first = true;
	@type('int') line = 0;
	@type('int') col = 0;
	@type('int') fileId = 0;

	while (stack != null) {
		@type('int') pc = StackFrame$stack.pc;
		stack = StackFrame$stack.previous;

		token = null;

		tokenList = $_array_get(allTokens, pc);
		if (tokenList != null) {
			token = $_list_get(tokenList, 0);
		}
		if (first && firstTokenOverride != null) {
			token = firstTokenOverride;
		}

		if (token != null) {
			line = Token$token.lineIndex;
			col = Token$token.colIndex;
			fileId = Token$token.fileId;
			if (fileId < $_array_length(allFiles)) {
				@type('string') fileData = $_array_get(allFiles, fileId);
				@type('Array<string>') lines = $_string_split(fileData, '\n');
				@type('string') filename = $_array_get(lines, 0);
				@type('string') linevalue = $_array_get(lines, line + 1);
				fullMessage = filename + ", Line: " + $_string_cast_weak(line + 1) + ", Col: " + $_string_cast_weak(col + 1) + "\n" + fullMessage;
				if (first) {
					@type('string') linedisplay = '';
					@type('string') arrowdisplay = '';
					@type('bool') lefttrim = true;
					for (@type('int') i = 0; i < $_string_length(linevalue); i += 1) {
						@type('char') c = $_string_char_at(linevalue, i);
						if (lefttrim) {
							if (c == $_string_as_char(' ') || c == $_string_as_char('\t') || c == $_string_as_char('\r')) {
								col -= 1;
							} else {
								lefttrim = false;
								i -= 1;
							}
						} else {
							if (col == 0) {
								arrowdisplay += '^';
								linedisplay += c;
							} else if (c == $_string_as_char('\t')) {
								arrowdisplay += '    ';
								linedisplay += '    ';
							} else {
								arrowdisplay += ' ';
								linedisplay += c;
							}
							col -= 1;
						}
					}
					fullMessage = fullMessage + "\n  " + message + "\n\n" + linedisplay + "\n" + arrowdisplay;
				}
			} else {
				token = null; // execution killed before file data was loaded
			}
		}

		if (token == null) {
			fullMessage = "[No Stack Info]\n" + fullMessage;
			if (first) {
				fullMessage += "[No Stack Info]\n  " + message + "\n";
			}
		}

		first = false;
		token = null;
	}
	return "Error:\n" + fullMessage;
}

// This saves the state of the interpreter so that it's ready to have
// interpret() called again. Even though this is only called once directly
// in the translated crayon interpreter code, certain platforms will need
// to call this manually.
function yieldControl(@type('StackFrame') stack) {
	@type('ProgramData') p = $_get_program_data();
	ProgramData$p.stackTop = stack;
	StackFrame$stack.pc += 1;
}

// Work nuggets are only performed if the ProgramData.initializationComplete field is set to true

function performWorkNuggetPreFrame() {
	imageSheetPerformWorkNuggetPreFrame();
}

function performWorkNuggetPostFrame() {
	imageSheetPerformWorkNuggetPostFrame();
	$_async_message_queue_pump();
}
