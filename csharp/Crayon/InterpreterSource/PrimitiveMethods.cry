
function @type('string') wrongArgCountError(@type('string') name, @type('int') expected, @type('int') actual) {
	@type('string') output = null;
	if (expected == 0) {
		output = name + " does not accept any arguments.";
	} else if (expected == 1) {
		output = name + " accepts exactly 1 argument.";
	} else {
		output = name + " requires " + expected + " arguments.";
	}

	output += " Found: " + actual;
	return output;
}

function @type('Dictionary<string, int>') generatePrimitiveMethodLookupTable() {

	// TODO: eventually take in the dictionary of inv_identifiers and build an int->int lookup
	// where the keys are the method name ID * MAX_TYPE + type ID

	@type('Dictionary<string, int>') lookup = $_new_dictionary('string', 'int');
	// no need to weakly cast ints to strings, since the optimizer will consolidate everything into inline strings
	$_dictionary_set(lookup, Types.STRING + "contains", %%%PRIMITIVE_METHOD_STRING_CONTAINS%%%);
	
	$_dictionary_set(lookup, Types.STRING + "endsWith", %%%PRIMITIVE_METHOD_STRING_ENDSWITH%%%);
	$_dictionary_set(lookup, Types.STRING + "lower", %%%PRIMITIVE_METHOD_STRING_LOWER%%%);
	$_dictionary_set(lookup, Types.STRING + "reverse", %%%PRIMITIVE_METHOD_STRING_REVERSE%%%);
	$_dictionary_set(lookup, Types.STRING + "replace", %%%PRIMITIVE_METHOD_STRING_REPLACE%%%);
	$_dictionary_set(lookup, Types.STRING + "split", %%%PRIMITIVE_METHOD_STRING_SPLIT%%%);
	$_dictionary_set(lookup, Types.STRING + "startsWith", %%%PRIMITIVE_METHOD_STRING_STARTSWITH%%%);
	$_dictionary_set(lookup, Types.STRING + "trim", %%%PRIMITIVE_METHOD_STRING_TRIM%%%);
	$_dictionary_set(lookup, Types.STRING + "upper", %%%PRIMITIVE_METHOD_STRING_UPPER%%%);

	$_dictionary_set(lookup, Types.LIST + "add", %%%PRIMITIVE_METHOD_LIST_ADD%%%);
	$_dictionary_set(lookup, Types.LIST + "clear", %%%PRIMITIVE_METHOD_LIST_CLEAR%%%);
	$_dictionary_set(lookup, Types.LIST + "contains", %%%PRIMITIVE_METHOD_LIST_CONTAINS%%%);
	$_dictionary_set(lookup, Types.LIST + "insert", %%%PRIMITIVE_METHOD_LIST_INSERT%%%);
	$_dictionary_set(lookup, Types.LIST + "join", %%%PRIMITIVE_METHOD_LIST_JOIN%%%);
	$_dictionary_set(lookup, Types.LIST + "pop", %%%PRIMITIVE_METHOD_LIST_POP%%%);
	$_dictionary_set(lookup, Types.LIST + "remove", %%%PRIMITIVE_METHOD_LIST_REMOVE%%%);
	$_dictionary_set(lookup, Types.LIST + "reverse", %%%PRIMITIVE_METHOD_LIST_REVERSE%%%);
	$_dictionary_set(lookup, Types.LIST + "shuffle", %%%PRIMITIVE_METHOD_LIST_SHUFFLE%%%);

	$_dictionary_set(lookup, Types.DICTIONARY + "clear", %%%PRIMITIVE_METHOD_DICTIONARY_CLEAR%%%);
	$_dictionary_set(lookup, Types.DICTIONARY + "contains", %%%PRIMITIVE_METHOD_DICTIONARY_CONTAINS%%%);
	$_dictionary_set(lookup, Types.DICTIONARY + "entries", %%%PRIMITIVE_METHOD_DICTIONARY_ENTRIES%%%);
	$_dictionary_set(lookup, Types.DICTIONARY + "get", %%%PRIMITIVE_METHOD_DICTIONARY_GET%%%);
	$_dictionary_set(lookup, Types.DICTIONARY + "keys", %%%PRIMITIVE_METHOD_DICTIONARY_KEYS%%%);
	$_dictionary_set(lookup, Types.DICTIONARY + "remove", %%%PRIMITIVE_METHOD_DICTIONARY_REMOVE%%%);
	$_dictionary_set(lookup, Types.DICTIONARY + "values", %%%PRIMITIVE_METHOD_DICTIONARY_VALUES%%%);

	return lookup;
}

function @type('string') callSystemMethod(
		@type('int') methodId,
		@type('Value') wrappedContext,
		@type('Array<Value>') funcArgs,
		@type('Stack<Value>') valueStack,
		@type('bool') returnValueUsed) {
	// trusted switch. No weird values will occur. (assuming you implement all the methods you have in the lookup table)
	@type('Value') output = VALUE_NULL;
	@type('object') context = Value$wrappedContext.internalValue;
	@type('int') i = 0;
	switch (methodId) {
		case %%%PRIMITIVE_METHOD_LIST_ADD%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("List add method", 1, $_array_length(funcArgs));
			$_list_push($_force_parens($_cast('List<Value>', context)), $_list_get(funcArgs, 0));
			break;
		case %%%PRIMITIVE_METHOD_LIST_CLEAR%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("List clear method", 0, $_array_length(funcArgs));
			// TODO: replace with the platform's .clear if convenient
			if (%%%PLATFORM_SUPPORTS_LIST_CLEAR%%%) {
				$_list_clear($_force_parens($_cast('List<Value>', Value$wrappedContext.internalValue)));
			} else {
				Value$wrappedContext.internalValue = $_new_list('Value');
			}
			break;
		case %%%PRIMITIVE_METHOD_LIST_CONTAINS%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("List contains method", 1, $_array_length(funcArgs));
			@type('List<Value>') list1 = $_cast('List<Value>', context);
			@type('int') len = $_list_length(list1);
			@type('Value') target = $_list_get(funcArgs, 0);
			output = VALUE_FALSE;
			for (i = 0; i < len; i += 1) {
				if (doEqualityComparisonAndReturnCode(target, $_list_get(list1, i)) == 1) {
					output = VALUE_TRUE;
					i += len;
				}
			}
			break;
		case %%%PRIMITIVE_METHOD_LIST_INSERT%%%:
			if ($_array_length(funcArgs) != 2) return wrongArgCountError("List insert method", 2, $_array_length(funcArgs));
			@type('Value') wrappedIndex = $_list_get(funcArgs, 0);
			@type('Value') value = $_list_get(funcArgs, 1);
			@type('List<Value>') list2 = $_cast('List<Value>', context);
			if (Value$wrappedIndex.type != Types.INTEGER) return "First argument of list.insert needs to be an integer.";
			@type('int') index = $_cast('int', Value$wrappedIndex.internalValue);
			if (index < 0 || index > $_list_length(list2)) return "Index out of bounds.";
			$_list_insert(list2, index, value);
			break;
		case %%%PRIMITIVE_METHOD_LIST_JOIN%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("List join method", 1, $_array_length(funcArgs));
			@type('List<Value>') list3 = $_cast('List<Value>', context);
			@type('Value') wrappedSep = $_array_get(funcArgs, 0);
			// TODO: make first argument optional
			if (Value$wrappedSep.type != Types.STRING) return "Argument of list.join needs to be a string.";
			@type('List<string>') sb = $_new_list('string');
			@type('string') sepstr = $_cast('string', Value$wrappedSep.internalValue);
			@type('int') len2 = $_list_length(list3);
			for (i = 0; i < len2; i += 1) {
				$_list_push(sb, valueToString($_list_get(list3, i)));
			}
			@type('string') string1 = $_list_join(sb, sepstr);
			output = new Value(Types.STRING, string1);
			break;
		case %%%PRIMITIVE_METHOD_LIST_POP%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("List pop method", 0, $_array_length(funcArgs));
			@type('List<Value>') lp_list = $_cast('List<Value>', context);
			if ($_list_length(lp_list) == 0) return "Cannot pop from empty list.";
			output = $_list_get(lp_list, $_list_last_index(lp_list));
			$_list_pop(lp_list);
			break;
		case %%%PRIMITIVE_METHOD_LIST_REMOVE%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("List remove method", 1, $_array_length(funcArgs));
			@type('Value') lr_wrappedIndex = $_array_get(funcArgs, 0);
			if (Value$lr_wrappedIndex.type != Types.INTEGER) return "First argument of list.remove needs to be an integer.";
			i = $_cast('int', Value$lr_wrappedIndex.internalValue);
			@type('List<Value>') lr_list = $_cast('List<Value>', context);
			if (i < 0 || i >= $_list_length(lr_list)) return "Index out of bounds.";
			output = $_list_get(lr_list, i);
			$_list_remove_at(lr_list, i);
			break;
		case %%%PRIMITIVE_METHOD_LIST_REVERSE%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("List reverse method", 0, $_array_length(funcArgs));
			$_list_reverse_in_place($_force_parens($_cast('List<Value>', context)));
			break;
		case %%%PRIMITIVE_METHOD_LIST_SHUFFLE%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("List shuffle method", 0, $_array_length(funcArgs));
			$_list_shuffle_in_place($_force_parens($_cast('List<Value>', context)));
			break;
		case %%%PRIMITIVE_METHOD_STRING_SPLIT%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("String split method", 1, $_array_length(funcArgs));
			@type('Value') ss_wrappedSep = $_list_get(funcArgs, 0);
			if (Value$ss_wrappedSep.type != Types.STRING) {
				return "Split method requires a string. Found a " + getTypeFromId(Value$ss_wrappedSep.type) + " instead.";
			}
			@type('string') ss_string = $_cast('string', context);
			@type('Array<string>') ss_rawList = $_string_split(ss_string, $_cast('string', Value$ss_wrappedSep.internalValue));
			@type('List<Value>') ss_wrappedList = $_new_list('Value');
			@type('int') ss_len = $_array_length(ss_rawList);
			for (i = 0; i < ss_len; i += 1) {
				$_list_push(ss_wrappedList, new Value(Types.STRING, $_list_get(ss_rawList, i)));
			}
			output = new Value(Types.LIST, ss_wrappedList);
			break;
		case %%%PRIMITIVE_METHOD_STRING_CONTAINS%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("String contains method", 1, $_array_length(funcArgs));
			@type('Value') sc_item = $_list_get(funcArgs, 0);
			if (Value$sc_item.type != Types.STRING) {
				return "String contains method requires a string. Found a " + getTypeFromId(Value$sc_item.type) + " instead.";
			}
			@type('string') sc_string = $_cast('string', context);
			if ($_string_contains(sc_string, $_cast('string', Value$sc_item.internalValue))) {
				output = VALUE_TRUE;
			} else {
				output = VALUE_FALSE;
			}
			break;
		case %%%PRIMITIVE_METHOD_STRING_ENDSWITH%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("String endsWith method", 1, $_array_length(funcArgs));
			@type('Value') sew_item = $_array_get(funcArgs, 0);
			@type('string') sew_string = $_cast('string', context);
			if (Value$sew_item.type != Types.STRING) {
				return "String endsWith method requires a string. Found a " + getTypeFromId(Value$sew_item.type) + " instead.";
			}
			if ($_string_endswith(sew_string, $_cast('string', Value$sew_item.internalValue))) {
				output = VALUE_TRUE;
			} else {
				output = VALUE_FALSE;
			}
			break;
		case %%%PRIMITIVE_METHOD_STRING_STARTSWITH%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("String startsWith method", 1, $_array_length(funcArgs));
			@type('Value') ssw_item = $_array_get(funcArgs, 0);
			@type('string') ssw_string = $_cast('string', context);
			if (Value$ssw_item.type != Types.STRING) {
				return "String startsWith method requires a string. Found a " + getTypeFromId(Value$ssw_item.type) + " instead.";
			}
			if ($_string_startswith(ssw_string, $_cast('string', Value$ssw_item.internalValue))) {
				output = VALUE_TRUE;
			} else {
				output = VALUE_FALSE;
			}
			break;
		case %%%PRIMITIVE_METHOD_STRING_UPPER%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("String upper method", 0, $_array_length(funcArgs));
			@type('string') su_string = $_cast('string', context);
			output = new Value(Types.STRING, $_string_upper(su_string));
			break;
		case %%%PRIMITIVE_METHOD_STRING_LOWER%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("String lower method", 0, $_list_length(funcArgs));
			@type('string') sl_string = $_cast('string', context);
			output = new Value(Types.STRING, $_string_lower(sl_string));
			break;
		case %%%PRIMITIVE_METHOD_STRING_TRIM%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("String trim method", 0, $_array_length(funcArgs));
			@type('string') st_string = $_cast('string', context);
			output = new Value(Types.STRING, $_string_trim(st_string));
			break;
		case %%%PRIMITIVE_METHOD_STRING_REVERSE%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("String reverse method", 0, $_array_length(funcArgs));
			@type('string') sr_string = $_cast('string', context);
			output = new Value(Types.STRING, $_string_reverse(sr_string));
			break;
		case %%%PRIMITIVE_METHOD_STRING_REPLACE%%%:
			if ($_array_length(funcArgs) != 2) return wrongArgCountError("String replace method", 2, $_array_length(funcArgs));
			@type('Value') sr_a = $_array_get(funcArgs, 0);
			@type('Value') sr_b = $_array_get(funcArgs, 1);
			if (Value$sr_a.type != Types.STRING || Value$sr_b.type != Types.STRING) {
				return "string replace must take in two strings as arguments.";
			}
			@type('string') srep_value = $_cast('string', context);
			output = new Value(Types.STRING, 
				$_string_replace(
					srep_value,
					$_cast('string', Value$sr_a.internalValue),
					$_cast('string', Value$srep_b.internalValue)));
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_CLEAR%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("Dictionary clear method", 0, $_array_length(funcArgs));
			DictImpl$context.keyLookup = {};
			DictImpl$context.valueLookup = {};
			DictImpl$context.size = 0;
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_GET%%%:
			if ($_array_length(funcArgs) != 2) return wrongArgCountError("Dictionary get method", 2, $_array_length(funcArgs));
			key = $_list_get(funcArgs, 0);
			defaultValue = $_list_get(funcArgs, 1);
			if (DictImpl$context.keyType != Value$key.type) {
				output = defaultValue;
			} else {
				valueLookup = DictImpl$context.valueLookup;
				keyValue = Value$key.internalValue;
				if (DictImpl$context.keyType == Types.INSTANCE) keyValue = $_list_get(keyValue, 2);
				value = $_dictionary_get(valueLookup, keyValue, null);
				if (value == null) {
					output = defaultValue;
				} else {
					output = value;
				}
			}
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_REMOVE%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("Dictionary remove method", 1, $_array_length(funcArgs));
			key = $_list_get(funcArgs, 0);
			keyType = Value$key.type;
			if (DictImpl$context.keyType != keyType) return "Key not found.";
			keyLookup = DictImpl$context.keyLookup;
			keyValue = Value$key.internalValue;
			if (keyType == Types.INSTANCE) keyValue = $_list_get(keyValue, 2);
			if ($_dictionary_get(keyLookup, keyValue, null) == null) return "Key not found.";
			$_dictionary_remove(keyLookup, keyValue);
			$_dictionary_remove(DictImpl$context.valueLookup, keyValue);
			DictImpl$context.size -= 1;
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_CONTAINS%%%:
			if ($_array_length(funcArgs) != 1) return wrongArgCountError("Dictionary contains method", 1, $_array_length(funcArgs));
			keys = DictImpl$context.keyLookup;
			arg = $_list_get(funcArgs, 0);
			argType = Value$arg.type;
			if (argType == Types.INTEGER || argType == Types.STRING) {
				key = Value$arg.internalValue;
			} else if (argType == Types.INSTANCE) {
				t = Value$arg.internalValue;
				key = $_list_get(t, 2);
			}

			if (DictImpl$context.keyType != argType) {
				output = VALUE_FALSE;
			} else {
				t = $_dictionary_get(keys, key, null);
				if (t == null) {
					output = VALUE_FALSE;
				} else {
					output = VALUE_TRUE;
				}
			}
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_VALUES%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("Dictionary values method", 0, $_array_length(funcArgs));
			values = $_dictionary_get_values(DictImpl$context.valueLookup);
			output = new Value(Types.LIST, values);
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_KEYS%%%:
			if ($_array_length(funcArgs) != 0) return wrongArgCountError("Dictionary keys method", 0, $_array_length(funcArgs));
			values = $_dictionary_get_values(DictImpl$context.keyLookup);
			output = new Value(Types.LIST, values);
			break;
		default:
			return "Unknown system method";
	}
	if (returnValueUsed) {
		$_stack_push(valueStack, output);
	}
	return null;
}
