
// TODO: the types for these values must be verified.
// The arg count is verified to be in the correct range at compile time.
// However if there are optional arguments, the number of args used in this call are located in row[2]
output = VALUE_NULL;
switch ($_array_get(row, 0)) {
	case %%%FF_ABS%%%:
		$_comment('$abs');
		value = $_stack_pop(valueStack);
		if (Value$value.type == Types.INTEGER) {
			if ($_cast('int', Value$value.internalValue) < 0) {
				output = buildInteger(-$_cast('int', Value$value.internalValue));
			} else {
				output = value;
			}
		} else if (Value$value.type == Types.FLOAT) {
			if ($_cast('double', Value$value.internalValue) < 0) {
				output = buildFloat(-$_cast('double', Value$value.internalValue));
			} else {
				output = value;
			}
		} else {
			return killExecution(stack, "$abs requires a number as input.");
		}
		break;

	case %%%FF_ARCCOS%%%:
		$_comment('$arccos');
		// $arccos(theta)
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			if (float1 < -1 || float1  > 1) {
				return killExecution(stack, "$arc_cos requires a number in the range of -1 to 1");
			}
			output = buildFloat($_arc_cos(float1));
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			if (int1 < -1 || int1 > 1) {
				return killExecution(stack, "$arc_cos requires a number in the range of -1 to 1");
			}
			output = buildFloat($_arc_cos(int1));
		} else {
			return killExecution(stack, "$arc_cos requires a number as input.");
		}
		break;

	case %%%FF_ARCSIN%%%:
		$_comment('$arcsin');
		// $arcsin(theta)
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			if (float1 < -1 || float1  > 1) {
				return killExecution(stack, "$arc_sin requires a number in the range of -1 to 1");
			}
			output = buildFloat($_arc_sin(float1));
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			if (int1 < -1 || int1 > 1) {
				return killExecution(stack, "$arc_sin requires a number in the range of -1 to 1");
			}
			output = buildFloat($_arc_sin(int1));
		} else {
			return killExecution(stack, "$arc_sin requires a number as input.");
		}
		break;

	case %%%FF_ARCTAN%%%:
		$_comment('$arctan');
		// $arctan(theta)
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			output = buildFloat($_arc_tan(float1, 1.0));
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			output = buildFloat($_arc_tan(int1, 1.0));
		} else {
			return killExecution(stack, "$arc_tan requires a number as input.");
		}
		break;

	case %%%FF_ARCTAN2%%%:
		$_comment('$arctan2');
		// $arctan2(y, x)
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			if (Value$arg2.type == Types.FLOAT) {
				float2 = $_cast('double', Value$arg2.internalValue);
				output = buildFloat($_arc_tan(float1, float2));
			} else if (Value$arg2.type == Types.INTEGER) {
				int2 = $_cast('int', Value$arg2.internalValue);
				output = buildFloat($_arc_tan(float1, int2));
			} else {
				return killExecution(stack, "$arctan2 requires 2 numeric arguments.");
			}
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			if (Value$arg2.type == Types.FLOAT) {
				float2 = $_cast('double', Value$arg2.internalValue);
				output = buildFloat($_arc_tan(int1, float2));
			} else if (Value$arg2.type == Types.INTEGER) {
				int2 = $_cast('int', Value$arg2.internalValue);
				output = buildFloat($_arc_tan(int1, int2));
			} else {
				return killExecution(stack, "$arctan2 requires 2 numeric arguments.");
			}
		} else {
			return killExecution(stack, "$arctan2 requires 2 numeric arguments.");
		}
		break;

	case %%%FF_ASSERT%%%:
		$_comment('$assert');
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.BOOLEAN) {
			return killExecution(stack, "Assertion expression must be a boolean.");
		}
		if (!$_cast('bool', Value$arg1.internalValue)) {
			return killExecution(stack, "Assertion failed: " + valueToString(arg2));
		}
		break;

	case %%%FF_CHR%%%:
		$_comment('$chr');
		arg1 = $_stack_pop(valueStack);
		output = null;
		if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			if (int1 >= 0 && int1 < 256) {
				output = buildCommonString($_chr(int1));
			}
		}
		if (output == null) {
			return killExecution(stack, "$chr requires an integer between 0 and 255");
		}
		break;

	case %%%FF_COS%%%:
		$_comment('$cos');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			output = buildFloat($_cos(float1));
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			output = buildFloat($_cos(int1));
		} else {
			return killExecution(stack, "$cos requires a number argument.");
		}
		break;

	case %%%FF_CURRENT_TIME%%%:
		$_comment('$current_time');
		output = buildFloat($_current_time_seconds());
		break;

	case %%%FF_FLOOR%%%:
		$_comment('$floor');
		// $floor(number)
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			if (%%%INT_IS_FLOOR%%%) {
				output = buildInteger($_int(float1));
			} else {
				if (float1 < 0 && float1 % 1 != 0) {
					output = buildInteger($_int(float1) - 1);
				} else {
					output = buildInteger($_int(float1));
				}
			}
		} else if (Value$arg1.type == Types.INTEGER) {
			output = arg1;
		} else {
			return killExecution(stack, "$floor expects a numeric argument.");
		}
		break;

	case %%%FF_GAME_CLOCK_TICK%%%:
		$_comment('$game_clock_tick');

		if (ProgramData$p.initializationComplete) {
			performWorkNuggetPostFrame();
		}

		yieldControl(stack);
		return null;
		// this extra break is not a mistake. Python translation will get confused without the break here. Ultimately I plan to make this smart enough that it'll figure it out, but it's not a high priority.
		break;

	case %%%FF_GAME_INITIALIZE%%%:
		$_comment('$game_initialize');
		// $initialize_game(fps)
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.INTEGER) {
			float1 = $_cast('int', Value$arg1.internalValue);
		} else if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
		} else {
			return killExecution(stack, "$initialize_game(fps) requiress a numeric argument.");
		}

		if (float1 <= 0) {
			return killExecution(stack, "fps must be a positive number.");
		}
		$_initialize_game_with_fps(float1);
		break;

	case %%%FF_GAME_INITIALIZE_SCREEN%%%:
		$_comment('$game_initialize_screen');
		// $initialize_screen(width, height)
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER) {
			return killExecution(stack, "$initialize_screen requires two integer arguments.");
		}

		int1 = $_cast('int', Value$arg1.internalValue);
		int2 = $_cast('int', Value$arg2.internalValue);
		if (int1 < 1 || int2 < 1) {
			return killExecution(stack, "Screen dimensions must be positive.");
		}

		if (%%%SCREEN_BLOCKS_EXECUTION%%%) {
			yieldControl(stack);
			$_initialize_screen(int1, int2, null, null);
			return '';
		} else {
			$_initialize_screen(int1, int2, null, null);
		}
		break;

	case %%%FF_GAME_INITIALIZE_SCREEN_SCALED%%%:
		$_comment('$game_initialize_screen_scaled');
		// $initialize_screen_scaled(gameWidth, gameHeight, pixelWidth, pixelHeight)
		arg4 = $_stack_pop(valueStack);
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER) {
			return killExecution(stack, "$initialize_screen_scaled requires four integer arguments.");
		}

		int1 = $_cast('int', Value$arg1.internalValue);
		int2 = $_cast('int', Value$arg2.internalValue);
		int3 = $_cast('int', Value$arg3.internalValue);
		int4 = $_cast('int', Value$arg4.internalValue);

		if (int1 < 1 || int2 < 1 || int3 < 1 || int4 < 1) {
			return killExecution(stack, "Screen dimensions must be positive.");
		}

		if (%%%SCREEN_BLOCKS_EXECUTION%%%) {
			yieldControl(stack);
			$_initialize_screen(int1, int2, int3, int4);
			return '';
		} else {
			$_initialize_screen(int1, int2, int3, int4);
		}
		break;

	case %%%FF_GAME_PUMP_EVENTS%%%:
		$_comment('$game_pump_events');
		list1 = $_get_events_raw_list();
		output = new Value(Types.LIST, list1);
		break;

	case %%%FF_GAME_SET_TITLE%%%:
		$_comment('$game_set_title');
		arg1 = $_stack_pop(valueStack);
		string1 = valueToString(arg1);
		$_set_title(string1);
		break;

	case %%%FF_GAMEPAD_BIND_ANALOG_AXIS%%%:
		$_comment('$gamepad_bind_analog_axis');
		arg2 = $_stack_pop(valueStack); // custom id
		arg1 = $_stack_pop(valueStack); // button item
		string1 = gamepadVerifyBindArgs(arg1, arg2);
		if (string1 != null) {
			return killExecution(stack, string1);
		}
		gamepadBindAnalogAxis(arg1, arg2);
		break;

	case %%%FF_GAMEPAD_BIND_BUTTON%%%:
		$_comment('$gamepad_bind_button');
		arg2 = $_stack_pop(valueStack); // custom id
		arg1 = $_stack_pop(valueStack); // button item
		break;

	case %%%FF_GAMEPAD_BIND_DIGITAL_AXIS%%%:
		$_comment('$gamepad_bind_digital_axis');
		arg2 = $_stack_pop(valueStack); // custom id
		arg1 = $_stack_pop(valueStack); // button item
		break;

	case %%%FF_GAMEPAD_DISABLE_DEVICE%%%:
		$_comment('$gamepad_disable_device');
		arg1 = $_stack_pop(valueStack); // device item
		break;

	case %%%FF_GAMEPAD_ENABLE_DEVICE%%%:
		$_comment('$gamepad_enable_device');
		arg1 = $_stack_pop(valueStack); // device item
		break;

	case %%%FF_GAMEPAD_GET_DEVICES%%%:
		$_comment('$gamepad_get_devices');
		output = buildListByWrappingInput(getGamepadDevices());
		break;

	case %%%FF_GAMEPAD_GET_PUSHED_BUTTONS%%%:
		$_comment('$gamepad_get_pushed_buttons');
		arg1 = null;
		break;

	case %%%FF_GFX_BLIT_IMAGE%%%:
		$_comment('$gfx_blit_image');
		// $blit_image(image, x, y)
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		image1 = extractImageFromValue(arg1);
		if (image1 == null) {
			return killExecution(stack, "$blit_image must consume an image as its first argument.");
		}
		if (Value$arg2.type != Types.INTEGER || Value$arg3.type != Types.INTEGER) {
			return killExecution(stack, "$gfx_blit_image coordinates must be integers.");
		}
		if (%%%IS_OPEN_GL_BASED%%%) {
			glDrawImageSimple(image1, $_cast('int', Value$arg2.internalValue), $_cast('int', Value$arg3.internalValue));
		} else {
			$_blit_image(image1, $_cast('int', Value$arg2.internalValue), $_cast('int', Value$arg3.internalValue));
		}
		break;

	case %%%FF_GFX_BLIT_IMAGE_PARTIAL%%%:
		$_comment('$gfx_blit_image_partial');
		// $gfx_blit_image_partial(image, targetX, targetY, sourceX, sourceY, width, height)
		arg7 = $_stack_pop(valueStack);
		arg6 = $_stack_pop(valueStack);
		arg5 = $_stack_pop(valueStack);
		arg4 = $_stack_pop(valueStack);
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		image1 = extractImageFromValue(arg1);

		if (image1 == null ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg3.type != Types.INTEGER ||
			Value$arg4.type != Types.INTEGER ||
			Value$arg5.type != Types.INTEGER ||
			Value$arg6.type != Types.INTEGER ||
			Value$arg7.type != Types.INTEGER) {
			return killExecution(stack, "$gfx_blit_image_partial requires an image object and 6 integer arguments.");
		}
		if (%%%IS_OPEN_GL_BASED%%%) {
			glDrawImageAdvanced(
				image1,
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg6.internalValue), // w
				$_cast('int', Value$arg7.internalValue), // h
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue), // w
				$_cast('int', Value$arg7.internalValue)); // h
		} else {
			$_blit_image_partial(
				image1,
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg6.internalValue), // w
				$_cast('int', Value$arg7.internalValue), // h
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue), // w
				$_cast('int', Value$arg7.internalValue)); // h
		}
		break;

	case %%%FF_GFX_BLIT_IMAGE_PARTIAL_AT_SCALE%%%:
		$_comment('$gfx_blit_image_partial_at_scale');
		// $gfx_blit_image_partial_at_scale(image, targetX, targetY, targetWidth, targetHeight, sourceX, sourceY, sourceWidth, sourceHeight)
		arg9 = $_stack_pop(valueStack);
		arg8 = $_stack_pop(valueStack);
		arg7 = $_stack_pop(valueStack);
		arg6 = $_stack_pop(valueStack);
		arg5 = $_stack_pop(valueStack);
		arg4 = $_stack_pop(valueStack);
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		image1 = extractImageFromValue(arg1);
						
		if (image1 == null ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg3.type != Types.INTEGER ||
			Value$arg4.type != Types.INTEGER ||
			Value$arg5.type != Types.INTEGER ||
			Value$arg6.type != Types.INTEGER ||
			Value$arg7.type != Types.INTEGER ||
			Value$arg8.type != Types.INTEGER ||
			Value$arg9.type != Types.INTEGER) {
			return killExecution(stack, "$gfx_blit_image_partial_at_scale requires an image object and 8 integer arguments.");
		}
		if (%%%IS_OPEN_GL_BASED%%%) {
			glDrawImageAdvanced(
				image1,
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue),
				$_cast('int', Value$arg9.internalValue));
		} else {
			$_blit_image_partial(
				image1,
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue),
				$_cast('int', Value$arg9.internalValue));
		}
		break;

	case %%%FF_GFX_DRAW_ELLIPSE%%%:
		$_comment('$gfx_draw_ellipse');
		// $gfx_draw_ellipse(left, top, width, height, red, green, blue, alpha)
		arg8 = $_stack_pop(valueStack);
		arg7 = $_stack_pop(valueStack);
		arg6 = $_stack_pop(valueStack);
		arg5 = $_stack_pop(valueStack);
		arg4 = $_stack_pop(valueStack);
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg3.type != Types.INTEGER ||
			Value$arg4.type != Types.INTEGER ||
			Value$arg5.type != Types.INTEGER ||
			Value$arg6.type != Types.INTEGER ||
			Value$arg7.type != Types.INTEGER ||
			Value$arg8.type != Types.INTEGER) {
			return killExecution(stack, "$draw_ellipse requires 8 integer arguments.");
		}
		if (%%%IS_OPEN_GL_BASED%%%) {
			glDrawEllipse(
				$_cast('int', Value$arg1.internalValue),
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue));
		} else {
			$_draw_ellipse(
				$_cast('int', Value$arg1.internalValue),
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue));
		}
		break;

	case %%%FF_GFX_DRAW_LINE%%%:
		$_comment('$gfx_draw_line');
		// $draw_line(Ax, Ay, Bx, By, lineWidth, red, green, blue, alpha)
		arg9 = $_stack_pop(valueStack);
		arg8 = $_stack_pop(valueStack);
		arg7 = $_stack_pop(valueStack);
		arg6 = $_stack_pop(valueStack);
		arg5 = $_stack_pop(valueStack);
		arg4 = $_stack_pop(valueStack);
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
						
		if (Value$arg1.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg3.type != Types.INTEGER ||
			Value$arg4.type != Types.INTEGER ||
			Value$arg5.type != Types.INTEGER ||
			Value$arg6.type != Types.INTEGER ||
			Value$arg7.type != Types.INTEGER ||
			Value$arg8.type != Types.INTEGER ||
			Value$arg9.type != Types.INTEGER) {
			return killExecution(stack, "$draw_line requires 9 integer arguments.");
		}

		if (%%%IS_OPEN_GL_BASED%%%) {
			glDrawLine(
				$_cast('int', Value$arg1.internalValue),
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue),
				$_cast('int', Value$arg9.internalValue));
		} else {
			$_draw_line(
				$_cast('int', Value$arg1.internalValue),
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue),
				$_cast('int', Value$arg9.internalValue));
		}
		break;

	case %%%FF_GFX_DRAW_RECTANGLE%%%:
		$_comment('$gfx_draw_rectangle');
		// $draw_rectangle(x, y, width, height, red, green, blue, alpha)
		arg8 = $_stack_pop(valueStack);
		arg7 = $_stack_pop(valueStack);
		arg6 = $_stack_pop(valueStack);
		arg5 = $_stack_pop(valueStack);
		arg4 = $_stack_pop(valueStack);
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg3.type != Types.INTEGER ||
			Value$arg4.type != Types.INTEGER ||
			Value$arg5.type != Types.INTEGER ||
			Value$arg6.type != Types.INTEGER ||
			Value$arg7.type != Types.INTEGER ||
			Value$arg8.type != Types.INTEGER) {
			return killExecution(stack, "$draw_rectangle requires 8 integer arguments.");
		}
		if (%%%IS_OPEN_GL_BASED%%%) {
			glDrawRectangle(
				$_cast('int', Value$arg1.internalValue),
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue));
		} else {
			$_draw_rectangle(
				$_cast('int', Value$arg1.internalValue),
				$_cast('int', Value$arg2.internalValue),
				$_cast('int', Value$arg3.internalValue),
				$_cast('int', Value$arg4.internalValue),
				$_cast('int', Value$arg5.internalValue),
				$_cast('int', Value$arg6.internalValue),
				$_cast('int', Value$arg7.internalValue),
				$_cast('int', Value$arg8.internalValue));
		}
		break;

	case %%%FF_GFX_FILL_SCREEN%%%:
		$_comment('$gfx_fill_screen');
		// $fill_screen(red, green, blue)
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.INTEGER ||
			Value$arg2.type != Types.INTEGER ||
			Value$arg3.type != Types.INTEGER) {
			return killExecution(stack, "$fill_screen requires 3 integer arguments.");
		}
		$_fill_screen($_cast('int', Value$arg1.internalValue), $_cast('int', Value$arg2.internalValue), $_cast('int', Value$arg3.internalValue));
		break;

	case %%%FF_GFX_FLIP_IMAGE%%%:
		$_comment('$gfx_flip_image');
		// $flip_image(image, shouldFlipX, shouldFlipY)
		arg3 = $_stack_pop(valueStack);
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		image1 = extractImageFromValue(arg1);
		if (image1 == null) {
			return killExecution(stack, "$flip_image requires an image as its first argument.");
		}
		if (Value$arg2.type != Types.BOOLEAN || Value$arg3.type != Types.BOOLEAN) {
			return killExecution(stack, "$flip_image requires an image and two booleans.");
		}
		output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.IMAGE, flipImage(
			image1,
			$_cast('bool', Value$arg2.internalValue),
			$_cast('bool', Value$arg3.internalValue))));
		break;

	case %%%FF_GFX_IMAGE_ERROR_CODE%%%:
		$_comment('$gfx_image_error_code');
		// $image_error_code(image_key)
		// Error codes:
		// 0 - none (success or pending)
		// 1 - file not found
		// 2 - timed out
		// 3 - invalid format
		// 4 - too big
		// 5 - sprite sheet image not initialized
		// 99 - unknown
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$image_error_code requires a string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		int1 = getImageErrorCode(string1);
		output = buildInteger(int1);
		break;

	case %%%FF_GFX_IMAGE_GET%%%:
		$_comment('$gfx_image_get');
		// $image_get(image_key)
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$image_get requires a string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		object1 = getImageByKey(string1);
		if (object1 == null) {
			return killExecution(stack, "No image with the key '" + string1 + "' has been loaded.");
		}
		output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.IMAGE, object1));
		break;

	case %%%FF_GFX_IMAGE_LOAD_FROM_RESOURCE%%%:
		$_comment('$gfx_image_load_from_resource');
		// $image_load_from_resource(key, path)
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			return killExecution(stack, "$image_load_from_resource requires two string arguments.");
		}
		string1 = $_cast('string', Value$arg2.internalValue);
		int1 = loadImageFromLocalResources($_cast('string', Value$arg1.internalValue), string1);
		if (int1 != 1) {
			if (int1 == 0) {
				return killExecution(stack, "Image resource does not exist: " + string1);
			} else if (int1 == 2) {
				return killExecution(stack, "Image resource was loaded, but it was accessed from an image sheet that was not checked for load completion. Use $gfx_image_sheet_loaded on all image sheets before accessing files from them.");
			}
		}
		break;

	case %%%FF_GFX_IMAGE_LOAD_FROM_WEB%%%:
		$_comment('$gfx_image_load_from_web');
		// $image_load_from_web(key, url)
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			return killExecution(stack, "$image_load_from_web requires two string arguments.");
		}
		string1 = $_cast('string', Value$arg2.internalValue);
		$_download_image($_cast('string', Value$arg1.internalValue), string1);
		break;

	case %%%FF_GFX_IMAGE_LOAD_FROM_USER_DATA%%%:
		$_comment('$gfx_image_load_from_user_data');
		// $image_load_from_user_data(key, path)
		arg2 = $_stack_pop(valueStack);
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			return killExecution(stack, "$image_load_from_user_data requires two string arguments.");
		}
		loadImageFromUserData($_cast('string', Value$arg1.internalValue), $_cast('string', Value$arg2.internalValue));
		break;

	case %%%FF_GFX_IMAGE_POP_SCALE%%%:
		$_comment('$gfx_image_pop_scale');
		// $image_pop_scale()
		intList1 = ProgramData$p.imageScaleStack;
		int1 = $_list_length(intList1);
		if (int1 == 0) {
			return killExecution(stack, "$image_pop_scale() was called but the image scale stack was empty.");
		}
		int2 = $_list_get(intList1, int1 - 1);
		$_list_pop(intList1);
		output = buildInteger(int2);
		if (int1 == 1) {
			int3 = 1;
		} else {
			int3 = $_list_get(intList1, int1 - 2);
		}
		ProgramData$p.imageScaleStackTop = int3;
		break;

	case %%%FF_GFX_IMAGE_PUSH_SCALE%%%:
		$_comment('$gfx_image_push_scale');
		// $image_push_scale(scale)
		intList1 = ProgramData$p.imageScaleStack;
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.INTEGER) {
			if (Value$arg1.type != Types.FLOAT) {
				return killExecution(stack, "$image_push_scale must be called with an integer. Floats are not supported at this time.");
			}
			return killExecution(stack, "$image_push_scale must be called with an integer.");
		}
		int1 = $_cast('int', Value$arg1.internalValue);
		$_list_push(intList1, int1);
		ProgramData$p.imageScaleStackTop = int1;
		break;

	case %%%FF_GFX_IMAGE_SHEET_ERROR_CODE%%%:
		$_comment('$gfx_image_sheet_error_code');
		// $image_sheet_error_code(idOrIds)
		// Error codes: same as $image_error_code
		arg1 = $_stack_pop(valueStack);
		stringList = toStringList(arg1, stringList);
		if (stringList == null) {
			return killExecution(stack, "$image_sheet_error_code argument must either be a string or a list of strings.");
		}
						
		int1 = 0;
		// take the first non-zero entry you find.
		for (i = 0; i < $_array_length(stringList); i += 1) {
			int2 = getSheetErrorCode($_array_get(stringList, i));
			if (int2 > 0) {
				int1 = int2;
				i = $_array_length(stringList);
			}
		}

		output = buildInteger(int1);
		break;

	case %%%FF_GFX_IMAGE_SHEET_LOAD%%%:
		$_comment('$gfx_image_sheet_load');
		// $image_sheet_load(idOrIds)
		arg1 = $_stack_pop(valueStack);
		stringList = toStringList(arg1, stringList);
		if (stringList == null) {
			return killExecution(stack, "$image_sheet_load argument must either be a string or a list of strings.");
		}

		for (i = 0; i < $_array_length(stringList); i += 1) {
			string1 = $_array_get(stringList, i);
			bool1 = loadImageSheet(string1);
			if (!bool1) {
				return killExecution(stack, "'" + string1 + "' was not declared as an image sheet.");
			}
		}
		break;

	case %%%FF_GFX_IMAGE_SHEET_LOAD_PROGRESS%%%:
		$_comment('$gfx_image_sheet_load_progress');
		// $image_sheet_load_progres(idOrIds)
		arg1 = $_stack_pop(valueStack);
		stringList = toStringList(arg1, stringList);
		if (stringList == null) {
			return killExecution(stack, "$image_sheet_load_progress argument must either be a string or a list of strings.");
		}

		int1 = 0; // files loaded
		int2 = 0; // total files to load

		for (i = 0; i < $_array_length(stringList); i += 1) {
			string1 = $_array_get(stringList, i);
			if (getSheetErrorCode(string1) > 0) {
				int2 = 0; // this function should return 1.0
				i += $_array_length(stringList);
			} else {
				int3 = getNumTilesLoaded(string1);
				if (int3 == -1) {
					return killExecution(stack, "'" + string1 + "' is not a valid image sheet.");
				}
				int1 += int3;
				int2 += getNumTiles(string1);
			}
		}

		if (int2 == 0) {
			output = VALUE_FLOAT_ONE;
		} else {
			output = buildFloat($_unsafe_float_division(1.0 * int1, int2));
		}
		break;

	case %%%FF_GFX_IMAGE_SHEET_LOADED%%%:
		$_comment('$gfx_image_sheet_loaded');
		// $image_sheet_loaded(idOrIds)
		arg1 = $_stack_pop(valueStack);
		bool1 = false; // type error encountered
		int1 = 1; // 0 - not done, 1 - success, 2 - failure, this variable is a BIT MASK
		if (Value$arg1.type == Types.LIST) {
			for (i = 0; i < $_list_length(list1); i += 1) {
				value = $_list_get(list1, i);
				if (Value$value.type != Types.STRING) {
					bool1 = true;
					i = $_list_length(list1);
				} else {
					int2 = isImageSheetLoaded($_cast('string', Value$value.internalValue));
					if (int2 == 2) {
						return killExecution(stack, "$gfx_image_sheet_loaded cannot be called on sheet ID's that have not been loaded yet.");
					}

					int1 &= int2;
				}
			}
		} else if (Value$arg1.type == Types.STRING) {
			int1 = isImageSheetLoaded($_cast('string', Value$arg1.internalValue));
		} else {
			bool1 = true;
		}

		if (bool1) {
			return killExecution(stack, "$image_sheet_load arguments must either be a string or a list of strings.");
		}

		if (int1 == 0) {
			output = VALUE_FALSE;
		} else if (int1 == 1) {
			output = VALUE_TRUE;
		} else { // int1 == 2 || int1 == 3
			return killExecution(stack, "$gfx_image_sheet_loaded cannot be called on sheet ID's that have not been loaded yet.");
		}
		break;

	case %%%FF_GFX_IS_IMAGE_LOADED%%%:
		$_comment('$gfx_is_image_loaded');
		// $image_loaded(image_key)
		arg1 = $_stack_pop(valueStack);
		int1 = isImageLoaded($_cast('string', Value$arg1.internalValue));
		if (int1 == 0) {
			return killExecution(stack, "$gfx_is_image_loaded cannot be called on keys where loading has not been initialized.");
		} else if (int1 == 1) {
			output = VALUE_TRUE;
		} else { // int1 == 2
			output = VALUE_FALSE;
		}
		break;

	case %%%FF_HTTP_REQUEST%%%:
		$_comment('$http_request');
		arg4 = $_stack_pop(valueStack); // body
		arg3 = $_stack_pop(valueStack); // http headers
		arg2 = $_stack_pop(valueStack); // URL
		arg1 = $_stack_pop(valueStack); // Method
		bool1 = true;
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			bool1 = false;
		} else if (Value$arg3.type != Types.DICTIONARY && Value$arg3.type != Types.NULL) {
			bool1 = false;
		} else if (Value$arg4.type != Types.STRING && Value$arg4.type != Types.NULL) {
			bool1 = false;
		}
		
		/*
			The headers string-to-string|list dictionary will be flattened to the following two single-dimensional lists.
			The string list is a list of all the headers immediately followed by 1 or more header values. Note that headers
			can be repeated, like Set-Cookie.
			The int list is a list of how many header values are included for each header.
			For example:
			{ 
				'User-Agent': "MyGame/v1.0",
				'Set-Cookie': ["Cookie1", "Cookie2"]
			}
			Gets flattened to:
				intList = [1, 2]
				stringList = ['User-Agent', 'MyGame/v1.0', 'Set-Cookie', 'Cookie1', 'Cookie2']
			Types are also verified by this code with appropriate error messages thrown.
		*/
		intList1 = $_new_list('int');
		stringList1 = $_new_list('string');
		
		if (Value$arg3.type == Types.DICTIONARY) {
			// TODO: iterate through dictionary and verify string contents
			dictImpl = $_cast('DictImpl', Value$arg3.internalValue);
			if (DictImpl$dictImpl.size > 0) {
				if (DictImpl$dictImpl.keyType != Types.STRING) {
					return killExecution(stack, "HTTP Headers must be a dictionary keyed from strings");
				}
				stringList = $_dictionary_get_keys('string', DictImpl$dictImpl.valueStringLookup);
				for (int1 = 0; int1 < $_array_length(stringList); int1 += 1) {
					string1 = $_array_get(stringList, int1); // Header name
					$_list_push(stringList1, string1);
					value = $_dictionary_get_guaranteed(DictImpl$dictImpl.valueStringLookup, string1);
					if (Value$value.type == Types.STRING) {
						$_list_push(intList1, 1);
						$_list_push(stringList1, $_cast('string', Value$value.internalValue));
					} else if (Value$value.type == Types.LIST) {
						list1 = $_cast('List<Value>', Value$value.internalValue);
						$_list_push(intList1, $_list_length(list1));
						for (int2 = 0; int2 < $_list_length(list1); int2 += 1) {
							value2 = $_list_get(list1, int2);
							$_list_push(stringList1, $_cast('string', Value$value2.internalValue));
						}
					} else {
						return killExecution(stack, "The values of an HTTP headers dictionary must be strings or, for repeated headers, a list of strings");
					}
				}
			}
		}

		if (!bool1) {
			return killExecution(stack, "Invalid arguments. $http_request's arguments require 2 strings, a dictionary, and a string.");
		}
		string1 = $_cast('string', Value$arg1.internalValue); // method
		string2 = $_cast('string', Value$arg2.internalValue); // url
		string3 = $_cast('string', Value$arg4.internalValue); // body

		output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.HTTP_REQUEST, makeHttpRequest(string1, string2, string3, intList1, stringList1, stringOutParam)));

		if ($_array_get(stringOutParam, 0) != null) {
			return killExecution(stack, "Error while making HTTP request: " + $_array_get(stringOutParam, 0));
		}
		break;

	case %%%FF_IO_CURRENT_DIRECTORY%%%:
		$_comment('$io_current_directory');
		output = buildString($_io_current_directory());
		break;

	case %%%FF_IO_DIRECTORY_LISTING%%%:
		$_comment('$io_directory_list');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$io_directory_list requires a string argument.");
		}
		list1 = $_new_list('Value');
		int1 = ioListDir($_cast('string', Value$arg1.internalValue), false, false, list1, stringOutParam);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$io_directory_list: " + ioErrorToString(int1));
		}
		output = buildListByWrappingInput(list1);
		break;

	case %%%FF_IO_FILE_READ_TEXT%%%:
		$_comment('$io_file_read_text');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$io_file_read_text requires 1 string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue); // path
		int1 = ioReadFileText($_cast('string', Value$arg1.internalValue), false, false, stringOutParam);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$io_file_read_text: " + ioErrorToString(int1));
		}
		output = buildString($_array_get(stringOutParam, 0));
		break;

	case %%%FF_IO_FILE_WRITE_TEXT%%%:
		$_comment('$io_file_write_text');
		arg2 = $_stack_pop(valueStack); // contents
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			return killExecution(stack, "$io_file_write_text requires 2 string arguments.");
		}
		int1 = ioWriteFileText(
			$_cast('string', Value$arg1.internalValue), $_cast('string', Value$arg2.internalValue),
			false, false, stringOutParam);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$io_file_write_text: " + ioErrorToString(int1));
		}
		break;

	case %%%FF_IO_IS_PATH_DIRECTORY%%%:
		$_comment('$io_is_path_directory');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$io_is_path_directory requires a string argument.");
		}
		bool1 = ioCheckPathExistence($_cast('string', Value$arg1.internalValue), false, false, true, stringOutParam);
		if (bool1) {
			output = VALUE_TRUE;
		} else {
			output = VALUE_FALSE;
		}
		break;

	case %%%FF_IO_PATH_EXISTS%%%:
		$_comment('$io_path_exists');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$io_path_exists requires a string argument.");
		}
		bool1 = ioCheckPathExistence($_cast('string', Value$arg1.internalValue), false, false, false, stringOutParam);
		if (bool1) {
			output = VALUE_TRUE;
		} else {
			output = VALUE_FALSE;
		}
		break;

	case %%%FF_IO_PATH_JOIN%%%:
		$_comment('$io_path_join');
		arg1 = $_stack_pop(valueStack);
		bool1 = true;
		list1 = null;
		// generally the number of string components in a path join command are < 5
		// and most commonly just 2. Just iteratively concatenate a string for conciseness.
		// It's okay.
		string1 = ""; 
		// TODO: accept a variable number of string args.
		if (Value$arg1.type != Types.LIST) {
			bool1 = false;
		} else {
			list1 = $_cast('List<Value>', Value$arg1.internalValue);
			string2 = "/";
			if ($_is_windows_program()) {
				string2 = "\\";
			}
			for (i = 0; i < $_list_length(list1); i += 1) {
				value = $_list_get(list1, i);
				if (Value$value.type != Types.STRING) {
					bool1 = false;
					/* break; */ i = $_list_length(list1); // break isn't supported in translate mode.
				} else {
					if (i == 0) {
						string1 += $_cast('string', Value$value.internalValue);
					} else {
						string1 += string2 + $_cast('string', Value$value.internalValue);
					}
				}
			}
		}
		if (!bool1) {
			return killExecution(stack, "$io_path_join requires a list of strings as input.");
		}
		output = buildString(string1);
		break;

	case %%%FF_ORD%%%:
		$_comment('$ord');
		arg1 = $_stack_pop(valueStack);
		output = null;
		if (Value$arg1.type == Types.STRING) {
			string1 = $_cast('string', Value$arg1.internalValue);
			if ($_string_length(string1) == 1) {
				output = buildInteger($_ord(string1));
			}
		}
		if (output == null) {
			return killExecution(stack, "$ord requires a 1 character string.");
		}
		break;

	case %%%FF_PARSE_FLOAT%%%:
		$_comment('$parse_float');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$parse_float requires a string argument.");
		}
		string1 = $_string_trim($_force_parens($_cast('string', Value$arg1.internalValue)));
		$_parse_float(floatList1, string1);
		if ($_array_get(floatList1, 0) < 0) {
			output = VALUE_NULL;
		} else {
			output = buildFloat($_array_get(floatList1, 1));
		}
		break;

	case %%%FF_PARSE_INT%%%:
		$_comment('$parse_int');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$parse_int requires a string argument.");
		}
		string1 = $_string_trim($_force_parens($_cast('string', Value$arg1.internalValue)));
		if ($_is_valid_integer(string1)) {
			output = buildInteger($_parse_int(string1));
		} else {
			output = VALUE_NULL;
		}
		break;

	case %%%FF_PARSE_JSON%%%:
		$_comment('$parse_json');
		// TODO: when you add ability to add optional arguments, add a boolean for failing silently.
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$parse_json requires a string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		bool1 = true; // is error
		if ($_string_length(string1) > 0) {
			output = $_parse_json(string1);
			if (output != null) {
				bool1 = false;
			}
		}
		if (bool1) {
			return killExecution(stack, "Attempted to parse an invalid JSON string.");
		}
		break;

	case %%%FF_PRINT%%%:
		$_comment('$print');
		arg1 = $_stack_pop(valueStack);
		string1 = valueToString(arg1);
		$_print(string1);
		break;

	case %%%FF_RANDOM%%%:
		$_comment('$random');
		output = buildFloat($_random_float());
		break;

	case %%%FF_RESOURCE_READ_TEXT%%%:
		$_comment('$resource_read_text');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$resource_read_text requires a string path parameter.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		// TODO: verify string1 is a well-formed path without '..'
		string2 = $_resource_read_text_file(string1);
		if (string2 == null) {
			return killExecution(stack, "Resource file not found: '" + string1 + "'");
		}
		output = new Value(Types.STRING, string2);
		break;

	case %%%FF_SFX_GET_SOUND%%%:
		$_comment('$sfx_get_sound');
		arg1 = $_stack_pop(valueStack); // key
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$sfx_get_sound requires a string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		sound1 = getLoadedSound(string1);
		if (sound1 == null) {
			return killExecution(stack, "No sound has been loaded with the key: '" + string1 + "'.");
		}
		output = new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.SOUND, sound1));
		break;

	case %%%FF_SFX_IS_SOUND_LOADED%%%:
		$_comment('$sfx_is_sound_loaded');
		arg1 = $_stack_pop(valueStack); // key
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$sfx_is_sound_loaded requires a string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		int1 = isSoundLoaded(string1);
		if (int1 == 2) {
			output = VALUE_TRUE;
		} else if (int1 == 0) {
			output = VALUE_FALSE;
		} else if (int1 == 1) {
			return killExecution(stack, "$sfx_is_sound_loaded cannot be called on a key that hasn't been initialized.");
		}
		break;

	case %%%FF_SFX_LOAD_SOUND_FROM_RESOURCE%%%:
		$_comment('$sfx_load_sound_from_resource');
		arg2 = $_stack_pop(valueStack); // path
		arg1 = $_stack_pop(valueStack); // key
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			return killExecution(stack, "$sfx_load_sound_from_resource requires two string parameters.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		string2 = $_cast('string', Value$arg2.internalValue);
		bool1 = loadSoundFromResource(string1, string2); // file exists
		if (!bool1) {
			return killExecution(stack, "The file '" + string2 + "' does not exist in the resources.");
		}
		break;

	case %%%FF_SFX_PLAY_SOUND%%%:
		$_comment('$sfx_play_sound');
		arg1 = $_stack_pop(valueStack); // native sound object.
		sound1 = null;
		if (Value$arg1.type == Types.NATIVE_OBJECT) {
			nativeObject = $_cast('NativeObjectWrapper', Value$arg1.internalValue);
			if (NativeObjectWrapper$nativeObject.subType == NativeObjectSubType.SOUND) {
				sound1 = $_cast('SoundInstance', NativeObjectWrapper$nativeObject.value);
			}
		}

		if (sound1 == null) {
			return killExecution(stack, "$sfx_play_sound requires a sound instance as its argument.");
		}

		playSound(sound1);
		break;

	case %%%FF_SIN%%%:
		$_comment('$sin');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			output = buildFloat($_sin(float1));
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			output = buildFloat($_sin(int1));
		} else {
			return killExecution(stack, "$sin requires a number argument.");
		}
		break;

	case %%%FF_TAN%%%:
		$_comment('$tan');
		arg1 = $_stack_pop(valueStack);
		// I do not check for arg1 == pi/2 because the float arithmetic
		// never produces a true pi/2. The closest a 64 bit floating point number can get
		// to pi/2 produces 16331239353195370. 
		if (Value$arg1.type == Types.FLOAT) {
			float1 = $_cast('double', Value$arg1.internalValue);
			output = buildFloat($_tan(float1));
		} else if (Value$arg1.type == Types.INTEGER) {
			int1 = $_cast('int', Value$arg1.internalValue);
			output = buildFloat($_tan(int1));
		} else {
			return killExecution(stack, "$tan requires a number argument.");
		}
		break;

	case %%%FF_TYPEOF%%%:
		$_comment('$typeof');
		arg1 = $_stack_pop(valueStack);

		switch (Value$arg1.type) {
			case Types.NULL: string1 = "null"; break;
			case Types.INTEGER: string1 = "integer"; break;
			case Types.FLOAT: string1 = "float"; break;
			case Types.STRING: string1 = "string"; break;
			case Types.LIST: string1 = "list"; break;
			case Types.DICTIONARY: string1 = "dictionary"; break;
			case Types.INSTANCE: string1 = "instance"; break;
			case Types.FUNCTION: string1 = "function"; break;
			case Types.METHOD: string1 = "method"; break;
			case Types.SYS_METHOD: string1 = "primitive_method"; break;
			case Types.NATIVE_OBJECT: string1 = "native_system_object"; break;
			default: string1 = "unknown_type"; break;
		}
		output = buildCommonString(string1);
		break;

	case %%%FF_USER_DATA_DELETE_DIRECTORY%%%:
		$_comment('$user_data_delete_directory');
		arg2 = $_stack_pop(valueStack); // recursive delete (folder is non-empty)
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.BOOLEAN) {
			return killExecution(stack, "$user_data_delete_directory requires a string and a bool argument.");
		}

		int1 = ioDeleteDirectory(
			$_cast('string', Value$arg1.internalValue),
			true, // strict path
			true,
			$_cast('bool', Value$arg2.internalValue),
			stringOutParam);

		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$user_data_delete_directory: " + ioErrorToString(int1));
		}

		break;

	case %%%FF_USER_DATA_DELETE_FILE%%%:
		$_comment('$user_data_delete_file');
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$user_data_delete_file requires a string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		int1 = ioDeleteFile(string1, true, true, stringOutParam);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$user_data_delete_file: " + ioErrorToString(int1));
		}
		break;

	case %%%FF_USER_DATA_DIRECTORY_LISTING%%%:
		$_comment('$user_data_directory_listing');
		arg1 = $_stack_pop(valueStack);
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$user_data_directory_listing requires a string argument.");
		}
		list1 = $_new_list('Value');
		string1 = $_cast('string', Value$arg1.internalValue);
		int1 = ioListDir(string1,
			false, // strictPath
			true, // isUserData
			list1,
			stringOutParam);
		if (int1 != IOErrors.NONE) {
			bool1 = true;
			if (int1 == IOErrors.DOES_NOT_EXIST) {
				int1 = ioPathFixer(
					string1,
					stringOutParam,
					false, // valid char check
					true, // is user data
					false, // require full path to exist
					true, // require parent path to exist
					false, // ensure parent path exists
					true); // enforce case sensitivity
				
				if ($_is_javascript()) {
					if (int1 == IOErrors.NONE && $_string_length($_array_get(stringOutParam, 0)) == 0) {
						bool1 = false;
					}
				} else {
					if ($_string_equals($_app_data_root(), $_array_get(stringOutParam, 0))) {
						bool1 = false;
					}
				}
			}
			if (bool1) {
				return killExecution(stack, "$user_data_directory_listing: " + ioErrorToString(int1));
			}
		}
		output = buildListByWrappingInput(list1);
		break;

	case %%%FF_USER_DATA_FILE_READ_TEXT%%%:
		$_comment('$user_data_file_read_text');
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$user_data_file_read_text requires 1 string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue); // path
		int1 = ioReadFileText($_cast('string', Value$arg1.internalValue), true, false, stringOutParam);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$user_data_file_read_text: " + ioErrorToString(int1));
		}
		output = buildString($_array_get(stringOutParam, 0));
		break;

	case %%%FF_USER_DATA_FILE_WRITE_TEXT%%%:
		$_comment('$user_data_file_write_text');
		arg2 = $_stack_pop(valueStack); // content
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING || Value$arg2.type != Types.STRING) {
			return killExecution(stack, "$user_data_file_write_text requires 2 string arguments.");
		}
		int1 = ioWriteFileText(
			$_cast('string', Value$arg1.internalValue), $_cast('string', Value$arg2.internalValue),
			true, false, stringOutParam);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$user_data_file_write_text: " + ioErrorToString(int1));
		}
		break;

	case %%%FF_USER_DATA_IS_PATH_DIRECTORY%%%:
		$_comment('$user_data_is_path_directory');
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$user_data_is_path_directory requires 1 string argument.");
		}
		bool1 = ioCheckPathExistence($_cast('string', Value$arg1.internalValue), false, true, true, stringOutParam);
		if (bool1) {
			output = VALUE_TRUE;
		} else {
			output = VALUE_FALSE;
		}
		break;

	case %%%FF_USER_DATA_MAKE_DIRECTORY%%%:
		$_comment('$user_data_make_directory');
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$user_data_make_directory requires 1 string argument.");
		}
		string1 = $_cast('string', Value$arg1.internalValue);
		if (!$_io_does_path_exist($_app_data_root(), true, true, true)) {
			int1 = $_io_create_directory($_app_data_root());
			if (int1 != IOErrors.NONE) {
				return killExecution(stack, "Could not create user data folder: " + ioErrorToString(int1));
			}
		}
		int1 = ioPathFixer(
			string1, // path
			stringOutParam,
			true, // valid char check
			true, // is user data
			false, // require full path to exist
			true, // require parent path to exist
			true, // ensure parent path exists
			true); // enforce case sensitivity
						
		string1 = $_array_get(stringOutParam, 0);
		if ($_is_windows_program()) {
			string1 = $_string_replace(string1, '/', '\\');
		}
		int1 = $_io_create_directory(string1);
		if (int1 != IOErrors.NONE) {
			return killExecution(stack, "$user_data_make_directory: " + ioErrorToString(int1));
		}
		break;

	case %%%FF_USER_DATA_PATH_EXISTS%%%:
		$_comment('$user_data_path_exists');
		arg1 = $_stack_pop(valueStack); // path
		if (Value$arg1.type != Types.STRING) {
			return killExecution(stack, "$user_data_path_exists requires 1 string argument.");
		}
		bool1 = ioCheckPathExistence($_cast('string', Value$arg1.internalValue), false, true, false, stringOutParam);
		if (bool1) {
			output = VALUE_TRUE;
		} else {
			output = VALUE_FALSE;
		}
		break;

	default:
		return killExecution(stack, "Invalid framework function: " + $_string_cast_weak($_array_get(row, 0))); 
		break;
}
if ($_array_get(row, 1) == 1) {
	$_stack_push(valueStack, output);
}
