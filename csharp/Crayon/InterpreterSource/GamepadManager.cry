
function @type('GamepadStatus') gamepadGetGlobalStatus() {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('ProgramData') p = $_get_program_data();
		return ProgramData$p.gamepadStatus;
	} else {
		return null;
	}
}

function @type('string') gamepadGenerateFingerprint(
		@type('string') deviceName,
		@type('int') analogAxisCount,
		@type('int') digital2dAxisCount,
		@type('int') buttonCount) {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		deviceName = $_string_trim(deviceName);
		@type('string') output = ""; // happens once on relatively small strings so string-build-by-concatenation is ok.
		@type('string') hex = '0123456789ABCDEF';
		for (@type('int') i = 0; i < $_string_length(deviceName); i += 1) {
			@type('int') byte = $_ord($_force_parens("" + $_string_char_at(deviceName, i)));
			@type('int') a = (byte >> 4) & 15;
			@type('int') b = byte & 15;
			output += $_string_char_at(hex, a) + $_string_char_at(hex, b);
		}
		output += "-" + $_string_cast_weak(analogAxisCount) + "-" + $_string_cast_weak(digital2dAxisCount) + "-" + $_string_cast_weak(buttonCount);
		return output;
	} else {
		return "";
	}
}

/*
	This is invoked directly after the game window has been initialized.
	Output not used.
*/
function @type('bool') gamepadInitializeState() {

	@type('GamepadStatus') status = gamepadGetGlobalStatus();

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('bool') isInitialized = GamepadStatus$status.isInitialized;
		if (isInitialized) {
			return false;
		}

		@type('List<GamepadDeviceInfo>') deviceList = GamepadStatus$status.devices;
		@type('List<Value>') deviceValueList = GamepadStatus$status.deviceValues;

		@type('GamepadHardwarePushy') hardwarePushy = null;
		@type('List<GamepadHardwarePushy>') hardwarePushies = GamepadStatus$status.hardwarePushies;
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;

		@type('int') index = 0;
		@type('int') deviceCount = $_gamepad_get_device_count();
		for (@type('int') deviceIndex = 0; deviceIndex < deviceCount; deviceIndex += 1) {

			// TODO: just combine these two into a $_gamepad_get_initialized_device(deviceIndex)
			@type('object') nativeDevice = $_gamepad_get_device(deviceIndex);
			$_gamepad_initialize(nativeDevice, deviceIndex);

			@type('string') deviceName = $_gamepad_get_device_name(nativeDevice, deviceIndex);
			@type('int') analogAxisCount = $_gamepad_get_analog_axis_count(nativeDevice, deviceIndex);
			@type('int') digital2dAxisCount = $_gamepad_get_2d_digital_axis_count(nativeDevice, deviceIndex);
			@type('int') buttonCount = $_gamepad_get_button_count(nativeDevice, deviceIndex);
			@type('string') deviceFingerprint = gamepadGenerateFingerprint(deviceName, analogAxisCount, digital2dAxisCount, buttonCount);

			@type('GamepadDeviceInfo') deviceInfo = new GamepadDeviceInfo(
				deviceIndex,
				nativeDevice,
				deviceName,
				deviceFingerprint, // config fingerprint

				null, // player ID

				analogAxisCount, // analog axis count
				digital2dAxisCount, // digital axis count
				buttonCount, // button count

				0, // hardware pushy start index
				0, // hardware pushy count
				0, // atomic pushy start index
				0, // atomic pushy count

				$_new_dictionary('string', 'GamepadVirtualPushy'),
				$_new_dictionary('int', 'GamepadVirtualPushy'),
				$_new_list('string'),
				$_new_list('int')
				);
			$_list_push(deviceList, deviceInfo);
			$_list_push(deviceValueList, 
				new Value(Types.NATIVE_OBJECT, new NativeObjectWrapper(NativeObjectSubType.GAMEPAD_DEVICE, deviceInfo)));

			@type('int') i = 0;

			@type('int') hardwarePushyStartLength = $_list_length(hardwarePushies);
			@type('int') atomicPushyStartLength = $_list_length(atomicPushies);

			for (i = 0; i < buttonCount; i += 1) {
				hardwarePushy = new GamepadHardwarePushy(
					deviceIndex,
					0, // is button
					i, // hardware index
					false, 0.0, 0, 0, // starting state
					0, 0, 0, 0, 0, 0, 0); // game counters
		
				index = $_list_length(hardwarePushies);
				$_list_push(hardwarePushies, hardwarePushy);
		
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 0, false, 0.0, 0, "B:" + $_string_cast_weak(i), false));
			}

			for (i = 0; i < analogAxisCount; i += 1) {
				hardwarePushy = new GamepadHardwarePushy(
					deviceIndex,
					1, // is analog axis
					i, // hardware index
					false, 0.0, 0, 0, // starting state
					0, 0, 0, 0, 0, 0, 0); // game counters
		
				index = $_list_length(hardwarePushies);
				$_list_push(hardwarePushies, hardwarePushy);
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 1, false, 0.0, 0, "A:" + $_string_cast_weak(i) + ":1", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 2, false, 0.0, 0, "A:" + $_string_cast_weak(i) + ":0", false));
			}
	
			for (i = 0; i < digital2dAxisCount; i += 1) {
				hardwarePushy = new GamepadHardwarePushy(
					deviceIndex,
					2, // is analog axis
					i, // hardware index
					false, 0.0, 0, 0, // starting state
					0, 0, 0, 0, 0, 0, 0); // game counters
		
				index = $_list_length(hardwarePushies);
				$_list_push(hardwarePushies, hardwarePushy);
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 3, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":X:1", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 4, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":X:0", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 5, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":Y:1", false));
				$_list_push(atomicPushies, new GamepadAtomicPushy(index, 6, false, 0.0, 0, "D:" + $_string_cast_weak(i) + ":Y:0", false));
			}
	
			@type('int') hardwarePushyEndLength = $_list_length(hardwarePushies);
			@type('int') atomicPushyEndLength = $_list_length(atomicPushies);

			GamepadDeviceInfo$deviceInfo.hardwarePushyStartIndex = hardwarePushyStartLength;
			GamepadDeviceInfo$deviceInfo.hardwarePushyCount = hardwarePushyEndLength - hardwarePushyStartLength;
			GamepadDeviceInfo$deviceInfo.atomicPushyStartIndex = atomicPushyStartLength;
			GamepadDeviceInfo$deviceInfo.atomicPushyCount = atomicPushyEndLength - atomicPushyStartLength;
		}
	}

	GamepadStatus$status.isInitialized = true;
	return true;
}

/*
	Set an ID on a gamepad device (or clear it if null is passed in)
	If a non-null ID is already set 
	Error codes:
	0 - no error
	1 - not a device
	2 - bad ID
*/
function @type('int') gamepadSetId(@type('Value') deviceValue, @type('Value') idValue) {
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadDeviceInfo') device = $_cast('GamepadDeviceInfo', extractNativeObjectOfType(deviceValue, NativeObjectSubType.GAMEPAD_DEVICE));
		if (device == null) {
			return 1;
		}
		if (idValue == null || Value$idValue.type == Types.NULL) {
			GamepadDeviceInfo$device.playerId = null;
			return 0;
		}
		if (Value$idValue.type != Types.INTEGER && Value$idValue.type != Types.STRING) {
			return 2;
		}

		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		
		@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
		
		for (@type('int') i = 0; i < $_list_length(devices); i += 1) {
			@type('GamepadDeviceInfo') otherDevice = $_list_get(devices, i);
			@type('Value') otherId = GamepadDeviceInfo$otherDevice.playerId;
			if (otherId != null && Value$otherId.type == Value$idValue.type) {
				if (Value$idValue.type == Types.INTEGER) {
					if ($_cast('int', Value$idValue.internalValue) == $_cast('int', Value$otherId.internalValue)) {
						GamepadDeviceInfo$otherDevice.playerId = null;
					}
				} else { // Types.STRING
					if ($_string_equals($_cast('string', Value$idValue.internalValue), $_cast('string', Value$otherId.internalValue))) {
						GamepadDeviceInfo$otherDevice.playerId = null;
					}
				}
			}
		}

		GamepadDeviceInfo$device.playerId = idValue;

		return 0;
	} else {
		return 1;
	}
}

function @type('bool') gamepadClearIds() {
	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	@type('bool') isInitialized = GamepadStatus$status.isInitialized;
	if (!isInitialized) {
		return false;
	}

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
		for (@type('int') i = 0; i < $_list_length(devices); i += 1) {
			@type('GamepadDeviceInfo') device = $_list_get(devices, i);
			GamepadDeviceInfo$device.playerId = null;
		}
	}

	return true;
}

/*
	Status codes:
	0 - not bound
	1 - bound
	2 - device invalid
	3 - descriptor invalid
	4 - alias isn't suitable type
	5 - direction invalid
	6 - sign invalid

	Valid descriptor strings:
	B:# -- button #
	A:#:0|1 -- analog axis # in the 0-negative/1-positive direction
	D:#:X|Y:0|1 -- digital axis # along the X/Y axis in the 0-neg/1-pos direction

	If this particular descriptor is already used, then the pushy must not be bound and 0 returned.
	If this user action is already bound, then that's okay as this will automatically overwrite that.
*/
function @type('int') gamepadBind(
	@type('Value') deviceValue,
	@type('Value') descriptorValue,
	@type('Value') alias,
	@type('int') dimensionality,
	@type('Value') isXValue,
	@type('Value') isPositiveValue,
	@type('bool') isDigital) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadDeviceInfo') device = $_cast('GamepadDeviceInfo', extractNativeObjectOfType(deviceValue, NativeObjectSubType.GAMEPAD_DEVICE));
		if (device == null) {
			return 2;
		}
		if (Value$descriptorValue.type != Types.STRING) return 3;
		@type('string') descriptor = $_cast('string', Value$descriptorValue.internalValue);

		// Look through atomic pushies for the one with the same descriptor ID.
		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		@type('int') atomicPushyStartIndex = GamepadDeviceInfo$device.atomicPushyStartIndex;
		@type('int') atomicPushyEndIndex = atomicPushyStartIndex + GamepadDeviceInfo$device.atomicPushyCount;
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;
		@type('GamepadAtomicPushy') atomicPushy = null;
		@type('int') atomicPushyFoundIndex = -1;
		for (@type('int') i = atomicPushyStartIndex; i < atomicPushyEndIndex; i += 1) {
			@type('GamepadAtomicPushy') atomicPushyIterator = $_list_get(atomicPushies, i);
			if ($_string_equals(GamepadAtomicPushy$atomicPushyIterator.descriptorId, descriptor)) {
				atomicPushy = atomicPushyIterator;
				atomicPushyFoundIndex = i;
				i = atomicPushyEndIndex; // break;
			}
		}
		if (atomicPushy == null) {
			return 3;
		}

		if (GamepadAtomicPushy$atomicPushy.isConfigured) {
			return 0; // Pushy already in use. Don't double-configure.
		}
		GamepadAtomicPushy$atomicPushy.isConfigured = true;

		@type('GamepadVirtualPushy') virtualPushy = null;
		if (Value$alias.type == Types.INTEGER) {
			@type('int') virtualIdInt = $_cast('int', Value$alias.internalValue);
			if ($_dictionary_contains(GamepadDeviceInfo$device.intVirtualPushies, virtualIdInt)) {
				virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.intVirtualPushies, virtualIdInt);
			} else {
				virtualPushy = new GamepadVirtualPushy(buildInteger(virtualIdInt), dimensionality, false, -1, -1, -1, -1, -1);
				$_dictionary_set(GamepadDeviceInfo$device.intVirtualPushies, virtualIdInt, virtualPushy);
				$_list_push(GamepadDeviceInfo$device.intVirtualPushyIds, virtualIdInt);
			}
		} else if (Value$alias.type == Types.STRING) {
			@type('string') virtualIdString = $_cast('string', Value$alias.internalValue);
			if ($_dictionary_contains(GamepadDeviceInfo$device.stringVirtualPushies, virtualIdString)) {
				virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.stringVirtualPushies, virtualIdString);
			} else {
				virtualPushy = new GamepadVirtualPushy(buildString(virtualIdString), dimensionality, false, -1, -1, -1, -1, -1);
				$_dictionary_set(GamepadDeviceInfo$device.stringVirtualPushies, virtualIdString, virtualPushy);
				$_list_push(GamepadDeviceInfo$device.stringVirtualPushyIds, virtualIdString);
			}
		} else {
			return 4;
		}

		// Overwrite any previous digital vs analog value with latest.
		GamepadVirtualPushy$virtualPushy.isDigital = isDigital;

		@type('bool') isX = false;
		@type('bool') isPositive = false;
		if (isXValue != null) {
			if (Value$isXValue.type != Types.BOOLEAN) return 6;
			isX = $_cast('bool', Value$isXValue.internalValue);
		}

		if (isPositiveValue != null) {
			if (Value$isPositiveValue.type != Types.BOOLEAN) return 5;
			isPositive = $_cast('bool', Value$isPositiveValue.internalValue);
		}

		@type('int') bumpedIndex = -1;

		if (dimensionality == 0) {
			bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
			GamepadVirtualPushy$virtualPushy.atomicIndex1 = atomicPushyFoundIndex;
		} else if (dimensionality == 1) {
			if (isPositive) {
				bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
				GamepadVirtualPushy$virtualPushy.atomicIndex1 = atomicPushyFoundIndex;
			} else {
				bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex2;
				GamepadVirtualPushy$virtualPushy.atomicIndex2 = atomicPushyFoundIndex;
			}
		} else { // dimensionality == 2
			if (isX) {
				if (isPositive) {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
					GamepadVirtualPushy$virtualPushy.atomicIndex1 = atomicPushyFoundIndex;
				} else {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex2;
					GamepadVirtualPushy$virtualPushy.atomicIndex2 = atomicPushyFoundIndex;
				}
			} else {
				if (isPositive) {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex3;
					GamepadVirtualPushy$virtualPushy.atomicIndex3 = atomicPushyFoundIndex;
				} else {
					bumpedIndex = GamepadVirtualPushy$virtualPushy.atomicIndex4;
					GamepadVirtualPushy$virtualPushy.atomicIndex4 = atomicPushyFoundIndex;
				}
			}
		}

		// if you bumped another atomic pushy that was previously configured, then you need to notate it
		// in the atomic pushy value.
		if (bumpedIndex != -1) {
			atomicPushy = $_list_get(atomicPushies, bumpedIndex);
			GamepadAtomicPushy$atomicPushy.isConfigured = false;
		}

		return 1;
	} else {
		return 2;
	}
}

function @type('bool') gamepadPollBeginFrame() {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('ProgramData') programData = $_get_program_data();
		@type('int') gameCounter = ProgramData$programData.gameCounter;
		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		$_list_clear(GamepadStatus$status.hardwareEvents);

		if (!GamepadStatus$status.isInitialized) {
			return true;
		}

		$_gamepad_poll();

		@type('List<GamepadDeviceInfo>') devices = GamepadStatus$status.devices;
		@type('List<GamepadHardwarePushy>') hardwarePushies = GamepadStatus$status.hardwarePushies;
		@type('List<GamepadAtomicPushy>') atomicPushies = GamepadStatus$status.atomicPushies;
		@type('GamepadHardwarePushy') hardwarePushy = null;
		@type('GamepadAtomicPushy') atomicPushy = null;
		@type('int') j = 0;
		@type('int') pushyType = 0;
		@type('int') pushySubType = 0;
		@type('int') hardwareIndex = 0;

		@type('bool') oldPushed = false;
		@type('bool') newPushed = false;
		@type('double') oldAxis = 0.0;
		@type('double') newAxis = 0.0;
		@type('double') axisDiff = 0.0;
		@type('int') oldX = 0;
		@type('int') newX = 0;
		@type('int') oldY = 0;
		@type('int') newY = 0;
		@type('Array<int>') xy = null;

		@type('Value') devicePlayerId = null;

		for (@type('int') i = 0; i < $_list_length(devices); i += 1) {
			@type('GamepadDeviceInfo') device = $_list_get(devices, i);
			if (GamepadDeviceInfo$device.playerId != null) {
				
				// First pass: update the hardware pushies.
				@type('int') pushyStart = GamepadDeviceInfo$device.hardwarePushyStartIndex;
				@type('int') pushyEnd = pushyStart + GamepadDeviceInfo$device.hardwarePushyCount;
				for (j = pushyStart; j < pushyEnd; j += 1) {
					hardwarePushy = $_list_get(hardwarePushies, j);
					pushyType = GamepadHardwarePushy$hardwarePushy.type;
					hardwareIndex = GamepadHardwarePushy$hardwarePushy.hardwareIndex;
					if (pushyType == 0) {
						// Button
						oldPushed = GamepadHardwarePushy$hardwarePushy.buttonValue;
						newPushed = $_gamepad_get_button_value(GamepadDeviceInfo$device.nativeDevice, hardwareIndex);
						if (oldPushed != newPushed) {
							GamepadHardwarePushy$hardwarePushy.buttonValue = newPushed;
							GamepadHardwarePushy$hardwarePushy.buttonGameCounter = gameCounter;
						}
					} else if (pushyType == 1) {
						// 1D Analog Axis
						oldAxis = GamepadHardwarePushy$hardwarePushy.axisValue;
						newAxis = $_gamepad_get_analog_axis_value(GamepadDeviceInfo$device.nativeDevice, hardwareIndex);
						if (newAxis < -.999) newAxis = -1.0;
						else if (newAxis > .999) newAxis = 1.0;
						else if (newAxis < .001 && newAxis > -.001) newAxis = 0.0;

						axisDiff = newAxis - oldAxis;
						if (axisDiff < 0) axisDiff *= -1;

						if (axisDiff >= 0.001) {
							if ((oldAxis < 0) != (newAxis < 0)) {
								// negative axis changed
								GamepadHardwarePushy$hardwarePushy.axisNegativeGameCounter = gameCounter;
							}
							if ((oldAxis > 0) != (newAxis > 0)) {
								// positive axis changed
								GamepadHardwarePushy$hardwarePushy.axisPositiveGameCounter = gameCounter;
							}
							GamepadHardwarePushy$hardwarePushy.axisValue = newAxis;
						}
					} else if (pushyType == 2) {
						// 2D Digital Axis
						oldX = GamepadHardwarePushy$hardwarePushy.hatXValue;
						oldY = GamepadHardwarePushy$hardwarePushy.hatYValue;
						xy = $_gamepad_get_2d_digital_axis_value(GamepadDeviceInfo$device.nativeDevice, hardwareIndex);
						newX = $_array_get(xy, 0);
						newY = $_array_get(xy, 1);
						if (oldX != newX || oldY != newY) {
							if ((oldX == -1) != (newX == -1)) {
								// -X changed
								GamepadHardwarePushy$hardwarePushy.hatXNegativeGameCounter = gameCounter;
							}
							if ((oldX == 1) != (newX == 1)) {
								// +X changed
								GamepadHardwarePushy$hardwarePushy.hatXPositiveGameCounter = gameCounter;
							}
							if ((oldY == -1) != (newY == -1)) {
								// -Y changed
								GamepadHardwarePushy$hardwarePushy.hatYNegativeGameCounter = gameCounter;
							}
							if ((oldY == 1) != (newY == 1)) {
								// +Y changed
								GamepadHardwarePushy$hardwarePushy.hatYPositiveGameCounter = gameCounter;
							}
							GamepadHardwarePushy$hardwarePushy.hatXValue = newX;
							GamepadHardwarePushy$hardwarePushy.hatYValue = newY;
						}
					}
				}

				// Second pass: update the atomic pushies and fire hardware events
				pushyStart = GamepadDeviceInfo$device.atomicPushyStartIndex;
				pushyEnd = pushyStart + GamepadDeviceInfo$device.atomicPushyCount;
				for (j = pushyStart; j < pushyEnd; j += 1) {
					atomicPushy = $_list_get(atomicPushies, j);
					hardwareIndex = GamepadAtomicPushy$atomicPushy.hardwarePushyIndex;
					hardwarePushy = $_list_get(hardwarePushies, hardwareIndex);
					pushyType = GamepadHardwarePushy$hardwarePushy.type;
					if (pushyType == 0) {
						if (GamepadHardwarePushy$hardwarePushy.buttonGameCounter == gameCounter) {
							// Fire button event
							newPushed = GamepadHardwarePushy$hardwarePushy.buttonValue;
							GamepadAtomicPushy$atomicPushy.value = newPushed;
							GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
							gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, false);
						}
					} else if (pushyType == 1) {
						pushySubType = GamepadAtomicPushy$atomicPushy.subtype;
						if (pushySubType == 1) { // positive axis
							if (GamepadHardwarePushy$hardwarePushy.axisPositiveGameCounter == gameCounter) {
								newAxis = GamepadHardwarePushy$hardwarePushy.axisValue;
								GamepadAtomicPushy$atomicPushy.valueF = newAxis;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireAnalogEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newAxis);
							}
						} else { // negative axis
							if (GamepadHardwarePushy$hardwarePushy.axisNegativeGameCounter == gameCounter) {
								newAxis = -GamepadHardwarePushy$hardwarePushy.axisValue;
								GamepadAtomicPushy$atomicPushy.valueF = newAxis;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireAnalogEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newAxis);
							}
						}
					} else if (pushyType == 2) {
						pushySubType = GamepadAtomicPushy$atomicPushy.subtype;
						if (pushySubType == 3) { // X+
							if (GamepadHardwarePushy$hardwarePushy.hatXPositiveGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatXValue > 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						} else if (pushySubType == 4) { // X-
							if (GamepadHardwarePushy$hardwarePushy.hatXNegativeGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatXValue < 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						} else if (pushySubType == 5) { // Y+
							if (GamepadHardwarePushy$hardwarePushy.hatYPositiveGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatYValue > 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						} else { // Y-
							if (GamepadHardwarePushy$hardwarePushy.hatYNegativeGameCounter == gameCounter) {
								newPushed = GamepadHardwarePushy$hardwarePushy.hatYValue < 0;
								GamepadAtomicPushy$atomicPushy.value = newPushed;
								GamepadAtomicPushy$atomicPushy.gameCounter = gameCounter;
								gamepadFireDigitalEvent(status, i, devicePlayerId, GamepadAtomicPushy$atomicPushy.descriptorId, newPushed, true);
							}
						}
					}
				}

				// Now search for virtual pushy events and add them to the event queue.
				@type('int') intIterator = 0;
				@type('int') stringIterator = 0;
				@type('int') intVLength = $_list_length(GamepadDeviceInfo$device.intVirtualPushyIds);
				@type('int') stringVLength = $_list_length(GamepadDeviceInfo$device.stringVirtualPushyIds);
				@type('GamepadVirtualPushy') virtualPushy = null;
				@type('bool') needsFiring = false;
				@type('int') dimensionality = 0;
				@type('int') atomicPushyIndex = 0;
				@type('GamepadAtomicPushy') ap1 = null;
				@type('GamepadAtomicPushy') ap2 = null;
				@type('GamepadAtomicPushy') ap3 = null;
				@type('GamepadAtomicPushy') ap4 = null;
		

				while (intIterator + stringIterator < intVLength + stringVLength) {
					if (intIterator < intVLength) {
						virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.intVirtualPushies, $_list_get(GamepadDeviceInfo$device.intVirtualPushyIds, intIterator));
						intIterator += 1;
					} else {
						virtualPushy = $_dictionary_get_guaranteed(GamepadDeviceInfo$device.stringVirtualPushies, $_list_get(GamepadDeviceInfo$device.stringVirtualPushyIds, stringIterator));
						stringIterator += 1;
					}

					needsFiring = false;
					dimensionality = GamepadVirtualPushy$virtualPushy.dimensionality;
					
					// atomic pushy 1
					atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex1;
					if (atomicPushyIndex != -1) {
						ap1 = $_list_get(atomicPushies, atomicPushyIndex);
						if (GamepadAtomicPushy$atomicPushy.gameCounter == gameCounter) {
							needsFiring = true;
						}
					} else {
						ap1 = null;
					}

					if (dimensionality > 0) {
						// atomic pushy 2
						atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex2;
						if (atomicPushyIndex != -1) {
							ap2 = $_list_get(atomicPushies, atomicPushyIndex);
							if (GamepadAtomicPushy$atomicPushy.gameCounter == gameCounter) {
								needsFiring = true;
							}
						} else {
							ap2 = null;
						}

						if (dimensionality > 1) {
							// atomic pushy 3
							if (dimensionality > 1) {
								atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex3;
								if (atomicPushyIndex != -1) {
									ap3 = $_list_get(atomicPushies, atomicPushyIndex);
									if (GamepadAtomicPushy$atomicPushy.gameCounter == gameCounter) {
										needsFiring = true;
									}
								} else {
									ap3 = null;
								}
							}

							// atomic pushy 4
							if (dimensionality > 1) {
								atomicPushyIndex = GamepadVirtualPushy$virtualPushy.atomicIndex4;
								if (atomicPushyIndex != -1) {
									ap4 = $_list_get(atomicPushies, atomicPushyIndex);
									if (GamepadAtomicPushy$atomicPushy.gameCounter == gameCounter) {
										needsFiring = true;
									}
								} else {
									ap4 = null;
								}
							}
						}
					}

					if (needsFiring) {
						// TODO (bug) analog values bound as digital events will needlessly fire as the analog value changes without crossing the firing threshold.
						gamepadFireVirtualEvent(status, i, GamepadVirtualPushy$virtualPushy.alias, dimensionality, GamepadVirtualPushy$virtualPushy.isDigital, ap1, ap2, ap3, ap4);
					}
				}
			}
		}
	}
	return true;
}

function @type('bool') gamepadFireVirtualEvent(
		@type('GamepadStatus') status,
		@type('int') deviceIndex,
		@type('Value') alias,
		@type('int') dimensionality,
		@type('bool') isDigital,
		@type('GamepadAtomicPushy') ap1,
		@type('GamepadAtomicPushy') ap2,
		@type('GamepadAtomicPushy') ap3,
		@type('GamepadAtomicPushy') ap4) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('Value') value = null;
		if (dimensionality == 0) {
			@type('int') ap1type = GamepadAtomicPushy$ap1.subtype;
			if (ap1type == 1) {
				if (isDigital) {
					if (GamepadAtomicPushy$ap1.valueF > .5) {
						value = VALUE_TRUE;
					} else {
						value = VALUE_FALSE;
					}
				} else {
					value = buildFloat(GamepadAtomicPushy$ap1.valueF);
				}
			} else {
				if (GamepadAtomicPushy$ap1.value) {
					if (isDigital) {
						value = VALUE_TRUE;
					} else {
						value = VALUE_FLOAT_ONE;
					}
				} else {
					if (isDigital) {
						value = VALUE_FALSE;
					} else {
						value = VALUE_FLOAT_ZERO;
					}
				}
			}
		} else {
			if (dimensionality == 1) {
				if (isDigital) {
					value = gamepadBuildVirtualAxisDigitalValue(ap1, ap2);
				} else {
					value = gamepadBuildVirtualAxisAnalogValue(ap1, ap2);
				}
			} else {
				if (isDigital) {
					value = buildList2(gamepadBuildVirtualAxisDigitalValue(ap1, ap2), gamepadBuildVirtualAxisDigitalValue(ap3, ap4));
				} else {
					value = buildList2(gamepadBuildVirtualAxisAnalogValue(ap1, ap2), gamepadBuildVirtualAxisAnalogValue(ap3, ap4));
				}
			}
		}

		@type('GamepadDeviceInfo') device = $_list_get(GamepadStatus$status.devices, deviceIndex);
		@type('Value') playerId = GamepadDeviceInfo$device.playerId;
		if (playerId == null) return true; // sanity check, but this should never happen.
		value = buildGameEventWithExtraArg('gamepad', 'gamepad', deviceIndex, 0, 0.0, false, null, playerId, value, alias);
		$_list_push(GamepadStatus$status.virtualEvents, value);
	}
	return true;
}

function @type('Value') gamepadBuildVirtualAxisDigitalValue(@type('GamepadAtomicPushy') apPos, @type('GamepadAtomicPushy') apNeg) {
	@type('bool') set = false;
	if (GamepadAtomicPushy$apPos.subtype == 1) {
		if (GamepadAtomicPushy$apPos.valueF > .5) {
			set = true;
		}
	} else {
		set = GamepadAtomicPushy$apPos.value;
	}
	if (set) return INTEGERS_CACHE[0][1];
	
	if (GamepadAtomicPushy$apNeg.valueF > .5) {
		if (GamepadAtomicPushy$apNeg.valueF > .5) {
			set = true;
		}
	} else {
		set = GamepadAtomicPushy$apNeg.value;
	}

	if (set) return INTEGERS_CACHE[1][1];

	return INTEGERS_CACHE[0][0];
}

function @type('Value') gamepadBuildVirtualAxisAnalogValue(@type('GamepadAtomicPushy') apPos, @type('GamepadAtomicPushy') apNeg) {
	if (GamepadAtomicPushy$apPos.subtype == 1 && GamepadAtomicPushy$apNeg.subtype == 1) {
		// First check if both axes are analog and if so, use the one that has the strongest value as the other could
		// possibly be non-zero noise.
		if (GamepadAtomicPushy$apPos.valueF > GamepadAtomicPushy$apNeg.valueF) {
			return buildFloat(GamepadAtomicPushy$apPos.valueF);
		}
		return buildFloat(-GamepadAtomicPushy$apNeg.valueF);
	}

	if (GamepadAtomicPushy$apPos.subtype == 1) {
		// positive is analog and negative is not. If negative axis is pressed, return that, otherwise, return the positive axis as-is.
		if (GamepadAtomicPushy$apNeg.value) {
			return VALUE_FLOAT_NEGATIVE_ONE;
		}

		return buildFloat(GamepadAtomicPushy$apPos.valueF);
	}

	if (GamepadAtomicPushy$apNeg.subtype == 1) {
		// negative is analog and positive is not. If positive axis is pressed, return that, otherwise, return the negative axis as-is.
		if (GamepadAtomicPushy$apPos.value) {
			return VALUE_FLOAT_ONE;
		}

		return buildFloat(-1 * GamepadAtomicPushy$apNeg.valueF);
	}

	// Both axes are digital and ideally should be physically impossible to press at the same time, so order doesn't matter.
	if (GamepadAtomicPushy$apPos.value) {
		return VALUE_FLOAT_ONE;
	}
	if (GamepadAtomicPushy$apNeg.value) {
		return VALUE_FLOAT_NEGATIVE_ONE;
	}

	return VALUE_FLOAT_ZERO;
}

function @type('bool') gamepadFireAnalogEvent(
		@type('GamepadStatus') status,
		@type('int') deviceIndex,
		@type('Value') playerId,
		@type('string') pushyDescriptor,
		@type('double') value) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('int') isSignificant = 1;
		if (value < .5) isSignificant = 0;
		@type('Value') gameEvent = buildGameEvent(
			'hardwareanalogaxis',
			'hardware',
			deviceIndex, // x field for device index
			isSignificant, // y field for is_significant
			value,
			false,
			pushyDescriptor,
			playerId);
		$_list_push(GamepadStatus$status.hardwareEvents, gameEvent);
	}
	return true;
}

function @type('bool') gamepadFireDigitalEvent(
		@type('GamepadStatus') status,
		@type('int') deviceIndex,
		@type('Value') playerId,
		@type('string') pushyDescriptor,
		@type('bool') value,
		@type('bool') isDigitalAxis) {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('string') type = 'hardwarebutton';
		if (isDigitalAxis) type = 'hardwaredigitalaxis';
		@type('Value') gameEvent = buildGameEvent(
			type,
			'hardware',
			deviceIndex, // x field for device index
			1, // y field for is_significant
			0.0,
			value,
			pushyDescriptor,
			playerId);
		$_list_push(GamepadStatus$status.hardwareEvents, gameEvent);
	}
	return true;
}

// returns -1 if the gamepads have not been initialized.
function @type('int') gamepadGetDeviceCount() {
	
	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		@type('GamepadStatus') status = gamepadGetGlobalStatus();
		if (GamepadStatus$status.isInitialized) {
			return $_list_length(GamepadStatus$status.devices);
		}
		return -1;
	} else {
		return 0;
	}
}

function @type('int') gamepadSaveConfig() {
	// TODO: this
	return 0;
}

/* 
	intOutParam[0] -> error code
	error codes:
	0 - no error
	1 - too early
	2 - not an integer
	3 - out of range

	returns a Value containing the native object wrapping the GamepadDeviceInfo.
*/
function @type('Value') gamepadGetDevice(@type('Value') indexValue, @type('Array<int>') intOutParam) {

	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	if (!GamepadStatus$status.isInitialized) {
		$_array_set(intOutParam, 0, 1);
		return null;
	}
	
	if (Value$indexValue.type != Types.INTEGER) {
		$_array_set(intOutParam, 0, 2);
		return null;
	}
	@type('int') index = $_cast('int', Value$indexValue.internalValue);
	
	if (index < 0 || index >= $_list_length(GamepadStatus$status.devices)) {
		$_array_set(intOutParam, 0, 3);
		return null;
	}
	
	$_array_set(intOutParam, 0, 0);
	return $_list_get(GamepadStatus$status.deviceValues, index);
}

/*
	Parses the config file for this platform in user data.
	Tries to initialize as many plugged in devices as possible by going down the history of the most
	recently used devices that have configuration information and applies those in the order it sees.
	
	Returns the number of devices successfully initialized.
	Error code is returned in intOutParam[0]
	
	Error codes:
	0 - no error
	1 - called too early
*/
function @type('int') gamepadEnableRecent(@type('Value') idOrList, @type('Array<int>') intOutParam) {
	
	@type('GamepadStatus') status = gamepadGetGlobalStatus();
	if (!GamepadStatus$status.isInitialized) {
		$_array_set(intOutParam, 0, 1);
		return 0;
	}

	if (%%%IS_GAMEPAD_SUPPORTED%%%) {
		// TODO: this
	}
	$_array_set(intOutParam, 0, 0);
	return 0;
}