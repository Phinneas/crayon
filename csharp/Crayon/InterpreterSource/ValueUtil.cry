function valueToString(@type('Value') wrappedValue) {
	@type('int') type = Value$wrappedValue.type;
	@type('object') value = Value$wrappedValue.internalValue;
	if (type == Types.NULL) return "null";
	if (type == Types.BOOLEAN) {
		if ($_cast('bool', value)) return "true";
		return "false";
	}
	if (type == Types.INTEGER || type == Types.FLOAT || type == Types.STRING) return $_string_cast_strong(value);
	if (type == Types.LIST) {
		// TODO: this will recurse infinitely if the list points to itself somehow.
		@type('List<Value>') internalList = $_cast('List<Value>', value);
		@type('string') output = "[";
		for (@type('int') i = 0; i < $_list_length(internalList); i += 1) {
			if (i > 0) output += ", ";
			output += valueToString($_list_get(internalList, i));
		}
		output += "]";
		return output;
	}
	if (type == Types.INSTANCE) {
		return "INSTANCE: " + $_string_cast_strong(value);
	}
	return "TODO: toString for " + getTypeFromId(type);
}

function initialize_constant_values() {
	@type('int') i = 0;
	@type('Array<Value>') positive_integers = $_new_array('Value', INTEGER_POSITIVE_CACHE);
	@type('Array<Value>') negative_integers = $_new_array('Value', INTEGER_NEGATIVE_CACHE);
	for (i = 0; i < INTEGER_POSITIVE_CACHE; i += 1) {
		$_list_set(positive_integers, i, new Value(Types.INTEGER, i));
	}
	for (i = 0; i < INTEGER_NEGATIVE_CACHE; i += 1) {
		$_list_set(negative_integers, i, new Value(Types.INTEGER, -i));
	}
	$_list_set(INTEGERS_CACHE, 0, positive_integers);
	$_list_set(INTEGERS_CACHE, 1, negative_integers);
}

function build_integer(@type('int') value) {
	if (value < 0) {
		if (value > -INTEGER_NEGATIVE_CACHE) {
			return INTEGERS_CACHE[1][-value];
		}
	} else {
		if (value < INTEGER_POSITIVE_CACHE) {
			return INTEGERS_CACHE[0][value];
		}
	}
	return new Value(Types.INTEGER, value);
}

function doEqualityComparisonAndReturnCode(@type('Value') a, @type('Value') b) {
	@type('int') leftType = Value$a.type;
	@type('int') rightType = Value$b.type;
	if (leftType == rightType || 
		(leftType == Types.INTEGER && rightType == Types.FLOAT) || 
		(leftType == Types.FLOAT && rightType == Types.INTEGER)) {
		left = Value$a.internalValue;
		right = Value$b.internalValue;
		if (leftType < Types.LIST) {
			if (left == right) {
				return 1;
			}
			return 0;
		}

		if (leftType == Types.INSTANCE) {
			if ($_list_get(left, 2) == $_list_get(right, 2)) {
				return 1;
			}
			return 0;
		}

		// == is not defined for this type. If a user needs to compare two things of one of the remaining types,
		// they are probably writing bad code.
		return 2;
	}
	return 0;
}

function buildLiteral(@type('int') type, @type('int') value, @type('Array<Value>') floatTable, @type('Array<Value>') stringTable) {
	if (type == Types.NULL) return VALUE_NULL;
	if (type == Types.INTEGER) return build_integer(value);
	if (type == Types.FLOAT) return $_list_get(floatTable, value);
	if (type == Types.STRING) return $_list_get(stringTable, value);
	if (type == Types.BOOLEAN && value == 1) return VALUE_TRUE;
	if (type == Types.BOOLEAN && value == 0) return VALUE_FALSE;
	return null;
}

function copyIntToIntDictionary(@type('Dictionary<int, int>') dict) {
	@type('Array<int>') key_list = $_dictionary_get_keys(dict);
	@type('Dictionary<int, int>') output = {};
	for (@type('int') i = 0; i < $_list_length(key_list); i += 1) {
		@type('int') key = $_list_get(key_list, i);
		@type('int') value = $_dictionary_get(dict, key, 0);
		$_dictionary_set(output, key, value);
	}
	return output;
}
