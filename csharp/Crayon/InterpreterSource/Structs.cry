struct Code {
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs
}

// Dictionaries in Crayon can only have 3 types of keys: integers, strings, and objects
// Dictionaries can hold any of these, but only hold one type at a time
struct DictImpl {
	@type('Dictionary<int, Value>') keyIntLookup,
	@type('Dictionary<int, Value>') valueIntLookup,
	@type('Dictionary<string, Value>') keyStringLookup,
	@type('Dictionary<string, Value>') valueStringLookup,
	@type('int') size,
	@type('int') keyType
}

struct SpriteSheetItemDescriptor {
	@type('string') filePath,
	@type('int') groupId,
	@type('int') spillId,
	@type('int') tileId,
	@type('bool') solitary,
	@type('int') x,
	@type('int') y,
	@type('int') width,
	@type('int') height
}

struct SpriteSheetData {
	@type('Dictionary<string, SpriteSheetItemDescriptor>') files,
	@type('Dictionary<int, List<string>>') filesByGroupId,
	@type('Dictionary<int, Dictionary<int, bool>>') tileIdsByGroupId,
	@type('Dictionary<string, int>') groupIdsByName
}

struct ProgramData {
	@type('StackFrame') stackTop,
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs,
	@type('Array<Array<int>>') specialCache,
	@type('Array<string>') identifiers,
	@type('List<string>') identifiersBuilder,
	@type('Dictionary<string, int>') inv_identifiers,
	@type('Array<Value>') literalTable,
	@type('List<Value>') literalTableBuilder,
	@type('Array<ClassInfo>') classTable,
	@type('Array<Dictionary<int, MethodDefinition>>') classMethods,
	@type('bool') tickerRegistered,
	@type('Array<List<Token>>') tokenData,
	@type('int') userCodeStart,
	@type('Dictionary<int, Value>') globalVarScope,
	@type('Array<string>') sourceCode,
	@type('List<string>') sourceCodeBuilder,
	@type('Array<Dictionary<int, int>>') integerSwitchLookups,
	@type('List<Dictionary<int, int>>') integerSwitchLookupsBuilder,
	@type('Array<Dictionary<string, int>>') stringSwitchLookups,
	@type('List<Dictionary<string, int>>') stringSwitchLookupsBuilder,
	@type('Dictionary<string, int>') primitiveMethodLookup, // TODO: make this an <int, int> dictionary and use the identifier code and eliminate the rutime string calculation altogether
	@type('int') instanceCounter,
	@type('SpriteSheetData') spriteSheetData,
	@type('ImageSheetStatus') imageSheetStatus,
	@type('SoundStatus') soundStatus,
	@type('bool') initializationComplete,
	@type('GamepadStatus') gamepadStatus,
}

struct StackFrame {
	@type('int') pc,
	@type('Dictionary<int, Value>') locals,
	@type('Stack<Value>') valueStack,
	@type('Array<Value>') args,
	@type('StackFrame') previous,
	@type('bool') returnValueUsed,
	@type('Value') objectContext
}

struct Token {
	@type('int') lineIndex,
	@type('int') colIndex,
	@type('int') fileId
}

struct Value {
	@type('int') type,
	@type('object') internalValue
}

struct MethodInstance {
	@type('Value') context,
	@type('int') pc,
	@type('int') maxArgs
}

struct MethodDefinition {
	@type('int') nameId,
	@type('int') maxArgs,
	@type('int') pc
}

struct SystemMethod {
	@type('Value') context,
	@type('int') id
}

struct ClassInfo {
	@type('int') nameId,
	@type('int') constructorPc,
	@type('int') constructorMaxArgCount,
	@type('int') baseClassId,
	@type('bool') baseConstructorRequired,
	@type('bool') initialized
}

struct FunctionDefinition {
	@type('int') pc,
	@type('int') maxArgCount,
	@type('string') name
}

struct ObjectInstance {
	@type('int') classId,
	@type('Dictionary<int, Value>') fields,
	@type('int') objectId
}

struct CompositeImage {
	@type('object') nativeBitmap,
	@type('int') width,
	@type('int') height,
	@type('int') glTextureId,
	@type('bool') loaded
}

struct ImageSheetVirtualizationGrid {
	@type('Dictionary<string, Array<int>>') imageLocations,
	@type('Dictionary<int, CompositeImage>') sheets,
	@type('string') groupName,
	@type('int') groupId,
	@type('Array<string>') paths,
	@type('bool') loadCompletionChecked
}

/*
 * Either compositeResource or rawResource will be null depending on the platform.
 */
struct Image {
	@type('CompositeImage') compositeResource, // Composite image this image is located in
	@type('object') rawResource, // native platform bitmap if image compositing is not used
	@type('int') sourceX,
	@type('int') sourceY,
	@type('int') sourceWidth,
	@type('int') sourceHeight,
	@type('int') width,
	@type('int') height,
	@type('float') textureLeft,
	@type('float') textureTop,
	@type('float') textureRight,
	@type('float') textureBottom
}

struct ImageSheetStatus {
	@type('Dictionary<string, string>') autogeneratedAsyncDownloadKeyToUserKeyLoop,
	@type('Dictionary<string, object>') downloadedImagesByKey,
	@type('Dictionary<string, int>') downloadedImagesErrorCodes,
	@type('Dictionary<string, TileLoadRequest>') downloadsInFlight, // key is generated tile name
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') fileToVirtualizationGrid,
	@type('Dictionary<int, Array<string>>') generatedTileNamesByGroupId,
	@type('Dictionary<string, int>') groupNameToId,
	@type('bool') isBackgroundLoaderActive,
	@type('Dictionary<string, Image>') loadedImagesByKey,
	@type('Dictionary<string, CompositeImage>') resourceImagesByKeys,
	@type('Dictionary<int, int>') sheetStatus,
	@type('Dictionary<int, List<SpriteSheetItemDescriptor>>') spriteSheetItemDescriptorsByGroupId,
	@type('Dictionary<string, Array<int>>') texturePartitioningInformation,
	@type('List<TileLoadRequest>') tileLoadQueue,
	@type('Dictionary<string, object>') tilesByName,
	@type('Dictionary<int, Array<int>>') tilesPerId,
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') virtualizationGrids
}

struct SoundInstance {
	@type('string') userFilePath, // path in the original project (consistent across platforms)
	@type('object') nativeObject, // native sound object.
	@type('string') realFilePath, // path on the actual disk
	@type('double') volume, // volume for this particular music instance (combined with master volume)
	@type('bool') isLoaded, // true if the music is loaded and ready to play
}

struct MusicInstance {
	@type('string') userFilePath, // path in the original project (consistent across platforms)
	@type('object') nativeObject, // native sound object, if necessary (SDL platforms use file paths directly, so this will be null)
	@type('string') realFilePath, // path on the actual disk
	@type('double') volume, // volume for this particular music instance (combined with master volume)
	@type('bool') isLoaded, // true if the music is loaded and ready to play (for SDL, this is unknown and is assumed to be true despite the fact that it may take a few ticks to start playing)
}

// Enqueued in the SoundStatus.soundEventQueue
// Dequeued by the work unit pump
// If the sound or music for an event isn't loaded, it'll 
struct SoundEvent {
	@type('int') type, // FADE_MUSIC, PLAY_MUSIC, PAUSE_MUSIC, PLAY_SOUND
	@type('SoundInstance') sound, 
	@type('MusicInstance') music,
	@type('bool') fadeOutEstablished, // set to true once the endFade timestamp is established.
	@type('bool') musicLoops, // true if the music should loop.

	// These are set when the event is created. These are in seconds.
	@type('double') fadeOutDuration, 

	// These are all blank when the event is created. 
	// When the music has loaded, these are set to the relative timestamps from the current time using the
	// durations listed above. These are all 1970 epoch timestamps.
	@type('double') fadeStart,
	@type('double') fadeMiddle,
	@type('double') fadeEnd,
}

struct SoundStatus {
	@type('List<SoundEvent>') soundEventQueue,
	@type('MusicInstance') currentMusic,
	@type('double') masterSoundVolume,
	@type('double') masterMusicVolume,
	@type('double') fadeVolumeRatio,
	@type('double') lastSetMusicVolume,
	@type('bool') forceVolumeSet,
}

struct TileLoadRequest {
	@type('string') path,
	@type('int') status,
	@type('int') groupId,
	@type('string') groupName,
	@type('int') tileId,
	@type('object') nativeResource,
	@type('string') asyncReferenceKey, // for JS, the key for which to refer back to the downloader.
}

/*
 * The imagette is an image that is defined by a width, height, and series of blits of native platform bitmaps.
 * These are used during the compositing phase of the image sheet tile loading. This allows that guts of the code logic to be written
 * in Crayon without the extensive use of native methods. The Imagettes, containing straightforward bitmap data, are then flushed to 
 * native platform bitmaps at the end.
 */
struct Imagette {
	@type('int') width,
	@type('int') height,
	@type('List<object>') nativeBitmaps,
	@type('List<int>') xs,
	@type('List<int>') ys,
}

/*
 * All native objects have this as an internal value.
 * The value field here is the actual native object.
 * This allows the native object to be consistently identified with the subtype marker.
 */
struct NativeObjectWrapper {
	@type('int') subType,
	@type('object') value,
}

/*
 * This is the wrapped native object value used for events.
 */
struct GameEvent {
	@type('string') specificType, // { mouseleftdown | mouserightdown | mouseleftup | mouserightup | mousemove | mousescroll | keydown | keyup | quit-x | quit-altf4 }
	@type('string') vagueType, // { mouse | key | joystick | quit } <-- technically these are redundant information with above, but allow for quick checks to see if specific fields are valid on the event object.
	@type('int') x,
	@type('int') y,
	@type('double') amount,
	@type('bool') down,
	@type('string') arg, // used for keyboard key, mouse button, or quit type
	// TODO: expand for joystick events
}

struct GamepadStatus {
	// Whether the gamepad list has been populated...which happens on $game_initialize_screen
	@type('bool') isInitialized,

	// List of all the gamepads that are available on startup, regardless of whether they are enabled.
	// This list does not change.
	@type('List<GamepadDeviceInfo>') deviceList,

	// An empty list of pushy info. These get populated as the devices are enabled.
	@type('List<GamepadPushyInfo>') pushyInfoList,
}

struct GamepadDeviceInfo {
	@type('object') nativeDevice,
	@type('string') name,
	@type('int') deviceIndex,
	@type('bool') enabled,
	@type('int') axisCount,
	@type('int') hatCount,
	@type('int') buttonCount,
	@type('int') pushyStartIndex,
	@type('int') pushyCount,
	@type('bool') supportsVibrate, // always false for now
	@type('int') registered, // 0 - no, 1 - yes w/ integer player ID, 2 - yes w/ string player ID
	@type('int') intPlayerId,
	@type('string') stringPlayerId,
}

// A "pushy" is a term I made up because there are hats, axes, and buttons, but if I use the term "button" it's ambiguous.
// A pushy refers to all 3 of these.
// A button is one digital pushy.
// An axis is defined as 2 pushies, one in each direction.
// A hat is actually defined as 4 pushies, two for each direction, two for each orientation.
// This term is not surfaced in the API.
struct GamepadPushyInfo {
	@type('int') deviceIndex,
	@type('int') pushyIndex,
	@type('int') hardwareIndexWithinType,

	// registrtion info
	@type('int') isRegistered, // 0 - no, 1 - yes w/ integer pushyId, 2 - yes w/ string pushyId
	@type('int') intPushyId,
	@type('string') stringPushyId,
	@type('bool') isRegistrationDigital, // report as float or bool?

	/* Aggregate registration info
		this indicates that the pushy is registered as part of a 
		aggregated button. For example, a user can register 4 buttons as "direction" but have aggregate definitions
		for each of the buttons and it will get returned as one item in the event queue as either a float from -1 to 1 or
		a list vector of two such float values.

		this value indicates the following:
		0 - not an aggregate registration
		
		one dimensional aggregate button:
		1 - positive axis
		2 - negative axis

		two dimensional aggregate button:
		3 - positive X axis
		4 - negative X axis
		5 - positive Y axis
		6 - negative Y axis

		(pushy ID, aggregateRegistrationId) must be unique.
		Registering a new value knocks a previous value to 0
		All pushies that use the same pushy ID must have the same type of
		aggregate ID e.g. (1 and 2) OR (3, 4, 5, and 6)
	*/
	@type('int') aggregateRegistrationId,

	// what kind of pushy is this?
	@type('bool') isButton,
	@type('bool') isAxis,
	@type('bool') isHat,
	@type('bool') isPositive, // -1 or 1, hats and axes only
	@type('bool') isX, // hats only

	@type('double') floatCurrentState,
	@type('bool') boolCurrentState,

	@type('double') floatLastReportedState,
	@type('bool') boolLastReportedState,
	@type('int') lastReportedFrameCounter, // frame counter at the last time an event was fired

	// Do not push events if the current real value is too close to the last reported value, according to this threshold
	@type('double') reportThreshold,
}

struct HttpRequest {
	@type('int') statusCode,
	@type('string') status,
	@type('Dictionary<string, Array<string>>') headers,
	@type('string') body,
}

struct GlRenderState {
	@type('int') mode,
	@type('int') textureId,
	@type('int') r,
	@type('int') g,
	@type('int') b,
	@type('int') a
}
