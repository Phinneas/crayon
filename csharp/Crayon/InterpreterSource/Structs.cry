struct Code {
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs
}

// Dictionaries in Crayon can only have 3 types of keys: integers, strings, and objects
// Dictionaries can hold any of these, but only hold one type at a time
struct DictImpl {
	@type('Dictionary<int, Value>') keyIntLookup,
	@type('Dictionary<int, Value>') valueIntLookup,
	@type('Dictionary<string, Value>') keyStringLookup,
	@type('Dictionary<string, Value>') valueStringLookup,
	@type('int') size,
	@type('int') keyType
}

struct SpriteSheetItemDescriptor {
	@type('string') filePath,
	@type('int') groupId,
	@type('int') spillId,
	@type('int') tileId,
	@type('bool') solitary,
	@type('int') x,
	@type('int') y,
	@type('int') width,
	@type('int') height
}

struct SpriteSheetData {
	@type('Dictionary<string, SpriteSheetItemDescriptor>') files,
	@type('Dictionary<int, List<string>>') filesByGroupId,
	@type('Dictionary<int, Dictionary<int, bool>>') tileIdsByGroupId,
	@type('Dictionary<string, int>') groupIdsByName
}

struct ProgramData {
	@type('StackFrame') stackTop,
	@type('Array<int>') ops,
	@type('Array<Array<int>>') args,
	@type('Array<string>') stringArgs,
	@type('Array<Array<int>>') specialCache,
	@type('Array<string>') identifiers,
	@type('List<string>') identifiersBuilder,
	@type('Dictionary<string, int>') inv_identifiers,
	@type('Array<Value>') literalTable,
	@type('List<Value>') literalTableBuilder,
	@type('Array<ClassInfo>') classTable,
	@type('Array<Dictionary<int, MethodDefinition>>') classMethods,
	@type('bool') tickerRegistered,
	@type('Array<List<Token>>') tokenData,
	@type('int') userCodeStart,
	@type('Dictionary<int, Value>') globalVarScope,
	@type('Array<string>') sourceCode,
	@type('List<string>') sourceCodeBuilder,
	@type('Array<Dictionary<int, int>>') integerSwitchLookups,
	@type('List<Dictionary<int, int>>') integerSwitchLookupsBuilder,
	@type('Array<Dictionary<string, int>>') stringSwitchLookups,
	@type('List<Dictionary<string, int>>') stringSwitchLookupsBuilder,
	@type('Dictionary<string, int>') primitiveMethodLookup, // TODO: make this an <int, int> dictionary and use the identifier code and eliminate the rutime string calculation altogether
	@type('int') instanceCounter,
	@type('SpriteSheetData') spriteSheetData,
	@type('List<int>') imageScaleStack,
	@type('int') imageScaleStackTop,
	@type('ImageSheetStatus') imageSheetStatus,
	@type('SoundStatus') soundStatus,
	@type('bool') initializationComplete,
}

struct StackFrame {
	@type('int') pc,
	@type('Dictionary<int, Value>') locals,
	@type('Stack<Value>') valueStack,
	@type('Array<Value>') args,
	@type('StackFrame') previous,
	@type('bool') returnValueUsed,
	@type('Value') objectContext
}

struct Token {
	@type('int') lineIndex,
	@type('int') colIndex,
	@type('int') fileId
}

struct Value {
	@type('int') type,
	@type('object') internalValue
}

struct MethodInstance {
	@type('Value') context,
	@type('int') pc,
	@type('int') maxArgs
}

struct MethodDefinition {
	@type('int') nameId,
	@type('int') maxArgs,
	@type('int') pc
}

struct SystemMethod {
	@type('Value') context,
	@type('int') id
}

struct ClassInfo {
	@type('int') nameId,
	@type('int') constructorPc,
	@type('int') constructorMaxArgCount,
	@type('int') baseClassId,
	@type('bool') baseConstructorRequired,
	@type('bool') initialized
}

struct FunctionDefinition {
	@type('int') pc,
	@type('int') maxArgCount,
	@type('string') name
}

struct ObjectInstance {
	@type('int') classId,
	@type('Dictionary<int, Value>') fields,
	@type('int') objectId
}

struct CompositeImage {
	@type('object') nativeBitmap,
	@type('int') width,
	@type('int') height,
	@type('int') glTextureId,
	@type('bool') loaded
}

struct ImageSheetVirtualizationGrid {
	@type('Dictionary<string, Array<int>>') imageLocations,
	@type('Dictionary<int, CompositeImage>') sheets,
	@type('string') groupName,
	@type('int') groupId,
	@type('Array<string>') paths
}

/*
 * Either compositeResource or rawResource will be null depending on the platform.
 */
struct Image {
	@type('CompositeImage') compositeResource, // Composite image this image is located in
	@type('object') rawResource, // native platform bitmap if image compositing is not used
	@type('int') x,
	@type('int') y,
	@type('int') width,
	@type('int') height,
	@type('float') textureLeft,
	@type('float') textureTop,
	@type('float') textureRight,
	@type('float') textureBottom
}

struct ImageSheetStatus {
	@type('Dictionary<string, string>') autogeneratedAsyncDownloadKeyToUserKeyLoop,
	@type('Dictionary<string, object>') downloadedImagesByKey,
	@type('Dictionary<string, int>') downloadedImagesErrorCodes,
	@type('Dictionary<string, TileLoadRequest>') downloadsInFlight, // key is generated tile name
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') fileToVirtualizationGrid,
	@type('Dictionary<int, Array<string>>') generatedTileNamesByGroupId,
	@type('Dictionary<string, int>') groupNameToId,
	@type('bool') isBackgroundLoaderActive,
	@type('Dictionary<string, Image>') loadedImagesByKey,
	@type('Dictionary<string, CompositeImage>') resourceImagesByKeys,
	@type('Dictionary<int, int>') sheetStatus,
	@type('Dictionary<int, List<SpriteSheetItemDescriptor>>') spriteSheetItemDescriptorsByGroupId,
	@type('Dictionary<string, Array<int>>') texturePartitioningInformation,
	@type('List<TileLoadRequest>') tileLoadQueue,
	@type('Dictionary<string, object>') tilesByName,
	@type('Dictionary<int, Array<int>>') tilesPerId,
	@type('Dictionary<string, ImageSheetVirtualizationGrid>') virtualizationGrids
}

struct SoundStatus {
	@type('Dictionary<string, SoundInstance>') loadedSoundsByKey
}

struct TileLoadRequest {
	@type('string') path,
	@type('int') status,
	@type('int') groupId,
	@type('string') groupName,
	@type('int') tileId,
	@type('object') nativeResource,
	@type('string') asyncReferenceKey, // for JS, the key for which to refer back to the downloader.
}

/*
 * The imagette is an image that is defined by a width, height, and series of blits of native platform bitmaps.
 * These are used during the compositing phase of the image sheet tile loading. This allows that guts of the code logic to be written
 * in Crayon without the extensive use of native methods. The Imagettes, containing straightforward bitmap data, are then flushed to 
 * native platform bitmaps at the end.
 */
struct Imagette {
	@type('int') width,
	@type('int') height,
	@type('List<object>') nativeBitmaps,
	@type('List<int>') xs,
	@type('List<int>') ys,
}

/*
 * All native objects have this as an internal value.
 * The value field here is the actual native object.
 * This allows the native object to be consistently identified with the subtype marker.
 */
struct NativeObjectWrapper {
	@type('int') subType,
	@type('object') value,
}

/*
 * This is the wrapped native object value used for events.
 */
struct GameEvent {
	@type('string') specificType, // { mouseleftdown | mouserightdown | mouseleftup | mouserightup | mousemove | mousescroll | keydown | keyup | quit-x | quit-altf4 }
	@type('string') vagueType, // { mouse | key | joystick | quit } <-- technically these are redundant information with above, but allow for quick checks to see if specific fields are valid on the event object.
	@type('int') x,
	@type('int') y,
	@type('double') amount,
	@type('bool') down,
	@type('string') arg, // used for keyboard key, mouse button, or quit type
	// TODO: expand for joystick events
}

struct SoundInstance {
	@type('object') nativeObject,
	@type('bool') isMusic,
	@type('int') soundId,
	@type('double') duration,
}
