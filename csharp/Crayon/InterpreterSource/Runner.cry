
function main() {

	initialize_constant_values();

	@type('Code') byteCode = loadByteCode();
	@type('Array<int>') ops = Code$byteCode.ops;
	@type('Array<Array<int>>') opArgs = Code$byteCode.args;
	@type('Array<string>') stringArgs = Code$byteCode.stringArgs;

	@type('Dictionary<int, int>') nameIdToClassId = {};
	@type('Array<Array<int>>') classTable = [null]; // class ID 0 is not valid. First entry should be at index 1.
	classMethods = [null]; // same here

	@type('int') nameId = 0;

	for (@type('int') i = 0; i < $_list_length(ops); i += 1) {
		@type('int') op = $_list_get(ops, i);
		if (op == OpCodes.CLASS_DEFINITION) {
			@type('Array<int>') args = $_list_get(opArgs, i);
			@type('int') id = $_list_length(classTable);
			@type('int') lastClassId = id;
			nameId = $_list_get(args, 0);
			$_dictionary_set(nameIdToClassId, nameId, id);
			@type('int') baseClassNameId = $_list_get(args, 1);
			@type('int') constructorArgsCount = $_list_get(args, 2); // -1 if no constructor present
			@type('int') methodCount = $_list_get(args, 3);

			@type('int') baseClassId = 0;
			if (baseClassNameId > 0) {
				// base class name not found is a compile time error.
				baseClassId = $_dictionary_get(nameIdToClassId, baseClassNameId, 0);
			}
			
			if (baseClassId == 0) {
				methodLookup = {};
			} else {
				methodLookup = copyIntToIntDictionary($_list_get(classMethods, baseClassId));
			}

			for (@type('int') j = 0; j < methodCount; j += 1) {
				@type('int') methodNameId = $_list_get(args, (j * 3) + 4);
				@type('int') pcOffset = $_list_get(args, (j * 3) + 5);
				@type('int') maxArgs = $_list_get(args, (j * 3) + 6);

				@type('Array<int>') methodData = [
					methodNameId,
					maxArgs,
					i + pcOffset
				];

				$_dictionary_set(methodLookup, methodNameId, methodData);
			}

			@type('Array<int>') classRow = [
				nameId,
				0, // PC of constructor (0 if absent, overriden to correct value below)
				0, // maximum arg count of constructor
				baseClassId,
				0, // do base constructors need to be invoked? (overridden below if yes)
				0 // Is class usable? This gets changed to 1 when the class definition is encountered.
			];
			if (constructorArgsCount >= 0) {
				classRow[1] = i + 2;
				classRow[2] = constructorArgsCount;
			}
			
			if (baseClassId != 0) {
				@type('Array<int>') baseClassInfo = $_list_get(classTable, baseClassId);
				if ($_list_get(baseClassInfo, 1) > 0 || $_list_get(baseClassInfo, 4) == 1) {
					classRow[4] = 1;
				}
			}

			$_list_push(classTable, classRow);
			$_list_push(classMethods, methodLookup);
		}
	}

	@type('int') lastClassId = 0;

	specialCache = [];

	for (i = 0; i < $_list_length(ops); i += 1) {
		@type('int') op = $_list_get(ops, i);
		@type('Array<int>') args = $_list_get(opArgs, i);
		if (op == OpCodes.CLASS_DEFINITION) {
			nameId = $_list_get(args, 0);
			classId = $_dictionary_get(nameIdToClassId, nameId, 0);
			lastClassId = classId;
			value = [classId];
		} else if (op == OpCodes.CALL_CONSTRUCTOR) {
			nameId = $_list_get(args, 1);
			classId = $_dictionary_get(nameIdToClassId, nameId, 0);
			value = [classId];
		} else if (op == OpCodes.CALL_BASE_CONSTRUCTOR) {
			classInfo = classTable[lastClassId];
			baseClassId = classInfo[3];
			value = [baseClassId];
		} else {
			value = null;
		}
		
		$_list_push(specialCache, value);
	}

	stack = new StackFrame(
		0, // pc
		{}, // locals
		[], // valueStack
		[], // args
		null, // previous
		false, // returnValueUsed
		null); // object context

	p = new ProgramData(
		stack,
		ops,
		opArgs,
		stringArgs,
		specialCache,
		[], // identifiers
		{}, // inv_identifiers
		[], // literal table
		classTable,
		classMethods,
		false, // ticker registered
		$_list_new($_list_length(ops)), // token data
		0, // user code start
		StackFrame$stack.locals, // global var scope
		[], // original source code data
		[], // integerSwitchLookups
		[], // stringSwitchLookups
		generatePrimitiveMethodLookupTable(),
		0
		);

	$_set_program_data(p);
	
	runTick();
}

function runTick() {
	@type('ProgramData') p = $_get_program_data();

	if (%%%PLATFORM_IS_ASYNC%%%) {
		if (!ProgramData$p.tickerRegistered) {
			ProgramData$p.tickerRegistered = true;
			$_register_ticker();
		}

		$_begin_frame();

		error = interpret(
			ProgramData$p.stackTop,
			ProgramData$p.ops,
			ProgramData$p.args,
			ProgramData$p.stringArgs,
			ProgramData$p.identifiers,
			ProgramData$p.inv_identifiers,
			ProgramData$p.literalTable,
			ProgramData$p.classTable,
			ProgramData$p.classMethods,
			ProgramData$p.specialCache,
			ProgramData$p.globalVarScope);
		if (error == null) {
			// do nothing, let the next tick occur
			$_register_timeout();
		} else {
			if ($_string_length(error) > 0) {
				// error message and stack trace
				$_print(error);
			}
			// execution ended, either with error or gracefully.
			$_unregister_ticker();
		}
		return null;
	} else {
		while (true) {
			@type('string') error = interpret(
				ProgramData$p.stackTop,
				ProgramData$p.ops,
				ProgramData$p.args,
				ProgramData$p.stringArgs,
				ProgramData$p.identifiers,
				ProgramData$p.inv_identifiers,
				ProgramData$p.literalTable,
				ProgramData$p.classTable,
				ProgramData$p.classMethods,
				ProgramData$p.specialCache,
				ProgramData$p.globalVarScope);
			if (error == null) {
				$_pause_for_frame();
			} else if (error == '') {
				// empty string means the execution came to an end.
				return null;
			} else {
				// error message and stack trace
				$_print(error);
				return null;
			}
		}
	}
}
