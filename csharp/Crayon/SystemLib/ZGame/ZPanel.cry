
enum _ZPanelStretchDirection {
	LEFT,
	RIGHT,
	UP,
	DOWN,
	BOTH,

}

class ZPanel : ZElement {
	constructor() : base() {
		this._Z_is_container = true;
		this._Z_is_stack_panel = false;
		this._Z_children = [];
		this._Z_panel_width = null;
		this._Z_panel_width_type = _ZBoundsType.NONE;
		this._Z_panel_height = null;
		this._Z_panel_height_type = _ZBoundsType.NONE;
	}


	function _Z_precompute_bounds() {
		switch (this._Z_width_type) {
			case _ZBoundsType.NONE:
				pix_w = 0;
				per_w = 1.0;
				break;
			case _ZBoundsType.RATIO:
				pix_w = 0;
				per_w = this._Z_width;
				break;
			case _ZBoundsType.PIXELS:
				pix_w = this._Z_width;
				per_w = 0;
				break;
		}
		switch (this._Z_height_type) {
			case _ZBoundsType.NONE:
				pix_h = 0;
				per_h = 1.0;
				break;
			case _ZBoundsType.RATIO:
				pix_h = 0;
				per_h = this._Z_height;
				break;
			case _ZBoundsType.PIXELS:
				pix_h = this._Z_height;
				per_h = 0;
				break;
		}

		// Children have no bearing on the panel's overall size.
		// They will simply overflow if they exceed the bounds.
		i = 0;
		for (child : this._Z_children) {
			child._Z_precompute_bounds();
		}

		this._Z_set_precomputed_bounds(pix_w, pix_h, per_w, per_h);
	}


	function get_element_by_id(id) {
		if (this._Z_id == id) return this;
		for (child : this._Z_children) {
			if (child._Z_id == id) return child;
			if (child._Z_is_container) {
				element = child.get_element_by_id(id);
				if (element != null) {
					return element;
				}
			}
		}
		return null;
	}

	function add_element(element) {
		// TODO: verify that no cycle is created.
		this._Z_children.add(element);
		return this;
	}

	function add_elements(elements) {
		for (element : elements) {
			this.add_element(element);
		}
		return this;
	}

	function render(left, top, width, height) {
		if (this._Z_rotation != null) {
			$assert(false, "Rotation on panels not supported yet.");
		}
		
		right = left + width;
		bottom = top + height;

		for (child : this._Z_children) {
			y_alloc = child._Z_precomputed_height_pixels;
			if (child._Z_precomputed_height_ratio > 0) {
				t = height - y_alloc;
				if (t > 0) {
					y_alloc += $floor(t * child._Z_precomputed_height_ratio);
				}
			}
			x_alloc = child._Z_precomputed_width_pixels;
			if (child._Z_precomputed_width_ratio > 0) {
				t = width - x_alloc;
				if (t > 0) {
					x_alloc += $floor(t * child._Z_precomputed_width_ratio);
				}
			}
			switch (child._Z_valignment) {
				case ZVerticalAlignment.TOP: y = top; break;
				case ZVerticalAlignment.CENTER: y = top + (height - y_alloc) / 2; break;
				case ZVerticalAlignment.BOTTOM: y = top + height - y_alloc; break;
			}
			switch (child._Z_halignment) {
				case ZHorizontalAlignment.LEFT: x = left; break;
				case ZHorizontalAlignment.CENTER: x = left + (width - x_alloc) / 2; break;
				case ZHorizontalAlignment.RIGHT: x = left + (width - x_alloc) / 2; break;
			}
			child.render(x, y, x_alloc, y_alloc);
		}
	}
}
