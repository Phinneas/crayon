
enum _ZPanelStretchDirection {
	LEFT,
	RIGHT,
	UP,
	DOWN,
	BOTH,

}

class ZPanel : ZElement {
	constructor() : base() {
		this._Z_is_container = true;
		this._Z_is_stack_panel = false;
		this._Z_children = [];
		this._Z_panel_width = null;
		this._Z_panel_width_type = _ZBoundsType.NONE;
		this._Z_panel_height = null;
		this._Z_panel_height_type = _ZBoundsType.NONE;
	}

	function get_element_by_id(id) {
		if (this._Z_id == id) return this;
		for (child : this._Z_children) {
			if (child._Z_id == id) return child;
			if (child._Z_is_container) {
				element = child.get_element_by_id(id);
				if (element != null) {
					return element;
				}
			}
		}
		return null;
	}

	function add_element(element) {
		// TODO: verify that no cycle is created.
		


		this._Z_children.add(element);
		return this;
	}

	function add_elements(elements) {
		for (element : elements) {
			this.add_element(element);
		}
		return this;
	}

	function render(left, top, width, height) {
		if (this._Z_rotation != null) {
			$assert(false, "Rotation on panels not supported yet.");
		}
		
		right = left + width;
		bottom = top + height;

		switch (this._Z_alignment) {
			case ZAlignment.TOP_LEFT:
				startX = left;
				startY = top;
				hstretch = _ZPanelStretchDirection.RIGHT;
				vstretch = _ZPanelStretchDirection.DOWN;
				break;

			case ZAlignment.TOP_CENTER:
				startX = (left + right) / 2;
				startY = top;
				hstretch = _ZPanelStretchDirection.BOTH;
				vstretch = _ZPanelStretchDirection.DOWN;
				break;

			case ZAlignment.TOP_RIGHT:
				startX = right;
				startY = top;
				hstretch = _ZPanelStretchDirection.LEFT;
				vstretch = _ZPanelStretchDirection.DOWN;
				break;

			case ZAlignment.CENTER_LEFT:
				startX = left;
				startY = (top + bottom) / 2;
				hstretch = _ZPanelStretchDirection.RIGHT;
				vstretch = _ZPanelStretchDirection.BOTH;
				break;

			case ZAlignment.CENTER:
				startX = (left + right) / 2;
				startY = (top + bottom) / 2;
				hstretch = _ZPanelStretchDirection.BOTH;
				vstretch = _ZPanelStretchDirection.BOTH;
				break;

			case ZAlignment.CENTER_RIGHT:
				startX = right;
				startY = (top + bottom) / 2;
				hstretch = _ZPanelStretchDirection.LEFT;
				vstretch = _ZPanelStretchDirection.BOTH;
				break;

			case ZAlignment.BOTTOM_LEFT:
				startX = left;
				startY = bottom;
				hstretch = _ZPanelStretchDirection.RIGHT;
				vstretch = _ZPanelStretchDirection.UP;
				break;
				
			case ZAlignment.BOTTOM_CENTER:
				startX = (left + right) / 2;
				startY = bottom;
				hstretch = _ZPanelStretchDirection.BOTH;
				vstretch = _ZPanelStretchDirection.UP;
				break;

			case ZAlignment.BOTTOM_RIGHT:
				startX = right;
				startY = bottom;
				hstretch = _ZPanelStretchDirection.LEFT;
				vstretch = _ZPanelStretchDirection.UP;
				break;
				
			default:
				$assert(false, "Unknown ZPanel alignment.");
				break;
		}
		
		switch (this._Z_panel_width_type) {
			case _ZBoundsType.PIXELS: width = this._Z_panel_width; break;
			case _ZBoundsType.PERCENTAGE: width = $floor(.01 * this._Z_panel_width * width); break;
		}
		
		switch (this._Z_panel_height_type) {
			case _ZBoundsType.PIXELS: height = this._Z_panel_height; break;
			case _ZBoundsType.PERCENTAGE: height = $floor(.01 * this._Z_panel_height * height); break;
		}

		switch (hstretch) {
			case _ZPanelStretchDirection.BOTH:
				left = startX - width / 2;
				right = left + width;
				break;
			case _ZPanelStretchDirection.LEFT:
				right = startX;
				left = right - width;
				break;
			case _ZPanelStretchDirection.RIGHT:
				left = startX;
				right = left + width;
				break;
		}
		
		switch (vstretch) {
			case _ZPanelStretchDirection.BOTH:
				top = startY - height / 2;
				bottom = top + height;
				break;
			case _ZPanelStretchDirection.UP:
				bottom = startX;
				top = bottom - height;
				break;
			case _ZPanelStretchDirection.DOWN:
				top = startY;
				bottom = startY + height;
				break;
		}

		for (element : this._Z_children) {
			if (element._Z_is_container) {
				element.render(left, top, right - left, bottom - top);
			} else {
				width = element._Z_reported_width;
				height = element._Z_reported_height;
				switch (element._Z_alignment) {
					case ZAlignment.TOP_LEFT: element.render(left, top, width, height); break;
					case ZAlignment.TOP_CENTER: element.render((left + right - width) / 2, top, width, height); break;
					case ZAlignment.TOP_RIGHT: element.render(right - width, top, width, height); break;
					case ZAlignment.CENTER_LEFT: element.render(left, (top + bottom - height) / 2, width, height); break;
					case ZAlignment.CENTER: element.render((left + right - width) / 2, (top + bottom - height) / 2, width, height); break;
					case ZAlignment.CENTER_RIGHT: element.render(right - width, (top + bottom - height) / 2, width, height); break;
					case ZAlignment.BOTTOM_LEFT: element.render(left, bottom - height, width, height); break;
					case ZAlignment.BOTTOM_CENTER: element.render((left + right - width) / 2, bottom - height, width, height); break;
					case ZAlignment.BOTTOM_RIGHT: element.render(right - width, bottom - height, width, height); break;
					default: $assert(false, "Invalid ZPanel alignment"); break;
				}

				// Totally temporary hack to unblock testing
				if (this._Z_is_stack_panel) {
					switch (this._Z_direction) {
						case ZStackDirection.DOWN:
							top += height;
							break;
					}
				}

			}
		}
	}
}
