
enum _ZPanelStretchDirection {
	LEFT,
	RIGHT,
	UP,
	DOWN,
	BOTH,

}

class ZPanel : ZElement {
	constructor() : base() {
		this._Z_is_container = true;
		this._Z_is_stack_panel = false;
		this._Z_children = [];
		this._Z_panel_width = null;
		this._Z_panel_width_type = _ZBoundsType.NONE;
		this._Z_panel_height = null;
		this._Z_panel_height_type = _ZBoundsType.NONE;
	}


	function _Z_precompute_bounds() {
		switch (this._Z_width_type) {
			case _ZBoundsType.NONE:
				pix_w = 0;
				per_w = 1.0;
				break;
			case _ZBoundsType.RATIO:
				pix_w = 0;
				per_w = this._Z_width;
				break;
			case _ZBoundsType.PIXELS:
				pix_w = this._Z_width;
				per_w = 0;
				break;
		}
		switch (this._Z_height_type) {
			case _ZBoundsType.NONE:
				pix_h = 0;
				per_h = 1.0;
				break;
			case _ZBoundsType.RATIO:
				pix_h = 0;
				per_h = this._Z_height;
				break;
			case _ZBoundsType.PIXELS:
				pix_h = this._Z_height;
				per_h = 0;
				break;
		}

		// Children have no bearing on the panel's overall size.
		// They will simply overflow if they exceed the bounds.
		for (child : this._Z_children) {
			if (child._Z_visibility != ZVisibility.COLLAPSED) {
				child._Z_precompute_bounds();
			}
		}

		this._Z_set_precomputed_bounds(pix_w, pix_h, per_w, per_h);
	}


	function get_element_by_id(id) {
		if (this._Z_id == id) return this;
		for (child : this._Z_children) {
			if (child._Z_id == id) return child;
			if (child._Z_is_container) {
				element = child.get_element_by_id(id);
				if (element != null) {
					return element;
				}
			}
		}
		return null;
	}

	function add_element(element) {
		// TODO: verify that no cycle is created.
		this._Z_children.add(element);
		return this;
	}

	function add_elements(elements) {
		for (element : elements) {
			this.add_element(element);
		}
		return this;
	}

	function hit_test(x, y) {
		for (i = this._Z_children.length - 1; i >= 0; --i) {
			child = this._Z_children[i];
			if (child._Z_visibility == ZVisibility.VISIBLE) {
				if (child._Z_is_container) {
					element = child.hit_test(x, y);
					if (element != null) {
						return element;
					}
				} else {
					if (x >= child._Z_rendered_left && x < child._Z_rendered_right &&
						y >= child._Z_rendered_top && y < child._Z_rendered_bottom) {
						return child;
					}
				}
			}
		}
		return null;
	}

	function render(left, top, width, height) {
		if (this._Z_rotation != null) {
			$assert(false, "Rotation on panels not supported yet.");
		}
		
		right = left + width;
		bottom = top + height;

		for (child : this._Z_children) {
			if (child._Z_visibility == ZVisibility.VISIBLE) {
				x_margins = child._Z_margin_left + child._Z_margin_right;
				y_margins = child._Z_margin_top + child._Z_margin_top;

				y_alloc = child._Z_precomputed_height_pixels;
				if (child._Z_precomputed_height_ratio > 0) {
					t = height - y_alloc - y_margins;
					if (t > 0) {
						y_alloc += $floor(t * child._Z_precomputed_height_ratio);
					}
				}

				x_alloc = child._Z_precomputed_width_pixels;
				if (child._Z_precomputed_width_ratio > 0) {
					t = width - x_alloc - x_margins;
					if (t > 0) {
						x_alloc += $floor(t * child._Z_precomputed_width_ratio);
					}
				}

				switch (child._Z_valignment) {
					case ZVerticalAlignment.TOP: y = top + child._Z_margin_top; break;
					case ZVerticalAlignment.CENTER: y = top + (height - y_alloc) / 2; break;
					case ZVerticalAlignment.BOTTOM: y = top + height - y_alloc - child._Z_margin_bottom; break;
				}

				switch (child._Z_halignment) {
					case ZHorizontalAlignment.LEFT: x = left + child._Z_margin_left; break;
					case ZHorizontalAlignment.CENTER: x = left + (width - x_alloc) / 2; break;
					case ZHorizontalAlignment.RIGHT: x = left + width - x_alloc - child._Z_margin_right; break;
				}

				child._Z_rendered_left = x;
				child._Z_rendered_right = x + x_alloc;
				child._Z_rendered_top = y;
				child._Z_rendered_bottom = y + y_alloc;

				child.render(x, y, x_alloc, y_alloc);
			}
		}
	}
}
