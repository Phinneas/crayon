enum OpCodes
{
	ADD_LITERAL, // 1: type, 2: value (0 or 1 for false/true or an integer. String values are in the string arg. Float values are as well, and are parsed.)
	ADD_NAME, // name is string arg. ID is the order in which this was encountered.
	ASSIGN_FUNCTION_ARG, // 1: variable name ID, 2: function arg value index to assign to variable
	ASSIGN_FUNCTION_ARG_AND_JUMP, // 1: variable name ID, 2: function arg value index to assign to variable, 3: PC offset to jump if arg is present (otherwise don't assign and keep going)
	ASSIGN_INDEX, // no args. value stack: [root, index, value]
	ASSIGN_STEP, // name ID of step. value stack: [root, value]
	ASSIGN_THIS_STEP, // name ID of step. value stack: [value]
	ASSIGN_VAR, // 1: variable name ID
	BINARY_OP,
	BOOLEAN_NOT, // no args.
	BREAK, // no ops. This should be resolved into a jump before actually being run.
	BUILD_SWITCH_INT, // 2n args: (1: integer key, 2: offset value) <- repeat, the order that these appear indicates the switch ID
	BUILD_SWITCH_STRING, // 1: switch ID, 2: offset, string arg: value
	CALL_BASE_CONSTRUCTOR, // 1: num args passed
	CALL_CONSTRUCTOR, // 1: arg count, 2: class name ID, 3: output used | special cache 1: Class ID
	CALL_FUNCTION, // 1: num args passed
	CALL_FRAMEWORK_FUNCTION, // 1: function ID (not identifier ID). Since these are defined by the framework, function count is verified at compile time and popped accordingly at runtime by the op itself.
	CALL_FUNCTION_ON_VARIABLE, // 1: function ID, 2: num args passed
	CLASS_DEFINITION, // Super complicated. See documentation in OO_readme.txt.
	CONTINUE, // no ops. This should be resolved into a jump before actually being run.
	DEF_ORIGINAL_CODE, // 1: file ID, string arg: source code of that file with a preceding line for the file name.
	DEF_DICTIONARY, // 1: size
	DEF_LIST, // 1: size
	DEREF_DOT, // 1: step ID
	DUPLICATE_STACK_TOP, // 1: how many stack items should be duplicated?. get the top n of the stack, and just duplicate it
	FUNCTION_DEFINITION, // 1: function name ID, 2: PC offset where first line of function is, 3: total number of args; check to make sure not exceeded
	INDEX,
	INDEX_INT,
	INDEX_STRING,
	ITERATION_STEP, // stack is in the following state: [index, variable ID, list]. If the index exceeds the length of the list, the loop stops and jumps over the body of the loop, which is arg 1.
	JUMP,
	JUMP_IF_FALSE,
	JUMP_IF_FALSE_NO_POP,
	JUMP_IF_TRUE,
	JUMP_IF_TRUE_NO_POP,
	LITERAL, // 1: literal ID in the literal table
	LITERAL_STREAM, // repeated version of the LITERAL op. Literals are listed in reverse order.
	NEGATIVE_SIGN, // no args. pop, flip, push.
	POP, // no args. pop value from value stack.
	RETURN,
	RETURN_NULL,
	SWITCH_INT, // 1: integer switch ID, 2: offset for default case
	SWITCH_STRING, // 1: string switch ID, 2: offset for default case
	THIS, // pushes the current object context onto the stack.
	TOKEN_DATA, // 1: PC of where this token data applies (you must add the value of USER_CODE_START at runtime), 2: line, 3: col, 4: file ID
	USER_CODE_START, // 1: PC of where the user-compiled code begins. PC in token information will add this number.
	VARIABLE, // 1: id
	VARIABLE_STREAM, // first n: id, followed by -1, followed by triplets of token data (line, col, fileID)
	VERIFY_IS_LIST, // verifies the last item on the stack is a list
}

// Needs to be in sync with BinaryOps.cs
// TODO: sync dynamically
enum BinaryOps
{
	ADDITION = 0,
	SUBTRACTION = 1,
	MULTIPLICATION = 2,
	DIVISION = 3,
	MODULO = 4,
	EXPONENT = 5,
	BITWISE_AND = 6,
	BITWISE_OR = 7,
	BITWISE_XOR = 8,
	BIT_SHIFT_LEFT = 9,
	BIT_SHIFT_RIGHT = 10,
	EQUALS = 12,
	NOT_EQUALS = 13,
	LESS_THAN = 14,
	LESS_THAN_OR_EQUAL = 15,
	GREATER_THAN = 16,
	GREATER_THAN_OR_EQUAL = 17,
}

const MAX_OP = BinaryOps.GREATER_THAN_OR_EQUAL + 1;

enum Types {
	NULL = %%%TYPE_ID_NULL%%%,
	BOOLEAN = %%%TYPE_ID_BOOLEAN%%%,
	INTEGER = %%%TYPE_ID_INTEGER%%%,
	FLOAT = %%%TYPE_ID_FLOAT%%%,
	STRING = %%%TYPE_ID_STRING%%%,
	LIST = %%%TYPE_ID_LIST%%%,
	DICTIONARY = %%%TYPE_ID_DICTIONARY%%%,
	INSTANCE = %%%TYPE_ID_INSTANCE%%%,
	FUNCTION = %%%TYPE_ID_FUNCTION%%%,
	SYS_FUNCTION = %%%TYPE_ID_SYS_FUNCTION%%%,
	METHOD = %%%TYPE_ID_METHOD%%%,
	SYS_METHOD = %%%TYPE_ID_SYS_METHOD%%%,
	NATIVE_OBJECT = %%%TYPE_ID_NATIVE_OBJECT%%%,
}

function getTypeFromId(id) {
	switch (id) {
		case Types.NULL: return "null";
		case Types.BOOLEAN: return "boolean";
		case Types.INTEGER: return "integer";
		case Types.FLOAT: return "float";
		case Types.STRING: return "string";
		case Types.LIST: return "list";
		case Types.DICTIONARY: return "dictionary";
		case Types.INSTANCE: return "instance"; // TODO: make this more specific
		case Types.FUNCTION: return "function";
		case Types.SYS_FUNCTION: return "system function";
		case Types.METHOD: return "method";
		case Types.SYS_METHOD: return "system method";
		case Types.NATIVE_OBJECT: return "native object"; // TODO: make this more specific
	}
}

function getBinaryOpFromId(id) {
	switch (id) {
		case BinaryOps.ADDITION: return '+';
		case BinaryOps.SUBTRACTION: return '-';
		case BinaryOps.MULTIPLICATION: return '*';
		case BinaryOps.DIVISION: return '/';
		case BinaryOps.MODULO: return '%';
		case BinaryOps.EXPONENT: return '**';
		case BinaryOps.BITWISE_AND: return '&';
		case BinaryOps.BITWISE_OR: return '|';
		case BinaryOps.BITWISE_XOR: return '^';
		case BinaryOps.BIT_SHIFT_LEFT: return '<<';
		case BinaryOps.BIT_SHIFT_RIGHT: return '>>';
		case BinaryOps.EQUALS: return '==';
		case BinaryOps.NOT_EQUALS: return '!=';
		case BinaryOps.LESS_THAN: return '<';
		case BinaryOps.LESS_THAN_OR_EQUAL: return '<=';
		case BinaryOps.GREATER_THAN: return '>';
		case BinaryOps.GREATER_THAN_OR_EQUAL: return '>=';
		default: return "unknown";
	}
}

enum NativeObjectTypes {
	SCREEN = 1,
}

const MAX_TYPE = Types.NATIVE_OBJECT + 1;

// Dictionaries in Crayon can only have 3 types of keys: integers, strings, and objects
// Dictionaries can hold any of these, but only hold one type at a time
struct DictImpl {
	keyLookup,
	valueLookup,
	size,
	keyType
}

struct StackFrame {
	pc,
	locals,
	valueStack,
	args,
	previous,
	returnValueUsed,
	objectContext
}

struct Code {
	ops,
	args,
	stringArgs
}

struct Token {
	lineIndex,
	colIndex,
	fileId
}

struct Value {
	type,
	internalValue
}

specialCache = [];

struct ProgramData {
	stackTop,
	ops,
	args,
	stringArgs,
	specialCache,
	identifiers,
	inv_identifiers,
	literalTable,
	classTable,
	classMethods,
	tickerRegistered,
	tokenData,
	userCodeStart,
	globalVarScope,
	sourceCode,
	integerSwitchLookups,
	stringSwitchLookups,
}

// If I assign to this global directly, the translator will think this is a local variable.
pd = [null];
instanceCounter = [0];

function buildLiteral(type, value, floatTable, stringTable) {
	if (type == Types.NULL) return VALUE_NULL;
	if (type == Types.INTEGER) return build_integer(value);
	if (type == Types.FLOAT) return $_list_get(floatTable, value);
	if (type == Types.STRING) return $_list_get(stringTable, value);
	if (type == Types.BOOLEAN && value == 1) return VALUE_TRUE;
	if (type == Types.BOOLEAN && value == 0) return VALUE_FALSE;
	return null;
}

function copyDictionary(dict) {
	key_list = $_dictionary_get_keys(dict);
	output = {};
	for (i = 0; i < $_list_length(key_list); i += 1) {
		key = $_list_get(key_list, i);
		value = $_dictionary_get(dict, key, 0);
		$_dictionary_set(output, key, value);
	}
	return output;
}

function main() {

	byteCode = loadByteCode();
	ops = Code$byteCode.ops;
	opArgs = Code$byteCode.args;
	stringArgs = Code$byteCode.stringArgs;

	nameToClassId = {};
	classTable = [null]; // class ID 0 is not valid. First entry should be at index 1.
	classMethods = [null]; // same here

	for (i = 0; i < $_list_length(ops); i += 1) {
		op = $_list_get(ops, i);
		if (op == OpCodes.CLASS_DEFINITION) {
			args = $_list_get(opArgs, i);
			id = $_list_length(classTable);
			lastClassId = id;
			nameId = $_list_get(args, 0);
			$_dictionary_set(nameToClassId, nameId, id);
			baseClassNameId = $_list_get(args, 1);
			constructorArgsCount = $_list_get(args, 2); // -1 if no constructor present
			methodCount = $_list_get(args, 3);

			baseClassId = 0;
			if (baseClassNameId > 0) {
				// base class name not found is a compile time error.
				baseClassId = $_dictionary_get(nameToClassId, baseClassNameId, 0);
			}
			
			if (baseClassId == 0) {
				methodLookup = {};
			} else {
				methodLookup = copyDictionary($_list_get(classMethods, baseClassId));
			}

			for (j = 0; j < methodCount; j += 1) {
				methodNameId = $_list_get(args, (j * 3) + 4);
				pcOffset = $_list_get(args, (j * 3) + 5);
				maxArgs = $_list_get(args, (j * 3) + 6);

				methodData = [
					methodNameId,
					maxArgs,
					i + pcOffset
				];

				$_dictionary_set(methodLookup, methodNameId, methodData);
			}

			classRow = [
				nameId,
				0, // PC of constructor (0 if absent, overriden to correct value below)
				0, // maximum arg count of constructor
				baseClassId,
				0, // do base constructors need to be invoked? (overridden below if yes)
				0 // Is class usable? This gets changed to 1 when the class definition is encountered.
			];
			if (constructorArgsCount >= 0) {
				classRow[1] = i + 2;
				classRow[2] = constructorArgsCount;
			}
			
			if (baseClassId != 0) {
				baseClassInfo = $_list_get(classTable, baseClassId);
				if ($_list_get(baseClassInfo, 1) > 0 || $_list_get(baseClassInfo, 4) == 1) {
					classRow[4] = 1;
				}
			}

			$_list_push(classTable, classRow);
			$_list_push(classMethods, methodLookup);
		}
	}

	lastClassId = 0;

	for (i = 0; i < $_list_length(ops); i += 1) {
		op = $_list_get(ops, i);
		args = $_list_get(opArgs, i);
		if (op == OpCodes.CLASS_DEFINITION) {
			nameId = $_list_get(args, 0);
			classId = $_dictionary_get(nameToClassId, nameId, 0);
			lastClassId = classId;
			value = [classId];
		} else if (op == OpCodes.CALL_CONSTRUCTOR) {
			nameId = $_list_get(args, 1);
			classId = $_dictionary_get(nameToClassId, nameId, 0);
			value = [classId];
		} else if (op == OpCodes.CALL_BASE_CONSTRUCTOR) {
			classInfo = classTable[lastClassId];
			baseClassId = classInfo[3];
			value = [baseClassId];
		} else {
			value = null;
		}
		
		$_list_push(specialCache, value);
	}

	stack = new StackFrame(
		0, // pc
		{}, // locals
		[], // valueStack
		[], // args
		null, // previous
		false, // returnValueUsed
		null); // object context

	p = new ProgramData(
		stack,
		ops,
		opArgs,
		stringArgs,
		specialCache,
		[], // identifiers
		{}, // inv_identifiers
		[], // literal table
		classTable,
		classMethods,
		false,
		$_list_new($_list_length(ops)),
		0,
		StackFrame$stack.locals,
		[], // original source code data
		[], // integerSwitchLookups
		[] // stringSwitchLookups
		);

	pd[0] = p;
	
	runTick();
}

function runTick() {
	p = pd[0];

	if (%%%PLATFORM_IS_ASYNC%%%) {
		if (!ProgramData$p.tickerRegistered) {
			ProgramData$p.tickerRegistered = true;
			$_register_ticker();
		}

		$_begin_frame();

		error = interpret(
			ProgramData$p.stackTop,
			ProgramData$p.ops,
			ProgramData$p.args,
			ProgramData$p.stringArgs,
			ProgramData$p.identifiers,
			ProgramData$p.inv_identifiers,
			ProgramData$p.literalTable,
			ProgramData$p.classTable,
			ProgramData$p.classMethods,
			ProgramData$p.specialCache,
			ProgramData$p.globalVarScope);
		if (error == null) {
			// do nothing, let the next tick occur
			$_register_timeout();
		} else {
			if ($_string_length(error) > 0) {
				// error message and stack trace
				$_print(error);
			}
			// execution ended, either with error or gracefully.
			$_unregister_ticker();
		}
	} else {
		while (true) {
			error = interpret(
				ProgramData$p.stackTop,
				ProgramData$p.ops,
				ProgramData$p.args,
				ProgramData$p.stringArgs,
				ProgramData$p.identifiers,
				ProgramData$p.inv_identifiers,
				ProgramData$p.literalTable,
				ProgramData$p.classTable,
				ProgramData$p.classMethods,
				ProgramData$p.specialCache,
				ProgramData$p.globalVarScope);
			if (error == null) {
				$_pause_for_frame();
			} else if (error == '') {
				// empty string means the execution came to an end.
				return;
			} else {
				// error message and stack trace
				$_print(error);
				return;
			}
		}
	}
}

VALUE_NULL = new Value(Types.NULL, null);

const INTEGER_POSITIVE_CACHE = 1000;
const INTEGER_NEGATIVE_CACHE = 100;
INTEGERS_POS = [];
INTEGERS_NEG = [];
for (i = 0; i < INTEGER_POSITIVE_CACHE; i += 1) {
	$_list_push(INTEGERS_POS, new Value(Types.INTEGER, i));
}
NEG_INTEGERS = [];
for (i = 0; i < INTEGER_NEGATIVE_CACHE; i += 1) {
	$_list_push(INTEGERS_NEG, new Value(Types.INTEGER, -i));
}
VALUE_TRUE = new Value(Types.BOOLEAN, true);
VALUE_FALSE = new Value(Types.BOOLEAN, false);
VALUE_EMPTY_STRING = new Value(Types.STRING, "");

function build_integer(value) {
	if (value < 0) {
		if (value > -INTEGER_NEGATIVE_CACHE) {
			return INTEGERS_NEG[-value];
		}
	} else {
		if (value < INTEGER_POSITIVE_CACHE) {
			return INTEGERS_POS[value];
		}
	}
	return new Value(Types.INTEGER, value);
}

PRIMITIVE_METHODS = {
	// no need to weakly cast ints to strings, since the optimizer will consolidate everything into inline strings
	Types.STRING + "contains": %%%PRIMITIVE_METHOD_STRING_CONTAINS%%%,
	Types.STRING + "endsWith": %%%PRIMITIVE_METHOD_STRING_ENDSWITH%%%,
	Types.STRING + "lower": %%%PRIMITIVE_METHOD_STRING_LOWER%%%,
	Types.STRING + "reverse": %%%PRIMITIVE_METHOD_STRING_REVERSE%%%,
	Types.STRING + "replace": %%%PRIMITIVE_METHOD_STRING_REPLACE%%%,
	Types.STRING + "split": %%%PRIMITIVE_METHOD_STRING_SPLIT%%%,
	Types.STRING + "startsWith": %%%PRIMITIVE_METHOD_STRING_STARTSWITH%%%,
	Types.STRING + "trim": %%%PRIMITIVE_METHOD_STRING_TRIM%%%,
	Types.STRING + "upper": %%%PRIMITIVE_METHOD_STRING_UPPER%%%,

	Types.LIST + "add": %%%PRIMITIVE_METHOD_LIST_ADD%%%,
	Types.LIST + "clear": %%%PRIMITIVE_METHOD_LIST_CLEAR%%%,
	Types.LIST + "contains": %%%PRIMITIVE_METHOD_LIST_CONTAINS%%%,
	Types.LIST + "insert": %%%PRIMITIVE_METHOD_LIST_INSERT%%%,
	Types.LIST + "join": %%%PRIMITIVE_METHOD_LIST_JOIN%%%,
	Types.LIST + "pop": %%%PRIMITIVE_METHOD_LIST_POP%%%,
	Types.LIST + "remove": %%%PRIMITIVE_METHOD_LIST_REMOVE%%%,
	Types.LIST + "reverse": %%%PRIMITIVE_METHOD_LIST_REVERSE%%%,
	Types.LIST + "shuffle": %%%PRIMITIVE_METHOD_LIST_SHUFFLE%%%,

	Types.DICTIONARY + "clear": %%%PRIMITIVE_METHOD_DICTIONARY_CLEAR%%%,
	Types.DICTIONARY + "contains": %%%PRIMITIVE_METHOD_DICTIONARY_CONTAINS%%%,
	Types.DICTIONARY + "entries": %%%PRIMITIVE_METHOD_DICTIONARY_ENTRIES%%%,
	Types.DICTIONARY + "get": %%%PRIMITIVE_METHOD_DICTIONARY_GET%%%,
	Types.DICTIONARY + "keys": %%%PRIMITIVE_METHOD_DICTIONARY_KEYS%%%,
	Types.DICTIONARY + "remove": %%%PRIMITIVE_METHOD_DICTIONARY_REMOVE%%%,
	Types.DICTIONARY + "values": %%%PRIMITIVE_METHOD_DICTIONARY_VALUES%%%,
};

function valueToString(value) {
	type = Value$value.type;
	value = Value$value.internalValue;
	if (type == Types.NULL) return "null";
	if (type == Types.BOOLEAN) {
		if (value) return "true";
		return "false";
	}
	if (type == Types.INTEGER || type == Types.FLOAT || type == Types.STRING) return $_string_cast_strong(value);
	if (type == Types.LIST) {
		// TODO: this will recurse infinitely if the list points to itself somehow.
		output = "[";
		for (i = 0; i < $_list_length(value); i += 1) {
			if (i > 0) output += ", ";
			output += valueToString($_list_get(value, i));
		}
		output += "]";
		return output;
	}
	if (type == Types.INSTANCE) {
		output = "INSTANCE: " + $_string_cast_strong(value);
		return output;
	}
	return "TODO: toString for " + getTypeFromId(type);
}

function interpret(stack, ops, args, stringArgs, identifiers, inv_identifiers, literalTable, classTable, classMethods, specialCache, globals) {
	valueStack = StackFrame$stack.valueStack;
	locals = StackFrame$stack.locals;
	LENGTH_ID = $_dictionary_get(inv_identifiers, 'length', -999);
	p = $_list_get(pd, 0);
	integerSwitches = ProgramData$p.integerSwitchLookups;
	stringSwitches = ProgramData$p.stringSwitchLookups;
	while (true) {
		row = args[StackFrame$stack.pc];
		switch (ops[StackFrame$stack.pc]) {

			case OpCodes.ADD_LITERAL:
				$_comment('ADD_LITERAL');
				type = $_list_get(row, 0);
				if (type == Types.NULL) {
					$_list_push(literalTable, VALUE_NULL);
				} else if (type == Types.BOOLEAN) {
					if (row[1] == 1) {
						$_list_push(literalTable, VALUE_TRUE);
					} else {
						$_list_push(literalTable, VALUE_FALSE);
					}
				} else if (type == Types.INTEGER) {
					$_list_push(literalTable, build_integer(row[1]));
				} else if (type == Types.FLOAT) {
					$_list_push(literalTable, new Value(Types.FLOAT, $_string_parse_float(stringArgs[StackFrame$stack.pc])));
				} else if (type == Types.STRING) {
					$_list_push(literalTable, new Value(Types.STRING, stringArgs[StackFrame$stack.pc]));
				}
				break;

			case OpCodes.ADD_NAME:
				$_comment('ADD_NAME');
				name = $_list_get(stringArgs, StackFrame$stack.pc);
				id = $_list_length(identifiers);
				$_dictionary_set(inv_identifiers, name, id);
				$_list_push(identifiers, name);
				if (name == 'length') {
					LENGTH_ID = id;
				}
				break;

			case OpCodes.ASSIGN_FUNCTION_ARG:
				$_comment('ASSIGN_FUNCTION_ARG');
				nameId = row[0];
				index = row[1];
				if (index >= $_list_length(StackFrame$stack.args)) {
					// pass in previous stack so that it's pointing at the spot where you invoke the function.
					return killExecution(StackFrame$stack.previous, "Not enough arguments supplied.");
				}
				value = $_list_get(StackFrame$stack.args, row[1]);
				$_dictionary_set(locals, nameId, value);
				break;

			case OpCodes.ASSIGN_FUNCTION_ARG_AND_JUMP:
				$_comment('ASSIGN_FUNCTION_ARG_AND_JUMP');
				nameId = row[0];
				index = row[1];
				if (index < $_list_length(StackFrame$stack.args)) {
					value = $_list_get(StackFrame$stack.args, index);
					$_dictionary_set(locals, nameId, value);
					StackFrame$stack.pc += row[2];
				}
				break;

			case OpCodes.ASSIGN_INDEX:
				$_comment('ASSIGN_INDEX');
				value = $_list_pop(valueStack);
				index = $_list_pop(valueStack);
				root = $_list_pop(valueStack);
				type = Value$root.type;
				if (type == Types.LIST) {
					if (Value$index.type == Types.INTEGER) {
						index = Value$index.internalValue;
						list = Value$root.internalValue;
						if (index < 0) {
							return killExecution(stack, "Index must be non-negative.");
						} else if (index >= $_list_length(list)) {
							return killExecution(stack, "Index is out of range.");
						} else {
							$_list_set(list, index, value);
						}
					} else {
						return killExecution(stack, "List index must be an integer.");
					}
				} else if (type == Types.DICTIONARY) {
					nativeKeyType = Value$index.type;
					if (nativeKeyType == Types.INTEGER) {
						nativeKey = Value$index.internalValue;
					} else if (nativeKeyType == Types.STRING) {
						nativeKey = Value$index.internalValue;
					} else if (nativeKeyType == Types.INSTANCE) {
						nativeKey = $_list_get(Value$index.internalValue, 2); // object ID
					} else {
						return killExecution(stack, "Invalid key for a dictionary.");
					}

					dictImpl = Value$root.internalValue;
					nonEmpty = DictImpl$dictImpl.size > 0;
					if (nonEmpty && DictImpl$dictImpl.keyType != nativeKeyType) {
						return killExecution(stack, "Cannot have multiple keys in one dictionary with different types.");
					}
					if (!$_dictionary_contains(DictImpl$dictImpl.keyLookup, nativeKey)) {
						$_dictionary_set(DictImpl$dictImpl.keyLookup, nativeKey, index);
						DictImpl$dictImpl.size += 1;
						if (!nonEmpty) {
							DictImpl$dictImpl.keyType = nativeKeyType;
						}
					}
					$_dictionary_set(DictImpl$dictImpl.valueLookup, nativeKey, value);
				} else {
					return killExecution(stack, getTypeFromId(type) + " type does not support indexing");
				}
				break;

			case OpCodes.ASSIGN_STEP:
				$_comment('ASSIGN_STEP');
				value = $_list_pop(valueStack);
				obj = $_list_pop(valueStack);
				nameId = row[0];
				if (Value$obj.type == Types.INSTANCE) {
					dict = $_list_get(Value$obj.internalValue, 1);
					$_dictionary_set(dict, nameId, value);
				} else {
					killExecution(stack, "Cannot assign to a field on this type.");
				}
				break;
				
			case OpCodes.ASSIGN_THIS_STEP:
				$_comment('ASSIGN_THIS_STEP');
				obj = StackFrame$stack.objectContext; // obj will never be null because that is a compile error.
				// TODO: prevent assignment to methods
				value = $_list_pop(valueStack);
				nameId = row[0];
				dict = $_list_get(Value$obj.internalValue, 1);
				$_dictionary_set(dict, nameId, value);
				break;

			case OpCodes.ASSIGN_VAR:
				$_comment('ASSIGN_VAR');
				thing = $_list_pop(valueStack);
				$_dictionary_set(locals, row[0], thing);
				break;

			case OpCodes.BINARY_OP:
				$_comment('BINARY_OP');
				rightObj = $_list_pop(valueStack);
				leftObj = $_list_pop(valueStack);

				leftType = Value$leftObj.type;
				if (rightObj == null) {
					return killExecution(stack, "WAT: " + valueToString(leftObj));
				}
				rightType = Value$rightObj.type;
				
				left = Value$leftObj.internalValue;
				right = Value$rightObj.internalValue;
				
				// TODO: special switch for when left == right
				op = $_list_get(row, 0);
				output = null;
				if (op == BinaryOps.EQUALS || op == BinaryOps.NOT_EQUALS) {
					if (leftType == rightType) {
						if (leftType <= Types.DICTIONARY) { // Note that this exists. Changing the ordering of types in the enum definition could ruin ==/!=
							if (left == right) { // may have to change if a platform doesn't support == for strings
								output = VALUE_TRUE;
							} else {
								output = VALUE_FALSE;
							}
						} else if (leftType == Types.INSTANCE) {
							if ($_list_get(left, 2) == $_list_get(right, 2)) {
								output = VALUE_TRUE;
							} else {
								output = VALUE_FALSE;
							}
						}
					} else {
						if ((leftType == Types.INTEGER && rightType == Types.FLOAT) || (leftType == Types.FLOAT && rightType == Types.INTEGER)) {
							if (left == right) {
								output = VALUE_TRUE;
							} else {
								output = VALUE_FALSE;
							}
						} else {
							output = VALUE_FALSE;
						}
					}
					
					if (output != null) {
						if (op == BinaryOps.NOT_EQUALS) {
							if (Value$output.internalValue) {
								output = VALUE_FALSE;
							} else {
								output = VALUE_TRUE;
							}
						}
						//$_list_push(valueStack, output);
					} else {
						return killExecution(stack, "== and != not defined here yet.");
					}
				} else if ((leftType == Types.STRING || rightType == Types.STRING) && op == BinaryOps.ADDITION && leftType != Types.NULL && rightType != Types.NULL) {
					output = new Value(Types.STRING, valueToString(leftObj) + valueToString(rightObj));
				} else {
					switch
						{((MAX_TYPE * MAX_OP + MAX_OP) * MAX_TYPE + MAX_TYPE)} // maximum possible value
						((((Value$leftObj.type * MAX_OP) + op) * MAX_TYPE) + Value$rightObj.type) {
						
						// int ** int
						case (Types.INTEGER * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.INTEGER:
							$_comment('int ** int');
							if (right == 0) output = INTEGERS_POS[1];
							else if (right > 0)
								output = build_integer($_int($_exponent(left, right)));
							else
								output = new Value(Types.FLOAT, $_exponent(left, right));
							break;

						// int ** float
						case (Types.INTEGER * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.FLOAT:
							$_comment('int ** float');
							output = new Value(Types.FLOAT, 0.0 + $_exponent(left, right));
							break;

						// float ** int
						case (Types.FLOAT * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.INTEGER:
							$_comment('float ** int');
							// add 0.0 just in case underlying platform likes to fall back to integer when possible
							output = new Value(Types.FLOAT, 0.0 + $_exponent(left, right));
							break;

						// float ** float
						case (Types.FLOAT * MAX_OP + BinaryOps.EXPONENT) * MAX_TYPE + Types.FLOAT:
							$_comment('float ** float');
							output = new Value(Types.FLOAT, 0.0 + $_exponent(left, right));
							break;
						
						// float % float
						case (Types.FLOAT * MAX_OP + BinaryOps.MODULO) * MAX_TYPE + Types.FLOAT:
							$_comment('float % float');
							if (right == 0) return killExecution(stack, "Modulo by 0");
							t = left % right;
							if (t < 0) t += right;
							output = new Value(Types.FLOAT, t);
							break;

						// int % int
						case (Types.INTEGER * MAX_OP + BinaryOps.MODULO) * MAX_TYPE + Types.INTEGER:
							$_comment('int % int');
							if (right == 0) return killExecution(stack, "Modulo by 0");
							t = left % right;
							if (t < 0) t += right;
							output = build_integer(t);
							break;

						// list + list
						case (Types.LIST * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.LIST:
							$_comment('list + list');
							output = new Value(Types.LIST, $_list_concat(left, right)); break;

						// int + int
						case (Types.INTEGER * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.INTEGER:
							$_comment('int + int');
							output = build_integer(left + right); break;

						// float + int
						case (Types.FLOAT * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.INTEGER:
							$_comment('float + int');
							output = new Value(Types.FLOAT, left + right); break;

						// int + float
						case (Types.INTEGER * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.FLOAT:
							$_comment('int + float');
							output = new Value(Types.FLOAT, left + right); break;

						// float + float
						case (Types.FLOAT * MAX_OP + BinaryOps.ADDITION) * MAX_TYPE + Types.FLOAT:
							$_comment('float + float');
							output = new Value(Types.FLOAT, left + right); break;
							
						// int - int
						case (Types.INTEGER * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.INTEGER:
							$_comment('int - int');
							output = build_integer(left - right); break;
							
						// int - float
						case (Types.INTEGER * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.FLOAT:
							$_comment('int - float');
							output = new Value(Types.FLOAT, left - right); break;
							
						// float - int
						case (Types.FLOAT * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.INTEGER:
							$_comment('float - int');
							output = new Value(Types.FLOAT, left - right); break;
							
						// float - float
						case (Types.FLOAT * MAX_OP + BinaryOps.SUBTRACTION) * MAX_TYPE + Types.FLOAT:
							$_comment('float - float');
							output = new Value(Types.FLOAT, left - right); break;

						// int * int
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('int * int');
							output = build_integer(left * right); break;

						// float * int
						case (Types.FLOAT * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('float * int');
							output = new Value(Types.FLOAT, left * right); break;

						// int * float
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.FLOAT:
							$_comment('int * float');
							output = new Value(Types.FLOAT, left * right); break;

						// float * float
						case (Types.FLOAT * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.FLOAT:
							$_comment('float * float');
							output = new Value(Types.FLOAT, left * right); break;
							
						// int / int
						case (Types.INTEGER * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.INTEGER:
							$_comment('int / int');
							if (right == 0) return killExecution(stack, "Division by 0"); output = build_integer($_unsafe_integer_division(left, right)); break;
							
						// int / float
						case (Types.INTEGER * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.FLOAT:
							$_comment('int / float');
							if (right == 0) return killExecution(stack, "Division by 0"); output = new Value(Types.FLOAT, $_unsafe_float_division(left, right)); break;

						// float / int
						case (Types.FLOAT * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.INTEGER:
							$_comment('float / int');
							if (right == 0) return killExecution(stack, "Division by 0"); output = new Value(Types.FLOAT, $_unsafe_float_division(left, right)); break;

						// float / float
						case (Types.FLOAT * MAX_OP + BinaryOps.DIVISION) * MAX_TYPE + Types.FLOAT:
							$_comment('float / float');
							if (right == 0) return killExecution(stack, "Division by 0"); output = new Value(Types.FLOAT, $_unsafe_float_division(left, right)); break;

						// int < int
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('int < int');
							if (left < right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// int <= int
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('int <= int');
							if (left <= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;
							
						// float < int
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('float < int');
							if (left < right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float <= int
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('float <= int');
							if (left <= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;
							
						// int < float
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('int < float');
							if (left < right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// int <= float
						case (Types.INTEGER * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('int <= float');
							if (left <= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float < float
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('float < float');
							if (left < right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float <= float
						case (Types.FLOAT * MAX_OP + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('float <= float');
							if (left <= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// int >= int
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('int >= int');
							if (left >= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						//int > int
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('int > int');
							if (left > right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float >= int
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.INTEGER:
							$_comment('float >= int');
							if (left >= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float > int
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.INTEGER:
							$_comment('float > int');
							if (left >= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// int >= float
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('int >= float');
							if (left >= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// int > float
						case (Types.INTEGER * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('int > float');
							if (left > right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float >= float
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE + Types.FLOAT:
							$_comment('float >= float');
							if (left >= right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// float > float
						case (Types.FLOAT * MAX_OP + BinaryOps.GREATER_THAN) * MAX_TYPE + Types.FLOAT:
							$_comment('float > float');
							if (left > right) output = VALUE_TRUE; else output = VALUE_FALSE; break;

						// list * int
						case (Types.LIST * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.INTEGER:
							$_comment('list * int');
							t = [];
							while (right > 0) {
								$_list_push(t, left);
								right -= 1;
							}
							output = new Value(Types.LIST, t);
							break;
							
						// int * list
						case (Types.INTEGER * MAX_OP + BinaryOps.MULTIPLICATION) * MAX_TYPE + Types.LIST:
							$_comment('int * list');
							t = [];
							while (left > 0) {
								$_list_push(t, right);
								left -= 1;
							}
							output = new Value(Types.LIST, t);
							break;

						default:
							$_comment('unrecognized op');
							return killExecution(stack, "The '" + getBinaryOpFromId($_list_get(row, 0)) + "' operator is not supported for these types: " + getTypeFromId(Value$leftObj.type) + " and " + getTypeFromId(Value$rightObj.type));
							break;
					}
				}

				$_list_push(valueStack, output);
				break;

			case OpCodes.BOOLEAN_NOT:
				$_comment('BOOLEAN_NOT');
				value = $_list_pop(valueStack);
				if (Value$value.type != Types.BOOLEAN) return killExecution(stack, "Boolean expected.");
				if (Value$value.internalValue) {
					$_list_push(valueStack, VALUE_FALSE);
				} else {
					$_list_push(valueStack, VALUE_TRUE);
				}
				break;

			case OpCodes.BUILD_SWITCH_INT:
				$_comment('BUILD_SWITCH_INT');
				integerSwitchLookup = {};
				for (i = 0; i < $_list_length(row); i += 2) {
					$_dictionary_set(integerSwitchLookup, $_list_get(row, i), $_list_get(row, i + 1));
				}
				p = $_list_get(pd, 0);
				$_list_push(ProgramData$p.integerSwitchLookups, integerSwitchLookup);
				break;

			case OpCodes.BUILD_SWITCH_STRING:
				$_comment('BUILD_SWITCH_STRING');
				allLookups = ProgramData$p.stringSwitchLookups;
				id = $_list_get(row, 0);
				while ($_list_length(allLookups) <= id) {
					$_list_push(allLookups, {});
				}
				lookup = $_list_get(allLookups, id);
				key = $_list_get(stringArgs, StackFrame$stack.pc);
				$_dictionary_set(lookup, key, $_list_get(row, 1));
				break;

			case OpCodes.CALL_BASE_CONSTRUCTOR:
				$_comment('CALL_BASE_CONSTRUCTOR');
				sc_row = $_list_get(specialCache, StackFrame$stack.pc);
				classId = $_list_get(sc_row, 0);
				classData = $_list_get(classTable, classId);
				value = StackFrame$stack.objectContext;
				
				// This is copied identically below in CALL_CONSTRUCTOR
				pc = $_list_get(classData, 1);
				argCount = $_list_get(row, 0);
				if (pc != 0) {
					funcArgs = [];
					while (argCount > 0) {
						$_list_push(funcArgs, $_list_pop(valueStack));
						argCount -= 1;
					}
					if ($_list_get(row, 0) > 1) {
						$_list_reverse_in_place(funcArgs);
					}

					valueStack = [];
					locals = {};
					stack = new StackFrame(pc - 1, locals, valueStack, funcArgs, stack, false, value);
				} else {
					$_list_push(valueStack, value);
				}
				break;

			case OpCodes.CALL_CONSTRUCTOR:
				$_comment('CALL_CONSTRUCTOR');
				sc_row = $_list_get(specialCache, StackFrame$stack.pc);
				classId = $_list_get(sc_row, 0);
				instanceCounter[0] += 1;
				value = new Value(Types.INSTANCE, [classId, {}, instanceCounter[0]]);
				classData = $_list_get(classTable, classId);
				if (classData[5] == 0) {
					return killExecution(stack, "This class has not been defined yet.");
				}
				pc = $_list_get(classData, 1);
				argCount = $_list_get(row, 0);
				if (pc != 0) {
					funcArgs = [];
					returnValueUsed = $_list_get(row, 2) == 1;
					while (argCount > 0) {
						$_list_push(funcArgs, $_list_pop(valueStack));
						argCount -= 1;
					}
					if ($_list_get(row, 0) > 1) {
						$_list_reverse_in_place(funcArgs);
					}

					if (returnValueUsed) {
						$_list_push(valueStack, value);
					}

					valueStack = [];
					locals = {};
					stack = new StackFrame(pc - 1, locals, valueStack, funcArgs, stack, false, value);
				} else {
					$_list_push(valueStack, value);
				}
				break;

			case OpCodes.CALL_FRAMEWORK_FUNCTION:
				$_comment('CALL_FRAMEWORK_FUNCTION');
				// TODO: the types for these values must be verified.
				// The arg count is verified to be in the correct range at compile time.
				// However if there are optional arguments, the number of args used in this call are located in row[2]
				output = VALUE_NULL;
				switch (row[0]) {
					case %%%FF_ABS%%%:
						value = $_list_pop(valueStack);
						if (Value$value.type == Types.INTEGER) {
							if (Value$value.internalValue < 0) {
								output = build_integer(-Value$value.internalValue);
							} else {
								output = value;
							}
						} else if (Value$value.type == Types.FLOAT) {
							if (Value$value.internalValue < 0) {
								output = new Value(Types.FLOAT, -Value$value.internalValue);
							} else {
								output = value;
							}
						} else {
							return killExecution(stack, "$abs requires a number as input.");
						}
						break;

					case %%%FF_ARCTAN2%%%:
						x = $_list_pop(valueStack);
						y = $_list_pop(valueStack);
						$_insert_platform_code('ff_arctan2');
						break;

					case %%%FF_ASSERT%%%:
						msg = $_list_pop(valueStack);
						value = $_list_pop(valueStack);
						if (Value$value.type != Types.BOOLEAN || !Value$value.internalValue) {
							return killExecution(stack, "Assertion failed: " + valueToString(msg));
						}
						break;

					case %%%FF_BLIT_IMAGE%%%:
						y = $_list_pop(valueStack);
						x = $_list_pop(valueStack);
						image = $_list_pop(valueStack);
						$_insert_platform_code('ff_blit_image');
						break;
						
					case %%%FF_CLOCK_TICK%%%:
						programdata = pd[0];
						ProgramData$programdata.stackTop = stack;
						StackFrame$stack.pc += 1;
						return null;
						// this extra break is not a mistake. Python translation will get confused without the break here. Ultimately I plan to make this smart enough that it'll figure it out, but it's not a high priority.
						break;

					case %%%FF_COS%%%:
						x = $_list_pop(valueStack);
						$_insert_platform_code('ff_cos');
						break;

					case %%%FF_CURRENT_TIME%%%:
						$_insert_platform_code('ff_current_time');
						break;
						
					case %%%FF_DOWNLOAD_IMAGE%%%:
						url = $_list_pop(valueStack);
						key = $_list_pop(valueStack);
						$_insert_platform_code('ff_download_image');
						break;

					case %%%FF_DRAW_ELLIPSE%%%:
						alpha = $_list_pop(valueStack);
						blue = $_list_pop(valueStack);
						green = $_list_pop(valueStack);
						red = $_list_pop(valueStack);
						height = $_list_pop(valueStack);
						width = $_list_pop(valueStack);
						top = $_list_pop(valueStack);
						left = $_list_pop(valueStack);
						$_insert_platform_code('ff_draw_ellipse');
						break;

					case %%%FF_DRAW_LINE%%%:
						alpha = $_list_pop(valueStack);
						blue = $_list_pop(valueStack);
						green = $_list_pop(valueStack);
						red = $_list_pop(valueStack);
						width = $_list_pop(valueStack);
						y2 = $_list_pop(valueStack);
						x2 = $_list_pop(valueStack);
						y1 = $_list_pop(valueStack);
						x1 = $_list_pop(valueStack);
						$_insert_platform_code('ff_draw_line');
						break;

					case %%%FF_DRAW_RECTANGLE%%%:
						alpha = $_list_pop(valueStack);
						blue = $_list_pop(valueStack);
						green = $_list_pop(valueStack);
						red = $_list_pop(valueStack);
						height = $_list_pop(valueStack);
						width = $_list_pop(valueStack);
						y = $_list_pop(valueStack);
						x = $_list_pop(valueStack);
						$_insert_platform_code('ff_draw_rectangle');
						break;

					case %%%FF_FILL_SCREEN%%%:
						blue = $_list_pop(valueStack);
						green = $_list_pop(valueStack);
						red = $_list_pop(valueStack);
						$_insert_platform_code('ff_fill_screen');
						break;
						
					case %%%FF_FLIP_IMAGE%%%:
						y = $_list_pop(valueStack);
						x = $_list_pop(valueStack);
						img = $_list_pop(valueStack);
						$_insert_platform_code('ff_flip_image');
						break;

					case %%%FF_FLOOR%%%:
						value = $_list_pop(valueStack);
						$_insert_platform_code('ff_floor');
						break;

					case %%%FF_GET_EVENTS%%%:
						$_insert_platform_code('ff_get_events');
						break;
						
					case %%%FF_GET_IMAGE%%%:
						key = $_list_pop(valueStack);
						$_insert_platform_code('ff_get_image');
						break;
						
					case %%%FF_GET_IMAGE_HEIGHT%%%:
						value = $_list_pop(valueStack);
						$_insert_platform_code('ff_get_image_height');
						break;

					case %%%FF_GET_IMAGE_WIDTH%%%:
						value = $_list_pop(valueStack);
						$_insert_platform_code('ff_get_image_width');
						break;

					case %%%FF_INITIALIZE_GAME%%%: 
						fps = $_list_pop(valueStack);
						$_insert_platform_code('ff_initialize_game');
						break;
						
					case %%%FF_INITIALIZE_SCREEN%%%:
						height = $_list_pop(valueStack);
						width = $_list_pop(valueStack);
						$_insert_platform_code('ff_initialize_screen');
						break;
						
					case %%%FF_INITIALIZE_SCREEN_SCALED%%%:
						pheight = $_list_pop(valueStack);
						pwidth = $_list_pop(valueStack);
						height = $_list_pop(valueStack);
						width = $_list_pop(valueStack);
						$_insert_platform_code('ff_initialize_screen_scaled');
						break;
						
					case %%%FF_IS_IMAGE_LOADED%%%:
						key = $_list_pop(valueStack);
						$_insert_platform_code('ff_is_image_loaded');
						break;

					case %%%FF_PARSE_INT%%%:
						value = $_list_pop(valueStack);
						$_insert_platform_code('ff_parse_int');
						break;

					case %%%FF_PRINT%%%: 
						value = $_list_pop(valueStack);
						string1 = valueToString(value);
						$_insert_platform_code('ff_print'); 
						break;
					case %%%FF_RANDOM%%%:
						$_insert_platform_code('ff_random');
						break;
					case %%%FF_SET_TITLE%%%:
						value = $_list_pop(valueStack);
						value = valueToString(value);
						$_insert_platform_code('ff_set_title');
						break;

					case %%%FF_SIN%%%:
						x = $_list_pop(valueStack);
						$_insert_platform_code('ff_sin');
						break;


					case %%%FF_TYPEOF%%%:
						value = $_list_pop(valueStack);

						switch (Value$value.type) {
							case Types.NULL: t = "null"; break;
							case Types.INTEGER: t = "integer"; break;
							case Types.FLOAT: t = "float"; break;
							case Types.STRING: t = "string"; break;
							case Types.LIST: t = "list"; break;
							case Types.DICTIONARY: t = "dictionary"; break;
							case Types.INSTANCE: t = "instance"; break;
							case Types.FUNCTION: t = "function"; break;
							case Types.METHOD: t = "method"; break;
							case Types.SYS_METHOD: t = "primitive_method"; break;
							case Types.NATIVE_OBJECT: t = "native_system_object"; break;
							default: t = "unknown_type"; break;
						}
						output = new Value(Types.STRING, t);
						break;
					default: 
						return killExecution(stack, "Invalid framework function: " + $_string_cast_weak(row[0])); 
						break;
				}
				if (row[1] == 1) {
					$_list_push(valueStack, output);
				}
				break;

			case OpCodes.CALL_FUNCTION:
				$_comment('CALL_FUNCTION');
				// This is mostly replicated below. Be sure to keep changes in sync.
				func = $_list_pop(valueStack);
				funcArgs = [];
				argCount = $_list_get(row, 0);
				returnValueUsed = $_list_get(row, 1) == 1;
				while (argCount > 0) {
					$_list_push(funcArgs, $_list_pop(valueStack));
					argCount -= 1;
				}
				if ($_list_get(row, 0) > 1) {
					$_list_reverse_in_place(funcArgs);
				}
				funcType = Value$func.type;
				if (funcType == Types.SYS_METHOD) {
					sysMethod = Value$func.internalValue;
					context = $_list_get(sysMethod, 0);
					methodId = $_list_get(sysMethod, 1);
					error = callSystemMethod(methodId, context, funcArgs, valueStack, returnValueUsed);
					if (error != null) {
						return killExecution(stack, error);
					}
				} else if (funcType == Types.METHOD) {
					methodData = Value$func.internalValue;
					obj = methodData[0];
					pc = methodData[1];
					maxArgs = methodData[2];
					if (maxArgs < $_list_length(funcArgs)) {
						return killExecution(stack, "Too many args were passed in.");
					}
					valueStack = [];
					locals = {};
					stack = new StackFrame(pc - 1, locals, valueStack, funcArgs, stack, returnValueUsed, obj);
				} else if (funcType == Types.SYS_FUNCTION) {
					return killExecution(stack, "TODO: invoke system function");
				} else if (funcType == Types.FUNCTION) {
					valueStack = [];
					locals = {};
					stack = new StackFrame(Value$func.internalValue[0], locals, valueStack, funcArgs, stack, returnValueUsed, null);
				} else {
					return killExecution(stack, "Cannot invoke " + getTypeFromId(funcType) + " like a function.");
				}
				break;

			case OpCodes.CALL_FUNCTION_ON_VARIABLE:
				$_comment('CALL_FUNCTION_ON_VARIABLE');
				// This is mostly replicated above. Be sure to keep changes in sync.
				funcArgs = [];
				argCount = row[1];
				returnValueUsed = $_list_get(row, 2) == 1;
				while (argCount > 0) {
					$_list_push(funcArgs, $_list_pop(valueStack));
					argCount -= 1;
				}
				if ($_list_get(row, 1) > 1) {
					$_list_reverse_in_place(funcArgs);
				}
				funcPointer = $_dictionary_get(locals, row[0], null);
				if (funcPointer == null) {
					funcPointer = $_dictionary_get(globals, row[0], null);
				}

				if (funcPointer != null) {
					
					type = Value$funcPointer.type;
					if (type == Types.FUNCTION) {
						valueStack = [];
						locals = {};
						stack = new StackFrame(Value$funcPointer.internalValue[0], locals, valueStack, funcArgs, stack, returnValueUsed, null);
					} else {
						return killExecution(stack, "Cannot invoke " + getTypeFromId(type) + " types like a function.");
					}
				} else {
					return killExecution(stack, "That function is not defined: '" + identifiers[row[0]] + "'");
				}
				break;

			case OpCodes.CLASS_DEFINITION:
				$_comment('CLASS_DEFINITION');
				sc_row = $_list_get(specialCache, StackFrame$stack.pc);
				classId = $_list_get(sc_row, 0);
				classInfo = $_list_get(classTable, classId);
				classInfo[5] = 1;
				break;

			case OpCodes.DEF_DICTIONARY:
				$_comment('DEF_DICT');
				dictKeyLookup = {};
				dictValueLookup = {};
				size = row[0];
				keyType = Types.INTEGER; // always ignored when size is 0
				prevType = null;
				first = true;
				anticipatedSize = size;
				while (size > 0) {
					value = $_list_pop(valueStack);
					key = $_list_pop(valueStack);
					keyType = Value$key.type;
					if (first) prevType = keyType;
					if (!first && keyType != prevType) return killExecution(stack, "Cannot have multiple key types in one dictionary.");

					if (keyType == Types.INTEGER || keyType == Types.STRING) {
						nativeKey = Value$key.internalValue;
					} else if (keyType == Types.INSTANCE) {
						obj = Value$key.internalValue;
						objId = $_list_get(obj, 2);
						nativeKey = objId;
					} else {
						return killExecution(stack, "Only integers, strings, and objects can be used as dictionary keys.");
					}

					$_dictionary_set(dictKeyLookup, nativeKey, key);
					$_dictionary_set(dictValueLookup, nativeKey, value);

					first = false;
					size -= 1;
				}

				if ($_dictionary_size(dictKeyLookup) != anticipatedSize) {
					return killExecution(stack, "Key collision"); // TODO: do a better job of figuring out where this collision is.
				}

				dict = new Value(Types.DICTIONARY, new DictImpl(dictKeyLookup, dictValueLookup, anticipatedSize, keyType));
				$_list_push(valueStack, dict);
				break;

			case OpCodes.DEF_LIST:
				$_comment('DEF_LIST');
				value = [];
				size = row[0];
				while (size > 0) {
					$_list_push(value, $_list_pop(valueStack));
					size -= 1;
				}
				$_list_reverse_in_place(value);
				$_list_push(valueStack, new Value(Types.LIST, value));
				break;

			case OpCodes.DEF_ORIGINAL_CODE:
				fileId = $_list_get(row, 0);
				p = pd[0];
				content = $_list_get(ProgramData$p.stringArgs, StackFrame$stack.pc);
				codeLookup = ProgramData$p.sourceCode;
				while ($_list_length(codeLookup) <= fileId) {
					$_list_push(codeLookup, null);
				}
				$_list_set(codeLookup, fileId, content);
				break;

			case OpCodes.DEREF_DOT:
				$_comment('DEREF_DOT');
				// TODO: no caching of methods occur here because ideally, I want to create another op for dotStepInvoke which eliminates the need to instantiate the method in 99.5% of cases.
				root = $_list_pop(valueStack);
				type = Value$root.type;
				if (type == Types.INSTANCE) {
					dict = $_list_get(Value$root.internalValue, 1);
					value = $_dictionary_get(dict, row[0], null);
					if (value == null) {
						classId = $_list_get(Value$root.internalValue, 0);
						method = $_dictionary_get($_list_get(classMethods, classId), row[0], null);
						if (method == null) {
							return killExecution(stack, "Field used before it was defined.");
						} else {
							value = new Value(Types.METHOD, [root, method[2], method[1]]); // context, pc, maxArgs
							$_dictionary_set(dict, row[0], value);
							$_list_push(valueStack, value);
						}
					} else {
						$_list_push(valueStack, value);
					}
				} else if (row[0] == LENGTH_ID) { // Length is a field. All other primitive type stuff is not.
					len = -1;
					if (type == Types.LIST) {
						// might need to revisit this if other platforms aren't as easy to do a list implementation?
						len = $_list_length(Value$root.internalValue);
					} else if (type == Types.DICTIONARY) {
						t = Value$root.internalValue;
						len = DictImpl$t.size;
					} else if (type == Types.STRING) {
						len = $_string_length(Value$root.internalValue);
					} else {
						return killExecution(stack, getTypeFromId(type) + " does not have a length property.");
					}

					if (len < INTEGER_POSITIVE_CACHE) {
						$_list_push(valueStack, INTEGERS_POS[len]);
					} else {
						$_list_push(valueStack, new Value(Types.INTEGER, len));
					}
				} else {
					// Everything else will presumably be hit 99% of the time via the DOT_STEP_INVOKE op instead of here, since they're methods. 
					// Therefore I'm not particularly concerned about optimizing the rest of this.

					primitive_method_id = $_dictionary_get(PRIMITIVE_METHODS, $_string_cast_weak(type) + identifiers[row[0]], -1);
					if (primitive_method_id == -1) {
						return killExecution(stack, getTypeFromId(type) + " type does not have a field called '" + identifiers[row[0]] + "'.");
					} else {
						$_list_push(valueStack, new Value(Types.SYS_METHOD, [root, primitive_method_id]));
					}
				}
				break;

			case OpCodes.DUPLICATE_STACK_TOP:
				$_comment('DUPLICATE_STACK_TOP');
				if (row[0] == 1) {
					$_list_push(valueStack, $_list_get(valueStack, $_list_length(valueStack) - 1));
				} else {
					for (i = 0; i < row[0]; i += 1) {
						$_list_push(valueStack, $_list_get(valueStack, $_list_length(valueStack) - row[0]));
					}
				}
				break;

			case OpCodes.FUNCTION_DEFINITION:
				$_comment('FUNCTION_DEFINITION');
				if (row[3] == 1) {
					
				} else {
					funcDef = new Value(Types.FUNCTION, 
						// PC                             Max arg count    Name ID]
						[StackFrame$stack.pc + row[1],    row[2],          identifiers[row[0]]]);
					$_list_push(valueStack, funcDef);
				}
				break;

			case OpCodes.INDEX:
				$_comment('INDEX');
				index = $_list_pop(valueStack);
				root = $_list_pop(valueStack);
				if (Value$root.type == Types.LIST) {
					if (Value$index.type != Types.INTEGER) {
						return killExecution(stack, "List index must be an integer.");
					} else {
						indexValue = Value$index.internalValue;
						listValue = Value$root.internalValue;
						if (indexValue < 0) return killExecution(stack, "List index cannot be negative.");
						else if (indexValue >= $_list_length(listValue)) return killExecution(stack, "List index is out of bounds");
						else {
							item = $_list_get(listValue, indexValue);
							$_list_push(valueStack, item);
						}
					}
				} else if (Value$root.type == Types.DICTIONARY) {
					dictImpl = Value$root.internalValue;
					nativeKeyType = Value$index.type;
					if (nativeKeyType != DictImpl$dictImpl.keyType) {
						return killExecution(stack, "Key not found.");
					} else {
						if (nativeKeyType == Types.INTEGER) {
							nativeKey = Value$index.internalValue;
						} else if (nativeKeyType == Types.STRING) {
							nativeKey = Value$index.internalValue;
						} else if (nativeKeyType == Types.INSTANCE) {
							nativeKey = $_list_get(Value$index.internalValue, 2);
						} else {
							return killExecution(stack, "Key not found.");
						}

						value = $_dictionary_get(DictImpl$dictImpl.valueLookup, nativeKey, null);
						if (value == null) return killExecution(stack, "Key not found.");
							
						$_list_push(valueStack, value);
					}
				} else if (Value$root.type == Types.STRING) {
					t = Value$root.internalValue;
					if (Value$index.type != Types.INTEGER) {
						return killExecution(stack, "indexes into strings must be integers.");
					}
					index = Value$index.internalValue;
					if (index < 0 || index >= $_string_length(t)) {
						return killExecution(stack, "String index out of range.");
					}
					$_list_push(valueStack, new Value(Types.STRING, $_string_char_at(t, index)));
				} else {
					return killExecution(stack, "Cannot index into this type: " + $_string_cast_weak(Value$root.type) + ", " + $_list_get(identifiers, args[StackFrame$stack.pc - 2][0]));
				}
				break;

			case OpCodes.INDEX_INT:
				$_comment('INDEX_INT');
				return killExecution(stack, "TODO: index int");
				break;

			case OpCodes.INDEX_STRING:
				$_comment('INDEX_STRING');
				return killExecution(stack, "TODO: index string");
				break;

			case OpCodes.ITERATION_STEP:
				$_comment('ITERATION_STEP');
				stacklen = $_list_length(valueStack);
				index = $_list_get(valueStack, stacklen - 3);
				varId = $_list_get(valueStack, stacklen - 2);
				list = $_list_get(valueStack, stacklen - 1);
				index = Value$index.internalValue;
				list = Value$list.internalValue;
				varId = Value$varId.internalValue;
				listlen = $_list_length(list);
				if (index < listlen) {
					$_dictionary_set(locals, varId, $_list_get(list, index));
				} else {
					StackFrame$stack.pc += row[0];
				}
				index += 1;
				$_list_set(valueStack, stacklen - 3, build_integer(index));
				break;

			case OpCodes.JUMP:
				$_comment('JUMP');
				StackFrame$stack.pc += row[0];
				break;
			
			case OpCodes.JUMP_IF_FALSE:
				$_comment('JUMP_IF_FALSE');
				expr = $_list_pop(valueStack);
				if (Value$expr.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if (!Value$expr.internalValue) {
					StackFrame$stack.pc += row[0];
				}
				break;

			case OpCodes.JUMP_IF_FALSE_NO_POP:
				$_comment('JUMP_IF_FALSE_NON_POP');
				expr = $_list_pop(valueStack);
				if (Value$expr.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if (!Value$expr.internalValue) {
					StackFrame$stack.pc += row[0];
					$_list_push(valueStack, VALUE_FALSE);
				}
				break;

			case OpCodes.JUMP_IF_TRUE:
				$_comment('JUMP_IF_TRUE');
				expr = $_list_pop(valueStack);
				if (Value$expr.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if (Value$expr.internalValue) {
					StackFrame$stack.pc += row[0];
				}
				break;

			case OpCodes.JUMP_IF_TRUE_NO_POP:
				$_comment('JUMP_IF_TRUE_NO_POP');
				expr = $_list_pop(valueStack);
				if (Value$expr.type != Types.BOOLEAN) {
					return killExecution(stack, "Boolean expected.");
				} else if (Value$expr.internalValue) {
					StackFrame$stack.pc += row[0];
					$_list_push(valueStack, VALUE_TRUE);
				}
				break;
				
			case OpCodes.LITERAL:
				$_comment('LITERAL');
				$_list_push(valueStack, $_list_get(literalTable, $_list_get(row, 0)));
				break;

			case OpCodes.LITERAL_STREAM:
				$_comment('LITERAL_STREAM');
				for (i = $_list_length(row) - 1; i >= 0; i -= 1) {
					$_list_push(valueStack, $_list_get(literalTable, $_list_get(row, i)));
				}
				break;

			case OpCodes.NEGATIVE_SIGN:
				$_comment('NEGATIVE_SIGN');
				value = $_list_pop(valueStack);
				t = Value$value.type;
				value = Value$value.internalValue;
				if (t == Types.INTEGER) {
					value = build_integer(-value);
				} else if (t == Types.FLOAT) {
					value = new Value(Types.FLOAT, -value);
				} else {
					return killExecution(stack, "Negative sign can only be applied to numbers. Found " + typeToString(t) + " instead.");
				}

				$_list_push(valueStack, value);
				break;

			case OpCodes.POP:
				$_comment('POP');
				$_list_pop(valueStack);
				break;

			case OpCodes.RETURN:
				$_comment('RETURN');
				returnValue = $_list_pop(valueStack);
				useReturnValue = StackFrame$stack.returnValueUsed;
				stack = StackFrame$stack.previous;
				if (stack == null) {
					StackFrame$stack.pc += 1;
					return '';
				}
				valueStack = StackFrame$stack.valueStack;
				locals = StackFrame$stack.locals;
				if (useReturnValue) {
					$_list_push(valueStack, returnValue);
				}
				break;
			
			case OpCodes.RETURN_NULL:
				$_comment('RETURN_NULL');
				useReturnValue = StackFrame$stack.returnValueUsed;
				stack = StackFrame$stack.previous;
				if (stack == null) {
					return '';
				}
				locals = StackFrame$stack.locals;
				valueStack = StackFrame$stack.valueStack;
				if (useReturnValue) {
					$_list_push(valueStack, VALUE_NULL);
				}
				break;

			case OpCodes.SWITCH_INT:
				$_comment('SWITCH_INT');
				value = $_list_pop(valueStack);
				if (Value$value.type == Types.INTEGER) {
					key = Value$value.internalValue;
					offset = $_dictionary_get($_list_get(integerSwitches, $_list_get(row, 0)), key, $_list_get(row, 1));
					StackFrame$stack.pc += offset;
				} else {
					return killExecution(stack, "Switch statement expects an integer.");
				}
				break;

			case OpCodes.SWITCH_STRING:
				$_comment('SWITCH_STRING');
				value = $_list_pop(valueStack);
				if (Value$value.type == Types.STRING) {
					key = Value$value.internalValue;
					offset = $_dictionary_get($_list_get(stringSwitches, $_list_get(row, 0)), key, $_list_get(row, 1));
					StackFrame$stack.pc += offset;
				} else {
					return killExecution(stack, "Switch statement expects a string.");
				}
				break;

			case OpCodes.THIS:
				$_comment('THIS');
				// will never be called outside of a method.
				$_list_push(valueStack, StackFrame$stack.objectContext);
				break;

			case OpCodes.TOKEN_DATA:
				$_comment('TOKEN_DATA');
				p = $_list_get(pd, 0);
				tokensByPc = ProgramData$p.tokenData;
				pc = $_list_get(row, 0) + ProgramData$p.userCodeStart;
				line = $_list_get(row, 1);
				col = $_list_get(row, 2);
				file = $_list_get(row, 3);
				tokens = $_list_get(tokensByPc, pc);
				if (tokens == null) {
					tokens = [];
					$_list_set(tokensByPc, pc, tokens);
				}
				$_list_push(tokens, new Token(line, col, file));
				break;

			case OpCodes.USER_CODE_START:
				$_comment('USER_CODE_START');
				value = $_list_get(row, 0);
				p = $_list_get(pd, 0);
				ProgramData$p.userCodeStart = value;
				break;

			case OpCodes.VARIABLE:
				$_comment('VARIABLE');
				value = $_dictionary_get(locals, row[0], null);
				if (value == null) {
					value = $_dictionary_get(globals, row[0], null);
					if (value == null) {
						return killExecution(stack, "Variable not defined: " + identifiers[row[0]]);
					} else {
						$_list_push(valueStack, value);
					}
				} else {
					$_list_push(valueStack, value);
				}
				break;

			case OpCodes.VARIABLE_STREAM:
				$_comment('VARIABLE_STREAM');
				// TODO: trim off the token data from the args now that this is done differently.
				for (i = 0; $_list_get(row, i) != -1; i += 1) {
					value = $_dictionary_get(locals, $_list_get(row, i), null);
					if (value == null) {
						value = $_dictionary_get(globals, $_list_get(row, i), null);
					}
					if (value == null) {
						sc_row = $_list_get(specialCache, StackFrame$stack.pc);
						fakeToken = $_list_get(sc_row, i);
						return killExecutionWithTokenOverride(stack, fakeToken, "Variable not defined: " + identifiers[$_list_get(row, i)]);
					} else {
						$_list_push(valueStack, value);
					}
				}
				break;

			case OpCodes.VERIFY_IS_LIST:
				$_comment('VERIFY_IS_LIST');
				value = $_list_pop(valueStack);
				if (Value$value.type != Types.LIST) {
					return killExecution(stack, "Expected a list.");
				}
				$_list_push(valueStack, value);
				break;

			default:
				$_comment('THIS SHOULD NEVER HAPPEN');
				return killExecution(stack, "Bad op code: " + $_string_cast_weak(ops[StackFrame$stack.pc]));
		}
		StackFrame$stack.pc += 1;
	}
}

function doEqualityComparisonAndReturnCode(a, b) {
	leftType = Value$a.type;
	rightType = Value$b.type;
	if (leftType == rightType || 
		(leftType == Types.INTEGER && rightType == Types.FLOAT) || 
		(leftType == Types.FLOAT && rightType == Types.INTEGER)) {
		output = false;
		left = Value$a.internalValue;
		right = Value$b.internalValue;
		if (leftType < Types.LIST) {
			if (left == right) {
				return 1;
			}
			return 0;
		}

		if (leftType == Types.INSTANCE) {
			if ($_list_get(left, 2) == $_list_get(right, 2)) {
				return 1;
			}
			return 0;
		}

		// == is not defined for this type. If a user needs to compare two things of one of the remaining types,
		// they are probably writing bad code.
		return 2;
	}
	return 0;
}

function wrongArgCountError(name, expected, actual) {
	if (expected == 0) {
		output = name + " does not accept any arguments.";
	} else if (expected == 1) {
		output = name + " accepts exactly 1 argument.";
	} else {
		output = name + " requires " + expected + " arguments.";
	}

	output += " Found: " + actual;
	return output;
}

function callSystemMethod(methodId, wrappedContext, funcArgs, valueStack, returnValueUsed) {
	// trusted switch. No weird values will occur. (assuming you implement all the methods you have in the lookup table)
	output = VALUE_NULL;
	context = Value$wrappedContext.internalValue;
	switch (methodId) {
		case %%%PRIMITIVE_METHOD_LIST_ADD%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("List add method", 1, $_list_length(funcArgs));
			$_list_push(context, $_list_get(funcArgs, 0));
			break;
		case %%%PRIMITIVE_METHOD_LIST_CLEAR%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("List clear method", 0, $_list_length(funcArgs));
			Value$wrappedContext.internalValue = [];
			break;
		case %%%PRIMITIVE_METHOD_LIST_CONTAINS%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("List contains method", 1, $_list_length(funcArgs));
			len = $_list_length(context);
			target = $_list_get(funcArgs, 0);
			output = VALUE_FALSE;
			for (i = 0; i < len; i += 1) {
				if (doEqualityComparisonAndReturnCode(target, $_list_get(context, i)) == 1) {
					output = VALUE_TRUE;
					i += len;
				}
			}
			break;
		case %%%PRIMITIVE_METHOD_LIST_INSERT%%%:
			if ($_list_length(funcArgs) != 2) return wrongArgCountError("List insert method", 2, $_list_length(funcArgs));
			index = $_list_get(funcArgs, 0);
			value = $_list_get(funcArgs, 1);
			if (Value$index.type != Types.INTEGER) return "First argument of list.insert needs to be an integer.";
			index = Value$index.internalValue;
			if (index < 0 || index > $_list_length(context)) return "Index out of bounds.";
			$_list_insert(context, Value$index.internalValue, value);
			break;
		case %%%PRIMITIVE_METHOD_LIST_JOIN%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("List join method", 1, $_list_length(funcArgs));
			sep = $_list_get(funcArgs, 0);
			// TODO: make first argument optional
			if (Value$sep.type != Types.STRING) return "Argument of list.join needs to be a string.";
			sb = [];
			sepstr = Value$sep.internalValue;
			len = $_list_length(context);
			for (i = 0; i < len; i += 1) {
				$_list_push(sb, valueToString($_list_get(context, i)));
			}
			value = $_list_join(sb, sepstr);
			output = new Value(Types.STRING, value);
			break;
		case %%%PRIMITIVE_METHOD_LIST_POP%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("List pop method", 0, $_list_length(funcArgs));
			if ($_list_length(context) == 0) return "Cannot pop from empty list.";
			output = $_list_get(context, $_list_last_index(context));
			$_list_pop(context);
			break;
		case %%%PRIMITIVE_METHOD_LIST_REMOVE%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("List remove method", 1, $_list_length(funcArgs));
			index = $_list_get(funcArgs, 0);
			if (Value$index.type != Types.INTEGER) return "First argument of list.remove needs to be an integer.";
			if (index < 0 || index >= $_list_length(context)) return "Index out of bounds.";
			output = $_list_get(context, index);
			$_list_remove_at(context, index);
			break;
		case %%%PRIMITIVE_METHOD_LIST_REVERSE%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("List reverse method", 0, $_list_length(funcArgs));
			$_list_reverse_in_place(context);
			break;
		case %%%PRIMITIVE_METHOD_LIST_SHUFFLE%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("List shuffle method", 0, $_list_length(funcArgs));
			$_list_shuffle_in_place(context);
			break;
		case %%%PRIMITIVE_METHOD_STRING_SPLIT%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("String split method", 1, $_list_length(funcArgs));
			sep = $_list_get(funcArgs, 0);
			if (Value$sep.type != Types.STRING) {
				return "Split method requires a string. Found a " + typeToString(Value$sep.type) + " instead.";
			}
			rawList = $_string_split(context, Value$sep.internalValue);
			wrappedList = [];
			for (i = 0; i < $_list_length(rawList); i += 1) {
				$_list_push(wrappedList, new Value(Types.STRING, $_list_get(rawList, i)));
			}
			output = new Value(Types.LIST, wrappedList);
			break;
		case %%%PRIMITIVE_METHOD_STRING_CONTAINS%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("String contains method", 1, $_list_length(funcArgs));
			item = $_list_get(funcArgs, 0);
			if (Value$item.type != Types.STRING) {
				return "String contains method requires a string. Found a " + typeToString(Value$item.type) + " instead.";
			}
			if ($_string_contains(context, Value$item.internalValue)) {
				output = VALUE_TRUE;
			} else {
				output = VALUE_FALSE;
			}
			break;
		case %%%PRIMITIVE_METHOD_STRING_ENDSWITH%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("String endsWith method", 1, $_list_length(funcArgs));
			item = $_list_get(funcArgs, 0);
			if (Value$item.type != Types.STRING) {
				return "String endsWith method requires a string. Found a " + typeToString(Value$item.type) + " instead.";
			}
			if ($_string_endswith(context, Value$item.internalValue)) {
				output = VALUE_TRUE;
			} else {
				output = VALUE_FALSE;
			}
			break;
		case %%%PRIMITIVE_METHOD_STRING_STARTSWITH%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("String startsWith method", 1, $_list_length(funcArgs));
			item = $_list_get(funcArgs, 0);
			if (Value$item.type != Types.STRING) {
				return "String startsWith method requires a string. Found a " + typeToString(Value$item.type) + " instead.";
			}
			if ($_string_startswith(context, Value$item.internalValue)) {
				output = VALUE_TRUE;
			} else {
				output = VALUE_FALSE;
			}
			break;
		case %%%PRIMITIVE_METHOD_STRING_UPPER%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("String upper method", 0, $_list_length(funcArgs));
			t = $_string_upper(context);
			output = new Value(Types.STRING, t);
			break;
		case %%%PRIMITIVE_METHOD_STRING_LOWER%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("String lower method", 0, $_list_length(funcArgs));
			t = $_string_lower(context);
			output = new Value(Types.STRING, t);
			break;
		case %%%PRIMITIVE_METHOD_STRING_TRIM%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("String trim method", 0, $_list_length(funcArgs));
			t = $_string_trim(context);
			output = new Value(Types.STRING, t);
			break;
		case %%%PRIMITIVE_METHOD_STRING_REVERSE%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("String reverse method", 0, $_list_length(funcArgs));
			t = $_string_reverse(context);
			output = new Value(Types.STRING, t);
			break;
		case %%%PRIMITIVE_METHOD_STRING_REPLACE%%%:
			if ($_list_length(funcArgs) != 2) return wrongArgCountError("String replace method", 2, $_list_length(funcArgs));
			a = $_list_get(funcArgs, 0);
			b = $_list_get(funcArgs, 1);

			if (Value$a.type != Types.STRING || Value$b.type != Types.STRING) {
				return "string replace must take in two strings as arguments.";
			}

			t = $_string_replace(context, Value$a.internalValue, Value$b.internalValue);
			output = new Value(Types.STRING, t);
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_CLEAR%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("Dictionary clear method", 0, $_list_length(funcArgs));
			DictImpl$context.keyLookup = {};
			DictImpl$context.valueLookup = {};
			DictImpl$context.size = 0;
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_GET%%%:
			if ($_list_length(funcArgs) != 2) return wrongArgCountError("Dictionary get method", 2, $_list_length(funcArgs));
			key = $_list_get(funcArgs, 0);
			defaultValue = $_list_get(funcArgs, 1);
			if (DictImpl$context.keyType != Value$key.type) {
				output = defaultValue;
			} else {
				valueLookup = DictImpl$context.valueLookup;
				keyValue = Value$key.internalValue;
				if (keyType == Types.INSTANCE) keyValue = $_list_get(keyValue, 2);
				value = $_dictionary_get(keyLookup, keyValue, null);
				if (value == null) {
					output = defaultValue;
				} else {
					output = value;
				}
			}
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_REMOVE%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("Dictionary remove method", 1, $_list_length(funcArgs));
			key = $_list_get(funcArgs, 0);
			keyType = Value$key.type;
			if (DictImpl$context.keyType != keyType) return "Key not found.";
			keyLookup = DictImpl$context.keyLookup;
			keyValue = Value$key.internalValue;
			if (keyType == Types.INSTANCE) keyValue = $_list_get(keyValue, 2);
			if ($_dictionary_get(keyLookup, keyValue, null) == null) return "Key not found.";
			$_dictionary_remove(keyLookup, keyValue);
			$_dictionary_remove(DictImpl$context.valueLookup, keyValue);
			DictImpl$context.size -= 1;
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_CONTAINS%%%:
			if ($_list_length(funcArgs) != 1) return wrongArgCountError("Dictionary contains method", 1, $_list_length(funcArgs));
			keys = DictImpl$context.keyLookup;
			arg = $_list_get(funcArgs, 0);
			argType = Value$arg.type;
			if (argType == Types.INTEGER || argType == Types.STRING) {
				key = Value$arg.internalValue;
			} else if (argType == Types.INSTANCE) {
				t = Value$arg.internalValue;
				key = $_list_get(t, 2);
			}

			if (DictImpl$context.keyType != argType) {
				output = VALUE_FALSE;
			} else {
				t = $_dictionary_get(keys, key, null);
				if (t == null) {
					output = VALUE_FALSE;
				} else {
					output = VALUE_TRUE;
				}
			}
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_VALUES%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("Dictionary values method", 0, $_list_length(funcArgs));
			values = $_dictionary_get_values(DictImpl$context.valueLookup);
			output = new Value(Types.LIST, values);
			break;
		case %%%PRIMITIVE_METHOD_DICTIONARY_KEYS%%%:
			if ($_list_length(funcArgs) != 0) return wrongArgCountError("Dictionary keys method", 0, $_list_length(funcArgs));
			values = $_dictionary_get_values(DictImpl$context.keyLookup);
			output = new Value(Types.LIST, values);
			break;
		default:
			return "Unknown system method";
	}
	if (returnValueUsed) {
		$_list_push(valueStack, output);
	}
	return null;
}

function killExecution(stack, message) {
	return killExecutionWithTokenOverride(stack, null, message);
}

function killExecutionWithTokenOverride(stack, firstTokenOverride, message) {
	fullMessage = '';
	programData = $_list_get(pd, 0);
	allTokens = ProgramData$programData.tokenData;
	allFiles = generateSourceFiles();
	first = true;
	while (stack != null) {
		pc = StackFrame$stack.pc;
		stack = StackFrame$stack.previous;

		token = null;

		tokenlist = $_list_get(allTokens, pc);
		if (tokenlist != null) {
			token = $_list_get(tokenlist, 0);
		}
		if (first && firstTokenOverride != null) {
			token = firstTokenOverride;
		}

		if (token != null) {
			line = $_list_get(token, 0);
			col = $_list_get(token, 1);
			fileId = $_list_get(token, 2);
			if (fileId < $_list_length(allFiles)) {
				fileData = $_list_get(allFiles, fileId);
				$_print(fileData);
				lines = $_string_split(fileData, '\n');
				filename = lines[0];
				linevalue = lines[line + 1];
				fullMessage = filename + ", Line: " + $_string_cast_weak(line + 1) + ", Col: " + $_string_cast_weak(col + 1) + "\n" + fullMessage;
				if (first) {
					linedisplay = '';
					arrowdisplay = '';
					lefttrim = true;
					for (i = 0; i < $_string_length(linevalue); i += 1) {
						c = $_string_char_at(linevalue, i);
						if (lefttrim) {
							if (c == ' ' || c == '\t' || c == '\r') {
								col -= 1;
							} else {
								lefttrim = false;
								i -= 1;
							}
						} else {
							if (col == 0) {
								arrowdisplay += '^';
								linedisplay += c;
							} else if (c == '\t') {
								arrowdisplay += '    ';
								linedisplay += '    ';
							} else {
								arrowdisplay += ' ';
								linedisplay += c;
							}
							col -= 1;
						}
					}
					lineCopy = linevalue;

					fullMessage = fullMessage + "\n  " + message + "\n\n" + linedisplay + "\n" + arrowdisplay;
				}
			} else {
				token = null; // execution killed before file data was loaded
			}
		}

		if (token == null) {
			fullMessage = "[No Stack Info]\n" + fullMessage;
			if (first) {
				fullMessage += "[No Stack Info]\n  " + message + "\n";
			}
		}

		first = false;
		token = null;
	}
	return "Error:\n" + fullMessage;
}

function read_till(index, raw, length, char) {
	output = [];
	ctn = true;
	while (ctn) {
		c = $_string_char_at(raw, index[0]);
		if (c == char) {
			ctn = false;
		} else {
			$_list_push(output, c);
		}
		index[0] += 1;
	}

	return $_list_join(output, '');
}

alpha_nums = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
function read_integer(pindex, raw, length) {
	c = raw[pindex[0]];
	pindex[0] += 1;
	if (c == '%') {
		value = read_till(pindex, raw, length, '%');
		num = $_string_parse_int(value);
	} else if (c == '@') {
		num = read_integer(pindex, raw, length);
		num *= 62;
		num += read_integer(pindex, raw, length);
	} else if (c == '#') {
		num = read_integer(pindex, raw, length);
		num *= 62;
		num += read_integer(pindex, raw, length);
		num *= 62;
		num += read_integer(pindex, raw, length);
	} else if (c == '^') {
		num = -1 * read_integer(pindex, raw, length);
	} else {
		num = $_string_index_of(alpha_nums, c);
		if (num == -1) {
			// TODO: assert
		}
	}
	return num;
}

function read_string(pindex, raw, length) {
	output = [];
	cont = true;
	while (cont) {
		c = $_string_char_at(raw, $_list_get(pindex, 0));
		$_list_set(pindex, 0, $_list_get(pindex, 0) + 1);
		if (c == '@') {
			repeat = read_integer(pindex, raw, length);
			last = $_list_get(output, $_list_length(output) - 1);
			while (repeat > 0) {
				$_list_push(output, last);
				repeat -= 1;
			}
		} else if (c == '~') {
			d1 = read_integer(pindex, raw, length);
			d2 = read_integer(pindex, raw, length);
			charcode = d1 * 62 + d2;
			$_list_push(output, $_string_from_code(charcode));
		} else if (c == '`') {
			d1 = read_integer(pindex, raw, length);
			d2 = read_integer(pindex, raw, length);
			d3 = read_integer(pindex, raw, length);
			d4 = read_integer(pindex, raw, length);
			charcode = ((d1 * 62 + d2) * 62 + d3) * 62 + d4;
			$_list_push(output, $_string_from_code(charcode));
		} else if (c == '%') {
			cont = false;
		} else {
			$_list_push(output, c);
		}
	}
	return $_list_join(output, '');
}

function loadByteCode() {
	raw = '%%%USER_COMPILED_BYTE_CODE%%%';

	index = [0];
	length = $_string_length(raw);

	header = read_till(index, raw, length, '@');
	if (header != 'CRAYON') {
		// TODO: assert
	}

	opCount = read_integer(index, raw, length);

	ops = [];
	iargs = [];
	sargs = [];
	for (i = 0; i < opCount; i += 1) {
		c = $_string_char_at(raw, index[0]);
		index[0] += 1;
		argc = 0;
		stringPresent = true;
		if (c == '!') argc = 1;
		else if (c == '&') argc = 2;
		else if (c == '*') argc = 3;
		else {
			if (c != '~') {
				stringPresent = false;
				$_list_set(index, 0, $_list_get(index, 0) - 1);
			}
			argc = read_integer(index, raw, length);
		}

		iarglist = [];
		for (j = 0; j < argc; j += 1) {
			iarg = read_integer(index, raw, length);
			if (j == 0) {
				$_list_push(ops, iarg);
			} else {
				$_list_push(iarglist, iarg);
			}
		}
		$_list_push(iargs, iarglist);
		if (stringPresent) {
			stringarg = read_string(index, raw, length);
		} else {
			stringarg = null;
		}
		$_list_push(sargs, stringarg);
	}
	
	return new Code(ops, iargs, sargs);
}

function generateSourceFiles() {
	p = pd[0];
	return ProgramData$p.sourceCode;
}

if (%%%PLATFORM_IS_AUTOLOAD%%%) {
	main();
}