package %%%PACKAGE%%%;

import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JFrame;
import javax.swing.JPanel;

class GameWindow {

    public static GameWindow INSTANCE = null;
    public static double FPS = 60;

    private static final int KEY_EVENT = 1;
    private static final int MOUSE_EVENT = 2;

    private JFrame frame;
    private BufferStrategy strategy = null;
    private int gameWidth;
    private int gameHeight;

    private int screenWidth;
    private int screenHeight;
    private BufferedImage virtualScreen;
    private JPanel canvasHost;
    
    private GameWindow(double fps, int gameWidth, int gameHeight, int pixelWidth, int pixelHeight) {

        INSTANCE = this;

        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;
        this.screenWidth = -1;
        this.screenHeight = -1;

        virtualScreen = new BufferedImage(gameWidth, gameHeight, BufferedImage.TYPE_INT_ARGB);
        
        frame = new JFrame("Crayon Window");
        frame.setSize(pixelWidth, pixelHeight);

        canvasHost = (JPanel) frame.getContentPane();
        canvasHost.setPreferredSize(new Dimension(pixelWidth, pixelHeight));
        canvasHost.setLayout(null);

        frame.pack();
        frame.setVisible(true);

        frame.addWindowListener(new WindowAdapter() { 
            @Override 
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        frame.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                handleKeyPress(e.getKeyCode(), true);
            }

            @Override
            public void keyReleased(KeyEvent e) { 
                handleKeyPress(e.getKeyCode(), false);
            }
        });

    }

    public void maybeUpdateCanvas() {
    	
    	int actualWidth = frame.getWidth();;
    	int actualHeight = frame.getHeight();
    	if (actualWidth == screenWidth && actualHeight == screenHeight) {
    		return;
    	}
    	
        canvasHost.removeAll();
        Canvas canvas = new Canvas();
        canvas.setBounds(0, 0, actualWidth, actualHeight);
        canvas.setSize(actualWidth, actualHeight);
        canvasHost.add(canvas);
        canvas.setIgnoreRepaint(true);
        
        canvas.requestFocus();
        canvas.createBufferStrategy(2);
        strategy = canvas.getBufferStrategy();
        
        screenWidth = actualWidth;
        screenHeight = actualHeight;
    }
    
    public static void initializeScreen(int gameWidth, int gameHeight) {
        initializeScreen(gameWidth, gameHeight, gameWidth, gameHeight);
    }

    public static void initializeScreen(int gameWidth, int gameHeight, int screenWidth, int screenHeight) {
        GameWindow window = new GameWindow(FPS, gameWidth, gameHeight, screenWidth, screenHeight);
        window.show();
    }

    public void setTitle(String title) {
        throw new RuntimeException("TODO: set title");
    }

    private int[] eventCodes = new int[100];
    private String[] eventData = new String[100];
    private int eventCodesLength = 0;
    private int eventDataLength = 0;

    private void handleKeyPress(int keyCode, boolean down) {
        String key;
        switch (keyCode) {
            case KeyEvent.VK_LEFT: key = "left"; break;
            case KeyEvent.VK_RIGHT: key = "right"; break;
            case KeyEvent.VK_UP: key = "up"; break;
            case KeyEvent.VK_DOWN: key = "down"; break;
            case KeyEvent.VK_SPACE: key = "space"; break;
            default: key = null; break;
        }

        if (key != null) {
            if (eventCodesLength + 2 >= eventCodes.length) {
                int[] newEventCodes = new int[eventCodes.length * 2];
                System.arraycopy(eventCodes, 0, newEventCodes, 0, eventCodes.length);
                eventCodes = newEventCodes;
            }

            if (eventDataLength + 1 >= eventData.length) {
                String[] newEventData = new String[eventData.length * 2];
                System.arraycopy(eventData, 0, newEventData, 0, eventData.length);
                eventData = newEventData;
            }

            eventCodes[eventCodesLength++] = KEY_EVENT;
            eventCodes[eventCodesLength++]  = down ? 1 : 0;
            eventData[eventDataLength++] = key;
        }
    }

    private void timerTick() {
        CrayonWrapper.v_runTick();
        
        maybeUpdateCanvas();
        Graphics2D virtualG = (Graphics2D) virtualScreen.createGraphics();
        RenderEngine.render(virtualG, gameWidth, gameHeight);
        
        Graphics2D realG = (Graphics2D) strategy.getDrawGraphics();
        realG.setRenderingHint(
        	RenderingHints.KEY_INTERPOLATION, 
        	RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
        realG.drawImage(virtualScreen, 0, 0, screenWidth, screenHeight, 
        		0, 0, virtualScreen.getWidth(), virtualScreen.getHeight(), null);
        
        realG.dispose();
        strategy.show();
    }

    public void show() {
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                timerTick();
            }
        }, 0, (int)(1000 / FPS));

        frame.setVisible(true);
    }

    public ArrayList<Value> pumpEventQueue() {
        int eventDataIndex = 0;
        int eventCodeIndex = 0;
        boolean down;
        String key;
        ArrayList<Value> output = new ArrayList<Value>();
        while (eventCodeIndex < eventCodesLength) {
            switch (eventCodes[eventCodeIndex++]) {
                case KEY_EVENT:
                    down = eventCodes[eventCodeIndex++] == 1;
                    key = eventData[eventDataIndex++];
                    if (down) {
                        output.add(generateEventItem(
                            getCommonString("keydown"),
                            getCommonString(key)));
                    } else {
                        output.add(generateEventItem(
                            getCommonString("keyup"),
                            getCommonString(key)));
                    }
                    break;
                case MOUSE_EVENT:
                    // TODO: this
                    break;
                default: break;
            }
        }
        eventCodesLength = 0;
        eventDataLength = 0;

        return output;
    }

    private static final HashMap<String, Value> STRING_CACHE  = new HashMap<String, Value>();
    private Value getCommonString(String str) {
        Value output = STRING_CACHE.get(str);
        if (output == null) {
            output = new Value(%%%TYPE_STRING%%%, str);
            STRING_CACHE.put(str, output);
        }
        return output;
    }

    private Value generateEventItem(Value ... values) {
        ArrayList<Value> output = new ArrayList<Value>(values.length);
        for (int i = 0; i < values.length; ++i) {
            output.set(i, values[i]);
        }
        return new Value(%%%TYPE_LIST%%%, output);
    }
}
