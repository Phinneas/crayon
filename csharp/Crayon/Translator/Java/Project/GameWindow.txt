package crayonproject;

import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferStrategy;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JFrame;
import javax.swing.JPanel;

class GameWindow {
    private static final int KEY_EVENT = 1;
    private static final int MOUSE_EVENT = 2;

    private JFrame frame;
    private BufferStrategy strategy = null;
    private int gameWidth;
    private int gameHeight;

    // TODO: I still have a canvas scaling problem
    private int pixelWidth;
    private int pixelHeight;

    public GameWindow(double fps, int gameWidth, int gameHeight, int pixelWidth, int pixelHeight) {
        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;
        this.pixelWidth = pixelWidth;
        this.pixelHeight = pixelHeight;

        frame = new JFrame("Crayon Window");
        frame.setSize(pixelWidth, pixelHeight);

        JPanel panel = (JPanel) frame.getContentPane();
        panel.setPreferredSize(new Dimension(pixelWidth, pixelHeight));
        panel.setLayout(null);

        Canvas canvas = new Canvas();
        canvas.setBounds(0, 0, gameWidth, gameHeight);
        canvas.setSize(pixelWidth, pixelHeight);
        panel.add(canvas);

        canvas.setIgnoreRepaint(true);

        frame.pack();
        frame.setResizable(false);
        frame.setVisible(true);

        frame.addWindowListener(new WindowAdapter() { 
            @Override 
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        frame.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                handleKeyPress(e.getKeyCode(), true);
            }

            @Override
            public void keyReleased(KeyEvent e) { 
                handleKeyPress(e.getKeyCode(), false);
            }
        });

        canvas.requestFocus();
        canvas.createBufferStrategy(2);
        strategy = canvas.getBufferStrategy();

        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                timerTick();
            }
        }, 0, 33);
    }

    private int[] eventCodes = new int[100];
    private String[] eventData = new String[100];
    private int eventCodesLength = 0;
    private int eventDataLength = 0;

    private void handleKeyPress(int keyCode, boolean down) {
        String key;
        switch (keyCode) {
            case KeyEvent.VK_LEFT: key = "left"; break;
            case KeyEvent.VK_RIGHT: key = "right"; break;
            case KeyEvent.VK_UP: key = "up"; break;
            case KeyEvent.VK_DOWN: key = "down"; break;
            case KeyEvent.VK_SPACE: key = "space"; break;
            default: key = null; break;
        }

        if (key != null) {
            if (eventCodesLength + 2 >= eventCodes.length) {
                int[] newEventCodes = new int[eventCodes.length * 2];
                System.arraycopy(eventCodes, 0, newEventCodes, 0, eventCodes.length);
                eventCodes = newEventCodes;
            }

            if (eventDataLength + 1 >= eventData.length) {
                String[] newEventData = new String[eventData.length * 2];
                System.arraycopy(eventData, 0, newEventData, 0, eventData.length);
                eventData = newEventData;
            }

            eventCodes[eventCodesLength++] = KEY_EVENT;
            eventCodes[eventCodesLength++]  = down ? 1 : 0;
            eventData[eventDataLength++] = key;
        }
    }

    private void timerTick() {
        CrayonWrapper.v_runTick();
        Graphics2D g = (Graphics2D) strategy.getDrawGraphics();
        RenderEngine.render(g, gameWidth, gameHeight);
        g.dispose();
        strategy.show();
    }

    public void show() {
        frame.setVisible(true);
    }

    public ArrayList<Value> pumpEventQueue() {
        int eventDataIndex = 0;
        int eventCodeIndex = 0;
        boolean down;
        String key;
        ArrayList<Value> output = new ArrayList<Value>();
        while (eventCodeIndex < eventCodesLength) {
            switch (eventCodes[eventCodeIndex++]) {
                case KEY_EVENT:
                    down = eventCodes[eventCodeIndex++] == 1;
                    key = eventData[eventDataIndex++];
                    if (down) {
                        output.add(generateEventItem(
                            getCommonString("keydown"),
                            getCommonString(key)));
                    } else {
                        output.add(generateEventItem(
                            getCommonString("keyup"),
                            getCommonString(key)));
                    }
                    break;
                case MOUSE_EVENT:
                    // TODO: this
                    break;
                default: break;
            }
        }
        eventCodesLength = 0;
        eventDataLength = 0;

        return output;
    }

    private static final HashMap<String, Value> STRING_CACHE  = new HashMap<String, Value>();
    private Value getCommonString(String str) {
        Value output = STRING_CACHE.get(str);
        if (output == null) {
            output = new Value(%%%TYPE_STRING%%%, str);
            STRING_CACHE.put(str, output);
        }
        return output;
    }

    private Value generateEventItem(Value ... values) {
        ArrayList<Value> output = new ArrayList<Value>(values.length);
        for (int i = 0; i < values.length; ++i) {
            output.set(i, values[i]);
        }
        return new Value(%%%TYPE_LIST%%%, output);
    }
}
