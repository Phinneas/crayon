package %%%PACKAGE%%%;

import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JFrame;
import javax.swing.JPanel;

class GameWindow {

    public static GameWindow INSTANCE = null;
    public static double FPS = 60;

    private static final int KEY_EVENT = 1;
    private static final int MOUSE_EVENT = 2;

    private JFrame frame;
    private BufferStrategy strategy = null;
    private int gameWidth;
    private int gameHeight;

    private int screenWidth;
    private int screenHeight;
    private BufferedImage virtualScreen;
    private JPanel canvasHost;
    private KeyAdapter keyAdapter;

    private GameWindow(double fps, int gameWidth, int gameHeight, int pixelWidth, int pixelHeight) {

        INSTANCE = this;

        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;
        this.screenWidth = -1;
        this.screenHeight = -1;

        virtualScreen = new BufferedImage(gameWidth, gameHeight, BufferedImage.TYPE_INT_ARGB);

        frame = new JFrame("Crayon Window");
        frame.setSize(pixelWidth, pixelHeight);

        canvasHost = (JPanel) frame.getContentPane();
        canvasHost.setPreferredSize(new Dimension(pixelWidth, pixelHeight));
        canvasHost.setLayout(null);

        frame.pack();
        frame.setVisible(true);

        frame.addWindowListener(new WindowAdapter() { 
            @Override 
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        keyAdapter = new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                handleKeyPress(e.getKeyCode(), true);
            }

            @Override
            public void keyReleased(KeyEvent e) { 
                handleKeyPress(e.getKeyCode(), false);
            }
        };
        canvasHost.addKeyListener(keyAdapter);
        canvasHost.requestFocus();
    }

    public void maybeUpdateCanvas() {
        int actualWidth = frame.getWidth();;
        int actualHeight = frame.getHeight();
        if (actualWidth == screenWidth && actualHeight == screenHeight) {
            return;
        }

        canvasHost.removeAll();
        Canvas canvas = new Canvas();
        canvas.setBounds(0, 0, actualWidth, actualHeight);
        canvas.setSize(actualWidth, actualHeight);
        canvasHost.add(canvas);
        canvas.setIgnoreRepaint(true);
        canvas.addKeyListener(keyAdapter);

        canvas.createBufferStrategy(2);
        strategy = canvas.getBufferStrategy();

        screenWidth = actualWidth;
        screenHeight = actualHeight;
    }

    public static void initializeScreen(int gameWidth, int gameHeight) {
        initializeScreen(gameWidth, gameHeight, gameWidth, gameHeight);
    }

    public static void initializeScreen(int gameWidth, int gameHeight, int screenWidth, int screenHeight) {
        GameWindow window = new GameWindow(FPS, gameWidth, gameHeight, screenWidth, screenHeight);
        window.show();
    }

    public void setTitle(String title) {
        throw new RuntimeException("TODO: set title");
    }

    private int[] eventCodes = new int[100];
    private String[] eventData = new String[100];
    private int eventCodesLength = 0;
    private int eventDataLength = 0;

    private static HashMap<Integer, String> keyCodeLookup = null;
    private HashMap<Integer, String> getKeyCodeLookup() {
        if (keyCodeLookup == null) {
            keyCodeLookup = new HashMap<Integer, String>();
            keyCodeLookup.put(KeyEvent.VK_LEFT, "left");
            keyCodeLookup.put(KeyEvent.VK_RIGHT, "right");
            keyCodeLookup.put(KeyEvent.VK_DOWN, "down");
            keyCodeLookup.put(KeyEvent.VK_UP, "up");

            keyCodeLookup.put(KeyEvent.VK_SPACE, "space");
            keyCodeLookup.put(KeyEvent.VK_ENTER, "enter");
            keyCodeLookup.put(KeyEvent.VK_TAB, "tab");
            keyCodeLookup.put(KeyEvent.VK_ESCAPE, "escape");

            keyCodeLookup.put(KeyEvent.VK_CONTROL, "ctrl");
            keyCodeLookup.put(KeyEvent.VK_SHIFT, "shift");
            keyCodeLookup.put(KeyEvent.VK_ALT, "alt");

            for (int i = 0; i < 26; ++i) {
                keyCodeLookup.put(KeyEvent.VK_A, "" + (char)('a' + i));
            }

            for (int i = 0; i < 10; ++i) {
                keyCodeLookup.put(KeyEvent.VK_0, "" + (char)('0' + i));
            }

            for (int i = 0; i < 12; ++i) {
                keyCodeLookup.put(KeyEvent.VK_F1, "F" + (i + 1));
            }
        }
        return keyCodeLookup;
    }

    private void handleKeyPress(int keyCode, boolean down) {
        String key = getKeyCodeLookup().get(keyCode);

        if (key != null) {
            if (eventCodesLength + 2 >= eventCodes.length) {
                int[] newEventCodes = new int[eventCodes.length * 2];
                System.arraycopy(eventCodes, 0, newEventCodes, 0, eventCodes.length);
                eventCodes = newEventCodes;
            }

            if (eventDataLength + 1 >= eventData.length) {
                String[] newEventData = new String[eventData.length * 2];
                System.arraycopy(eventData, 0, newEventData, 0, eventData.length);
                eventData = newEventData;
            }

            eventCodes[eventCodesLength++] = KEY_EVENT;
            eventCodes[eventCodesLength++]  = down ? 1 : 0;
            eventData[eventDataLength++] = key;
        }
    }

    private void timerTick() {
        CrayonWrapper.v_runTick();

        maybeUpdateCanvas();
        Graphics2D virtualG = (Graphics2D) virtualScreen.createGraphics();
        RenderEngine.render(virtualG, gameWidth, gameHeight);

        Graphics2D realG = (Graphics2D) strategy.getDrawGraphics();
        realG.setRenderingHint(
            RenderingHints.KEY_INTERPOLATION, 
            RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
        realG.drawImage(
            virtualScreen, 0, 0, screenWidth, screenHeight,
            0, 0, virtualScreen.getWidth(), virtualScreen.getHeight(),
            null);

        realG.dispose();
        strategy.show();
    }

    public void show() {
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                timerTick();
            }
        }, 0, (int)(1000 / FPS));

        frame.setVisible(true);
    }

    public ArrayList<Value> pumpEventQueue() {
        int eventDataIndex = 0;
        int eventCodeIndex = 0;
        boolean down;
        String key;
        ArrayList<Value> output = new ArrayList<Value>();
        while (eventCodeIndex < eventCodesLength) {
            switch (eventCodes[eventCodeIndex++]) {
                case KEY_EVENT:
                    down = eventCodes[eventCodeIndex++] == 1;
                    key = eventData[eventDataIndex++];
                    output.add(generateEventItem(
                        getCommonString("key"),
                        getBoolean(down),
                        getCommonString(key)));
                    break;
                case MOUSE_EVENT:
                    // TODO: this
                    break;
                default: break;
            }
        }
        eventCodesLength = 0;
        eventDataLength = 0;

        return output;
    }

    private static Value getBoolean(boolean b) {
        return b ? CrayonWrapper.v_VALUE_TRUE : CrayonWrapper.v_VALUE_FALSE;
    }

    private static final HashMap<String, Value> STRING_CACHE  = new HashMap<String, Value>();
    private Value getCommonString(String str) {
        Value output = STRING_CACHE.get(str);
        if (output == null) {
            output = new Value(%%%TYPE_STRING%%%, str);
            STRING_CACHE.put(str, output);
        }
        return output;
    }

    private Value generateEventItem(Value ... values) {
        ArrayList<Value> output = new ArrayList<Value>(values.length);
        for (int i = 0; i < values.length; ++i) {
            output.add(values[i]);
        }
        return new Value(%%%TYPE_LIST%%%, output);
    }
}
