package %%%PACKAGE%%%;

import android.graphics.Bitmap;
import android.opengl.GLUtils;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

import javax.microedition.khronos.opengles.GL10;

final class GlUtil {
    private GlUtil() {}

    private static GL10 gl;

    public static FloatBuffer quadVertexBuffer = null;
    public static FloatBuffer ellipseVertexBuffer = null;

    private static float[] ellipseVertices = null;

    public static void setGl(GL10 value) {
        gl = value;

        if (quadVertexBuffer == null) {
            quadVertexBuffer = buildVertexBuffer(new float[] {
                0.0f, 0.0f, 1.0f,
                0.0f, 1.0f, 1.0f,
                1.0f, 0.0f, 1.0f,
                1.0f, 1.0f, 1.0f,
            });
            ellipseVertices = allocateEllipse();
            ellipseVertexBuffer = buildVertexBuffer(ellipseVertices);
        }
    }

    private static FloatBuffer buildVertexBuffer(float[] vertices) {
        ByteBuffer vertexByteBuffer = ByteBuffer.allocateDirect(vertices.length * 4);
        vertexByteBuffer.order(ByteOrder.nativeOrder());
        FloatBuffer vertexBuffer = vertexByteBuffer.asFloatBuffer();
        vertexBuffer.put(vertices);
        vertexBuffer.position(0);
        return vertexBuffer;
    }

    private static float[] allocateEllipse() {
        int ptCount = 60;
        float[] output = new float[(ptCount + 2)* 3];
        output[0] = .5f;
        output[1] = .5f;
        output[2] = 0f;

        for (int i = 0; i < ptCount; ++i) {
            double ang = i * 2 * 3.14159265358979 / ptCount;
            output[i * 3 + 3] = (float) (Math.cos(ang) * .5 + .5);
            output[i * 3 + 4] = (float) (Math.sin(ang) * .5 + .5);
            output[i * 3 + 5] = 0f;
        }

        // close the fan to the starting edge point.
        output[output.length - 3] = output[3];
        output[output.length - 2] = output[4];
        output[output.length - 1] = output[5];

        return output;
    }

    public static int forceLoadTexture(Bitmap bitmap) {
		int[] texture = new int[1];
		gl.glGenTextures(1, texture, 0);
	    gl.glBindTexture(GL10.GL_TEXTURE_2D, texture[0]);
		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_NEAREST);
	    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
		GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);
		return texture[0];
    }

    public static void beginPolygon() {
        throw new RuntimeException("TODO");
    }

    public static void beginQuads() {
        throw new RuntimeException("TODO");
    }

    public static void glBindTexture(int textureId) {
        gl.glBindTexture(GL10.GL_TEXTURE_2D, textureId);
    }

    public static void color4(int r, int g, int b, int a) {
        gl.glColor4f(r / 255f, g / 255f, b / 255f, a / 255f);
    }

    public static void glDisableTexture2D() {
        gl.glDisable(GL10.GL_TEXTURE_2D);
    }

    public static void glEnableTexture2D() {
        gl.glEnable(GL10.GL_TEXTURE_2D);
    }

    public static void glLoadIdentity() {
        gl.glLoadIdentity();
    }

    public static int getMaxTextureSize() {
        return 1024; // need to change this. Probably safe to hardcode to 2048?
    }

    public static void prepareDrawPipeline(Object glUncast) {
        GL10 gl = (GL10) glUncast;
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
        gl.glClearColor(0f, 0f, 0f, 1f);
        gl.glEnable(GL10.GL_BLEND);
        gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
        gl.glMatrixMode(GL10.GL_MODELVIEW);
    }

    public static void glTexCoord2(double x, double y) {
        throw new RuntimeException("TODO");
    }

    public static void glVertex2(double x, double y) {
        throw new RuntimeException("TODO");
    }

    public static void glTranslatef(float dx, float dy) {
        gl.glTranslatef(dx, dy, 0);
    }

    public static void glScalef(float xratio, float yratio) {
        gl.glScalef(xratio, yratio, 0);
    }

    public static void glEnableVertexArray() {
        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
    }

    public static void glDrawEllipseVertices() {
        // Point to our vertex buffer
        gl.glVertexPointer(3, GL10.GL_FLOAT, 0, ellipseVertexBuffer);

        // Draw the vertices as triangle strip
        gl.glDrawArrays(GL10.GL_TRIANGLE_FAN, 0, ellipseVertices.length / 3);
    }

    public static void glDisableVertexArray() {
        gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
    }
}
