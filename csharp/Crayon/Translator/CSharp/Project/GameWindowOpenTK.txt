using System.Collections.Generic;
using OpenTK.Graphics.OpenGL;

namespace %%%PROJECT_ID%%%
{
	internal class GameWindow : OpenTK.GameWindow
	{
		private const int MOUSE_EVENT = 0;
		private const int KEY_EVENT = 1;
		private const int EXIT = 2;

		private const int MOUSE_LEFT = 0;
		private const int MOUSE_RIGHT = 1;
		private const int MOUSE_MOVE = 2;

		private const int EXIT_ALT_F4 = 1;
		private const int EXIT_CLOSE_BUTTON = 2;

		private Queue<int> events = new Queue<int>();
		private Queue<string> keyEvents = new Queue<string>();
		private bool altPressed = false;

		private int gameWidth;
		private int gameHeight;
		private int screenWidth;
		private int screenHeight;

		private static double fps = 60;
		private static GameWindow instance = null;
		public static GameWindow Instance { get { return instance; } }

		public static double FPS
		{
			get { return fps; }
			set { fps = value; }
		}

		private GameWindow(double fps, int gameWidth, int gameHeight, int screenWidth, int screenHeight)
			: base(screenWidth, screenHeight)
		{
			GameWindow.instance = this;
			this.gameWidth = gameWidth;
			this.gameHeight = gameHeight;
			this.screenWidth = screenWidth;
			this.screenHeight = screenHeight;
			this.X = 50;
			this.Y = 50;

			this.TargetRenderFrequency = fps;

			this.UpdateFrame += (sender, e) => this.Update();
			this.RenderFrame += (sender, e) => this.Render();
			this.Load += (sender, e) => this.Startup();
			this.Resize += (sender, e) => this.Resizing();

			this.Mouse.Move += (sender, e) => this.MouseMove(e.X, e.Y);
			this.Mouse.ButtonDown += (sender, e) => this.MouseButton(e.Button, e.X, e.Y, true);
			this.Mouse.ButtonUp += (sender, e) => this.MouseButton(e.Button, e.X, e.Y, false);
			this.Keyboard.KeyDown += (sender, e) => this.KeyEvent(e.Key, true);
			this.Keyboard.KeyUp += (sender, e) => this.KeyEvent(e.Key, false);
		}

		public static bool InitializeScreen(int gameWidth, int gameHeight)
		{
			return InitializeScreen(gameWidth, gameHeight, gameWidth, gameHeight);
		}

		public static bool InitializeScreen(int gameWidth, int gameHeight, int screenWidth, int screenHeight)
		{
			GameWindow gw = new GameWindow(fps, gameWidth, gameHeight, screenWidth, screenHeight);
			gw.Run(GameWindow.FPS, GameWindow.FPS);
			return false;
		}

		private void MouseMove(int x, int y)
		{
			events.Enqueue(MOUSE_EVENT);
			events.Enqueue(x * this.gameWidth / this.screenWidth);
			events.Enqueue(y * this.gameHeight / this.screenHeight);
			events.Enqueue(MOUSE_MOVE);
		}

		private void MouseButton(OpenTK.Input.MouseButton button, int x, int y, bool down)
		{
			// drop events that aren't the left or right buttons. For now.
			bool left = button == OpenTK.Input.MouseButton.Left;
			if (!left && button != OpenTK.Input.MouseButton.Right)
			{
				return;
			}

			events.Enqueue(MOUSE_EVENT);
			events.Enqueue(x * this.gameWidth / this.screenWidth);
			events.Enqueue(y * this.gameHeight / this.screenHeight);
			events.Enqueue(left ? MOUSE_LEFT : MOUSE_RIGHT);
			events.Enqueue(down ? 1 : 0);
		}

		private const int KEY_CODE_A = (int)OpenTK.Input.Key.A;
		private const int KEY_CODE_Z = (int)OpenTK.Input.Key.Z;
		private const int KEY_CODE_F1 = (int)OpenTK.Input.Key.F1;
		private const int KEY_CODE_F12 = (int)OpenTK.Input.Key.F12;
		private const int KEY_CODE_0 = (int)OpenTK.Input.Key.Number0;
		private const int KEY_CODE_9 = (int)OpenTK.Input.Key.Number9;

		private static readonly string[] LETTERS = "a b c d e f g h i j k l m n o p q r s t u v w x y z".Split(' ');
		private static readonly string[] F_KEYS = "f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12".Split(' ');
		private void KeyEvent(OpenTK.Input.Key key, bool down)
		{
			int keyCode = (int)key;

			if (keyCode >= KEY_CODE_A && keyCode <= KEY_CODE_Z)
			{
				keyEvents.Enqueue(LETTERS[keyCode - KEY_CODE_A]);
			}
			else if (keyCode >= KEY_CODE_F1 && keyCode <= KEY_CODE_F12)
			{
				if (this.altPressed && keyCode == KEY_CODE_F1 + 3)
				{
					events.Enqueue(EXIT);
					events.Enqueue(EXIT_ALT_F4);
				}

				keyEvents.Enqueue("f" + (1 + keyCode - KEY_CODE_F1));
			}
			else if (keyCode >= KEY_CODE_0 && keyCode <= KEY_CODE_9)
			{
				keyEvents.Enqueue("" + (keyCode - KEY_CODE_0));
			}
			else
			{
				string value;
				switch (key)
				{
					case OpenTK.Input.Key.Space: value = "space"; break;
					case OpenTK.Input.Key.Enter: value = "enter"; break;
					case OpenTK.Input.Key.KeypadEnter: value = "enter"; break;
					case OpenTK.Input.Key.Tab: value = "tab"; break;
					case OpenTK.Input.Key.Escape: value = "escape"; break;

					case OpenTK.Input.Key.Left: value = "left"; break;
					case OpenTK.Input.Key.Right: value = "right"; break;
					case OpenTK.Input.Key.Up: value = "up"; break;
					case OpenTK.Input.Key.Down: value = "down"; break;

					case OpenTK.Input.Key.Comma: value = "comma"; break;
					case OpenTK.Input.Key.Period: value = "period"; break;
					case OpenTK.Input.Key.Semicolon: value = "semicolon"; break;
					case OpenTK.Input.Key.Quote: value = "apostrophe"; break;
					case OpenTK.Input.Key.Slash: value = "slash"; break;
					case OpenTK.Input.Key.BackSlash: value = "backslash"; break;
					case OpenTK.Input.Key.BracketLeft: value = "openbracket"; break;
					case OpenTK.Input.Key.BracketRight: value = "closebracket"; break;
					case OpenTK.Input.Key.Minus: value = "hyphen"; break;
					case OpenTK.Input.Key.Plus: value = "equals"; break;
					case OpenTK.Input.Key.Tilde: value = "tilde"; break;

					case OpenTK.Input.Key.ControlLeft: value = "ctrl"; break;
					case OpenTK.Input.Key.ControlRight: value = "ctrl"; break;
					case OpenTK.Input.Key.ShiftLeft: value = "shift"; break;
					case OpenTK.Input.Key.ShiftRight: value = "shift"; break;
					case OpenTK.Input.Key.AltLeft: value = "alt"; break;
					case OpenTK.Input.Key.AltRight: value = "alt"; break;

					case OpenTK.Input.Key.PageUp: value = "pageup"; break;
					case OpenTK.Input.Key.PageDown: value = "pagedown"; break;
					case OpenTK.Input.Key.Home: value = "home"; break;
					case OpenTK.Input.Key.End: value = "end"; break;
					case OpenTK.Input.Key.Delete: value = "delete"; break;
					case OpenTK.Input.Key.Insert: value = "insert"; break;
					case OpenTK.Input.Key.BackSpace: value = "backspace"; break;
					case OpenTK.Input.Key.PrintScreen: value = "printscreen"; break;
					case OpenTK.Input.Key.Pause: value = "pause"; break;
					case OpenTK.Input.Key.Menu: value = "menu"; break;
					case OpenTK.Input.Key.CapsLock: value = "capslock"; break;
					case OpenTK.Input.Key.ScrollLock: value = "scrolllock"; break;
					case OpenTK.Input.Key.NumLock: value = "numlock"; break;

					default: value = null; break;
				}

				if (value == null)
				{
					return;
				}

				if (value == "alt")
				{
					this.altPressed = down;
				}

				keyEvents.Enqueue(value);
			}
			events.Enqueue(KEY_EVENT);
			events.Enqueue(down ? 1 : 0);
		}

		public List<Value> GetEvents()
		{
			List<Value> output = new List<Value>();
			Queue<int> events = instance.events;
			Queue<string> keyEvents = instance.keyEvents;
			int type;
			int x, y;
			bool down, isLeft;
			string keyCode;

			while (events.Count > 0)
			{
				switch (events.Dequeue())
				{
					case MOUSE_EVENT:
						x = events.Dequeue();
						y = events.Dequeue();
						type = events.Dequeue();
						if (type == MOUSE_MOVE)
						{
							output.Add(CrayonWrapper.v_buildGameEvent("mousemove", "mouse", x, y, 0, false, null));
						}
						else
						{
							isLeft = type == MOUSE_LEFT;
							down = events.Dequeue() == 1;
							string button = type == MOUSE_LEFT ? "left" : "right";
							output.Add(CrayonWrapper.v_buildGameEvent("mouse" + button + (down ? "down" : "up"), "mouse", x, y, 0, down, button));
						}
						break;
					case KEY_EVENT:
						down = events.Dequeue() == 1;
						keyCode = keyEvents.Dequeue();
						// TODO: intercept alt-f4
						output.Add(CrayonWrapper.v_buildGameEvent("key" + (down ? "down" : "up"), "key", 0, 0, 0, down, keyCode));
						break;
					case EXIT:
						type = events.Dequeue();
						string quitCode = type == EXIT_ALT_F4 ? "quit-altf4" : "quit-closebutton";
						output.Add(CrayonWrapper.v_buildGameEvent(quitCode, "quit", 0, 0, 0, false, null));
						break;
					default:
						break;
				}
			}

			return output;
		}

		private void Startup()
		{
			GL.ClearColor(1f, 1f, 1f, 1f);
			GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
			GL.Enable(EnableCap.Blend);
			GL.Disable(EnableCap.ColorMaterial);
		}

		private void Resizing()
		{
			this.screenWidth = this.Width;
			this.screenHeight = this.Height;

			GL.MatrixMode(MatrixMode.Projection);
			GL.LoadIdentity();
			GL.Ortho(0, this.screenWidth, this.screenHeight, 0, 10000, -10000);
			GL.Viewport(0, 0, this.screenWidth, this.screenHeight);
		}

		protected override void OnClosing(System.ComponentModel.CancelEventArgs e)
		{
			e.Cancel = true;
			events.Enqueue(EXIT);
			events.Enqueue(EXIT_CLOSE_BUTTON);
			base.OnClosing(e);
		}

		public void SetTitle(string value)
		{
			this.Title = value;
		}

		private void Update()
		{
			CrayonWrapper.v_glResetDrawBuffer();

			bool continueExecution = CrayonWrapper.v_runTick();

			if (!continueExecution)
			{
				// Because sometimes once isn't enough.
				this.Close();
				this.Exit();
				System.Environment.Exit(0);
			}
		}

		private void Render()
		{
			GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
			GL.ClearColor(0f, 0f, 0f, 1f);
			GL.MatrixMode(MatrixMode.Modelview);
			GL.LoadIdentity();

			CrayonWrapper.v_glRender(null, this.gameWidth, this.gameHeight, this.screenWidth, this.screenHeight);

			this.SwapBuffers();
		}

		internal int GetGamepadCount()
		{
			return this.Joysticks.Count;
		}

		internal object GetGamepadRawDevice(int index)
		{
			return this.Joysticks[index];
		}

		internal void GamepadEnableDevice(OpenTK.Input.JoystickDevice device)
		{
			// automatically enabled on OpenTK.
		}
		
		internal int GetGamepadAxisCount(OpenTK.Input.JoystickDevice device)
		{
			return device.Axis.Count;
		}

		internal int GetGamepadButtonCount(OpenTK.Input.JoystickDevice device)
		{
			return device.Button.Count;
		}

		internal int GetGamepadHatCount(OpenTK.Input.JoystickDevice device)
		{
			return 0;
		}

		internal string GetGamepadDeviceName(OpenTK.Input.JoystickDevice device)
		{
			return device.Description;
		}

		internal bool IsGamepadButtonPushed(OpenTK.Input.JoystickDevice device, int buttonIndex)
		{
			return device.Button[buttonIndex];
		}

		internal double GetGamepadAxisValue(OpenTK.Input.JoystickDevice device, int axisIndex)
		{
			return device.Axis[axisIndex];
		}
	}
}
