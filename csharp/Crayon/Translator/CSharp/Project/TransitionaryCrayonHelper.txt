using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;

namespace %%%PROJECT_ID%%%
{
	public static class TransitionaryCrayonHelper
	{
		public const int IMAGE_SHEET_TILES_LOADED_PER_FRAME = 3;
		public const int IMAGE_SHEET_STATUS_NOT_LOADED = 0;
		public const int IMAGE_SHEET_STATUS_LOADING = 1;
		public const int IMAGE_SHEET_STATUS_LOADED = 2;

		public static bool LoadCompositeImageResource(CompositeImage compositeImage)
		{
			compositeImage.glTextureId = GlUtil.ForceLoadTexture((Bitmap)compositeImage.nativeBitmap);
			compositeImage.loaded = true;
			return true;
		}

		public static ImageSheetVirtualizationGrid IntantiateVirtualizationGrid(
			string groupName,
			List<SpriteSheetItemDescriptor> spriteSheetItemDescriptors,
			Dictionary<string, object> nativeTileBitmapsByGeneratedName,
			Dictionary<string, int> groupNameToId)
		{
			int groupId = groupNameToId[groupName];

			Dictionary<int, Bitmap> tiles = new Dictionary<int, Bitmap>();
			Dictionary<int, Graphics> sheetGraphics = new Dictionary<int, Graphics>();

			// [ tile ID, x, y, width, height ]
			Dictionary<string, int[]> locations = new Dictionary<string, int[]>();

			List<string> paths = new List<string>();

			Dictionary<int, Bitmap> nonSolitarySheets = new Dictionary<int, Bitmap>();
			Dictionary<int, Bitmap> solitarySheets = new Dictionary<int, Bitmap>();

			int biggestSheetId = 0;
			foreach (SpriteSheetItemDescriptor item in spriteSheetItemDescriptors)
			{
				string filename = item.filePath;
				paths.Add(filename);
				int x = item.x;
				int y = item.y;
				int width = item.width;
				int height = item.height;
				int tileId = item.tileId;
				if (tileId > biggestSheetId)
				{
					biggestSheetId = tileId;
				}
				string generatedName = groupId + "_" + tileId;

				if (item.solitary)
				{
					solitarySheets[tileId] = (Bitmap)nativeTileBitmapsByGeneratedName[generatedName];
					locations[filename] = new int[] { tileId, 0, 0, item.width, item.height };
				}
				else
				{
					int col, row;
					int roundedId = tileId / 16 * 16;
					if (!nonSolitarySheets.ContainsKey(roundedId))
					{
						Bitmap bigSheet = new Bitmap(1024, 1024, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
						nonSolitarySheets[roundedId] = bigSheet;
						bigSheet.SetResolution(96, 96);
						sheetGraphics[roundedId] = Graphics.FromImage(bigSheet);

						for (int i = 0; i < 16; ++i)
						{
							int interiorTileId = roundedId + i;
							string interiorTileGeneratedName = groupId + "_" + interiorTileId;
							col = i % 4;
							row = i / 4;
							if (nativeTileBitmapsByGeneratedName.ContainsKey(interiorTileGeneratedName))
							{
								sheetGraphics[roundedId].DrawImage(
									(Bitmap)nativeTileBitmapsByGeneratedName[interiorTileGeneratedName],
									col * 256,
									row * 256);
							}
						}
					}

					col = (tileId - roundedId) % 4;
					row = (tileId - roundedId) / 4;

					locations[filename] = new int[] { roundedId, col * 256 + item.x, row * 256 + item.y, item.width, item.height };
				}
			}

			// Go through and further consolidate things if possible. 
			if (GlUtil.MaxTextureSize > 1024 && nonSolitarySheets.Count > 1)
			{
				int unitLength = GlUtil.MaxTextureSize / 1024;
				int maxSheetsPerMegaSheet = unitLength * unitLength;
				int sheetCount = nonSolitarySheets.Count;

				// Start making a list of ID groupings that don't exceed the maximum capacity of a megasheet.
				List<List<int>> megaSheetMapping = new List<List<int>>();
				foreach (int sheetIdToCombine in nonSolitarySheets.Keys.OrderBy<int, int>(i => i))
				{
					if (megaSheetMapping.Count == 0 || megaSheetMapping[megaSheetMapping.Count - 1].Count == maxSheetsPerMegaSheet)
					{
						megaSheetMapping.Add(new List<int>());
					}
					megaSheetMapping[megaSheetMapping.Count - 1].Add(sheetIdToCombine);
				}

				// now that the members of the mega sheets are fully determined, create the images.
				int megaSheetId = biggestSheetId;
				Dictionary<int, Bitmap> megaSheetById = new Dictionary<int, Bitmap>();
				Dictionary<int, int[]> oldSheetOffsetInformation = new Dictionary<int, int[]>();
				foreach (List<int> megaSheetMemberSheetIds in megaSheetMapping)
				{
					++megaSheetId;
					int totalMembers = megaSheetMemberSheetIds.Count;
					int imageUnitWidth = (int)(Math.Sqrt(totalMembers - 1) + 1);
					int imageWidth = GlUtil.NextPowerOf2(imageUnitWidth * 1024);
					Bitmap megaSheetBitmap = new Bitmap(imageWidth, imageWidth);
					megaSheetBitmap.SetResolution(96, 96);
					megaSheetById[megaSheetId] = megaSheetBitmap;
					Graphics graphics = Graphics.FromImage(megaSheetBitmap);

					for (int i = 0; i < megaSheetMemberSheetIds.Count; ++i)
					{
						int sheetId = megaSheetMemberSheetIds[i];
						// Allocate the ID's in this compact square pattern:
						// 0  1  4  9
						// 3  2  5  10
						// 8  7  6  11
						// 15 14 13 12
						// etc
						// "gen"eration refers to the layer # of the L shape that the sheet is occupying. 
						// Arithmetic magic.
						int gen = (int)Math.Floor(Math.Sqrt(i));
						int col = gen;
						int row = i - gen * gen;
						if (row > gen)
						{
							int adj = row - gen;
							col -= adj;
							row -= adj;
						}
						int x = col * 1024;
						int y = row * 1024;
						graphics.DrawImage(nonSolitarySheets[sheetId], x, y);
						oldSheetOffsetInformation[sheetId] = new int[] { megaSheetId, x, y };
					}

					graphics.Flush();
				}

				// now update the location information to reflect the new sheet ID's and locations
				foreach (int[] locationInfo in locations.Values)
				{
					int oldSheetId = locationInfo[0];
					if (oldSheetOffsetInformation.ContainsKey(oldSheetId))
					{
						int[] updatedInfo = oldSheetOffsetInformation[oldSheetId];
						locationInfo[0] = updatedInfo[0];
						locationInfo[1] += updatedInfo[1];
						locationInfo[2] += updatedInfo[2];
					}
				}
				// replace the non solitary sheets with the new mega sheets.
				nonSolitarySheets = megaSheetById;
			}

			Dictionary<int, CompositeImage> sheets = new Dictionary<int, CompositeImage>();
			Dictionary<int, Bitmap> allSheets = nonSolitarySheets;
			foreach (int sheetId in solitarySheets.Keys)
			{
				allSheets[sheetId] = solitarySheets[sheetId];
			}

			foreach (int sheetId in allSheets.Keys)
			{
				sheets[sheetId] = CrayonWrapper.v_createCompositeImage(allSheets[sheetId]);
			}

			return new ImageSheetVirtualizationGrid(
				locations,
				sheets,
				groupName,
				groupId,
				paths.ToArray());
		}

		public static void Initialize()
		{
			ImageSheetStatus imageUtil = TranslationHelper.ProgramData.imageSheetStatus;
			SpriteSheetData ssd = TranslationHelper.ProgramData.spriteSheetData;
			foreach (string groupId in ssd.groupIdsByName.Keys)
			{
				int id = ssd.groupIdsByName[groupId];
				imageUtil.groupNameToId[groupId] = id;
				imageUtil.sheetStatus[id] = IMAGE_SHEET_STATUS_NOT_LOADED;
				imageUtil.tilesPerId[id] = ssd.tileIdsByGroupId[id].Keys.OrderBy(k => k).ToArray();
			}

			foreach (SpriteSheetItemDescriptor ssid in ssd.files.Values)
			{
				List<SpriteSheetItemDescriptor> ssidForGroup;
				if (!imageUtil.spriteSheetItemDescriptorsByGroupId.TryGetValue(ssid.groupId, out ssidForGroup))
				{
					ssidForGroup = new List<SpriteSheetItemDescriptor>();
					imageUtil.spriteSheetItemDescriptorsByGroupId[ssid.groupId] = ssidForGroup;
				}
				ssidForGroup.Add(ssid);
			}

			foreach (int groupId in ssd.tileIdsByGroupId.Keys)
			{
				List<int> keys = new List<int>(ssd.tileIdsByGroupId[groupId].Keys);
				string[] tileNamesForGroupId = new string[keys.Count];
				for (int i = 0; i < keys.Count; ++i) {
					string name = groupId + "_" + keys[i];
					tileNamesForGroupId[i] = name;
				}
				imageUtil.generatedTileNamesByGroupId[groupId] = tileNamesForGroupId.ToArray();
			}
		}
	}
}
