using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;

namespace %%%PROJECT_ID%%%
{
	internal static class ImageUtil
	{
		private static object mutex = new object();
		private static object downloaderMutex = new object();

		private static ImageSheetStatus imageUtil { get { return TranslationHelper.ProgramData.imageSheetStatus; } }

		private static void EnsureBackgroundLoaderRunning()
		{
			BackgroundWorker bgWorker = null;
			lock (mutex)
			{
				if (!imageUtil.isBackgroundLoaderActive)
				{
					bgWorker = new BackgroundWorker();
					bgWorker.DoWork += bgWorker_DoWork;
					imageUtil.isBackgroundLoaderActive = true;
				}
			}
			if (bgWorker != null)
			{
				bgWorker.RunWorkerAsync();
			}
		}

		private static void bgWorker_DoWork(object sender, DoWorkEventArgs e)
		{
			while (true)
			{
				List<string> images = new List<string>();
				List<string> groupIdCompletionMarker = new List<string>();
				lock (mutex)
				{
					while (imageUtil.tileLoadQueue.Count > 0 && images.Count < TransitionaryCrayonHelper.IMAGE_SHEET_TILES_LOADED_PER_FRAME)
					{
						string[] parts = imageUtil.tileLoadQueue[0];
						imageUtil.tileLoadQueue.RemoveAt(0);
						string path = parts[0];
						string groupIdCompleted = parts[1];
						images.Add(path);
						if (groupIdCompletionMarker.Count > 0 && groupIdCompletionMarker[groupIdCompletionMarker.Count - 1] == groupIdCompleted)
						{
							groupIdCompletionMarker.Insert(groupIdCompletionMarker.Count - 1, null);
						}
						else
						{
							// note: if multiple background workers are added, this logic fails as one background worker could encounter 
							// the marker before another background worker has finished loading some of the tiles for the group
							groupIdCompletionMarker.Add(groupIdCompleted);
						}
					}
				}

				// TODO: go through and make variable names consistent (groupId vs groupName)

				for (int i = 0; i < images.Count; ++i)
				{
					string image = images[i];
					string groupNameCompleted = groupIdCompletionMarker[i];
					Bitmap bmp = ResourceReader.ReadImageFile("GeneratedFiles/spritesheets/" + image + ".png", true);
					lock (mutex)
					{
						imageUtil.tilesByName[image] = bmp;
						if (groupNameCompleted != null)
						{
							int groupId = imageUtil.groupNameToId[groupNameCompleted];
							// filter the tilesByName lookup to just the ones in this group now that it's done loading.
							string[] genNamesInGroup = imageUtil.generatedTileNamesByGroupId[groupId];
							Dictionary<string, object> tilesInGroupByGenName = new Dictionary<string, object>();
							foreach (string genName in genNamesInGroup)
							{
								tilesInGroupByGenName[genName] = imageUtil.tilesByName[genName];
							}

							// and create a virtualization grid for this group. 
							// This is a mapping of image paths to bitmap+location within the bitmap
							ICollection<SpriteSheetItemDescriptor> sheetMembers = GetSpriteSheetMembers(groupNameCompleted);
							ImageSheetVirtualizationGrid grid = TransitionaryCrayonHelper.IntantiateVirtualizationGrid(
									groupNameCompleted,
									imageUtil.spriteSheetItemDescriptorsByGroupId[groupId],
									tilesInGroupByGenName,
									imageUtil.groupNameToId);
							imageUtil.virtualizationGrids.Add(groupNameCompleted, grid);

							foreach (string path in grid.paths)
							{
								imageUtil.fileToVirtualizationGrid[path] = grid;
							}
						}
					}
				}

				bool stahp = false;
				lock (mutex)
				{
					stahp = imageUtil.tileLoadQueue.Count == 0;
				}

				if (stahp) break;
			}

			lock (mutex)
			{
				imageUtil.isBackgroundLoaderActive = false;
			}
		}

		private static ICollection<SpriteSheetItemDescriptor> GetSpriteSheetMembers(string groupName)
		{
			int groupId = imageUtil.groupNameToId[groupName];
			return imageUtil.spriteSheetItemDescriptorsByGroupId[groupId].ToArray();
		}

		public static int GetImageErrorCode(string key)
		{
			throw new NotImplementedException();
		}

		// will act like the image isn't there if a sprite sheet isn't loaded
		public static bool LoadImageFromEmbeddedResource(string key, string path)
		{
			bool spriteSheetItem = false;
			lock (mutex)
			{
				if (imageUtil.fileToVirtualizationGrid.ContainsKey(path))
				{
					spriteSheetItem = true;
					ImageSheetVirtualizationGrid grid = imageUtil.fileToVirtualizationGrid[path];
					int[] location = grid.imageLocations[path];
					imageUtil.resourceImagesByKeys[key] = grid.sheets[location[0]];
					imageUtil.texturePartitioningInformation[key] = location;
				}
			}

			if (spriteSheetItem)
			{
				return true;
			}
			else
			{
				Bitmap bmp = ResourceReader.ReadImageFile(path, false);
				if (bmp == null)
				{
					return false;
				}
				imageUtil.resourceImagesByKeys[key] = TransitionaryCrayonHelper.InstantiateCompositeImage(bmp);
				return true;
			}
		}

		// TODO: retry counter support
		public static void DownloadImageFromInternetTubes(string key, string url)
		{
			BackgroundWorker bgWorker = new BackgroundWorker();
			bgWorker.DoWork += (sender, args) =>
			{
				System.Net.WebClient wc = new System.Net.WebClient();
				try
				{
					byte[] imageBytes = wc.DownloadData(url);
					Bitmap bmp = new Bitmap(new System.IO.MemoryStream(imageBytes));
					bmp.SetResolution(96, 96);
					lock (downloaderMutex)
					{
						imageUtil.downloadedImagesByKey[key] = bmp;
						imageUtil.downloadedImagesErrorCodes[key] = 1;
					}
				}
				catch (Exception)
				{
					// TODO: figure out error codes
					lock (downloaderMutex)
					{
						imageUtil.downloadedImagesErrorCodes[key] = 2;
					}
				}
			};
			bgWorker.RunWorkerAsync();
		}

		public static void LoadImageFromUserData(string key, string path)
		{
			throw new NotImplementedException();
		}

		public static int IsImageLoaded(string key)
		{
			throw new NotImplementedException();
		}

		public static bool LoadSheet(string groupName)
		{
			bool sheetExists = false;
			bool loaderRequired = false;
			lock (mutex)
			{
				sheetExists = imageUtil.groupNameToId.ContainsKey(groupName);
				if (sheetExists)
				{
					int groupId = imageUtil.groupNameToId[groupName];
					if (imageUtil.sheetStatus[groupId] == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_NOT_LOADED)
					{
						imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING;
						int[] tiles = imageUtil.tilesPerId[groupId];
						for (int i = 0; i < tiles.Length; ++i)
						{
							int tileId = imageUtil.tilesPerId[groupId][i];
							imageUtil.tileLoadQueue.Add(new string[] { groupId + "_" + tileId, tiles.Length - 1 == i ? groupName : null });
						}
						loaderRequired = imageUtil.tileLoadQueue.Count > 0;
						if (!loaderRequired)
						{
							// This shouldn't really happen
							imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
						}
					}
				}
			}

			if (loaderRequired)
			{
				EnsureBackgroundLoaderRunning();
			}
			return sheetExists;
		}

		private static void EnsureSheetStatusUpToDate(int id)
		{
			lock (mutex)
			{
				if (imageUtil.sheetStatus[id] == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING)
				{
					bool allLoaded = true;
					foreach (int tileId in imageUtil.tilesPerId[id])
					{
						if (!imageUtil.tilesByName.ContainsKey(id + "_" + tileId))
						{
							allLoaded = false;
							break;
						}
					}
					if (allLoaded)
					{
						imageUtil.sheetStatus[id] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
					}
				}
			}
		}

		public static int IsImageSheetLoaded(string groupId)
		{
			int id = -1;
			lock (mutex)
			{
				imageUtil.groupNameToId.TryGetValue(groupId, out id);
			}

			int status = 2; // error code
			if (id != -1)
			{
				EnsureSheetStatusUpToDate(id);

				lock (mutex)
				{
					switch (imageUtil.sheetStatus[id])
					{
						case TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED: status = 1; break;
						case TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING: status = 0; break;
						default: status = 2; break;
					}
				}
			}
			return status;
		}

		public static int GetSheetErrorCode(string groupId)
		{
			return 0;
		}

		public static int GetNumTiles(string groupName)
		{
			int tileCount = -1;
			lock (mutex)
			{
				int groupId;
				if (imageUtil.groupNameToId.TryGetValue(groupName, out groupId))
				{
					tileCount = imageUtil.tilesPerId[groupId].Length;
				}
			}
			return tileCount;
		}

		public static int GetNumTilesLoaded(string groupName)
		{
			EnsureBackgroundLoaderRunning();

			int tileCount = -1;
			lock (mutex)
			{
				int groupId;
				if (imageUtil.groupNameToId.TryGetValue(groupName, out groupId))
				{
					tileCount = 0;
					foreach (int tileId in imageUtil.tilesPerId[groupId])
					{
						if (imageUtil.tilesByName.ContainsKey(groupId + "_" + tileId))
						{
							++tileCount;
						}
					}
				}
			}
			return tileCount;
		}

		private static Dictionary<string, Image> loadedImagesByKey = new Dictionary<string, Image>();
		public static Image GetImageByKey(string key)
		{
			if (imageUtil.resourceImagesByKeys.ContainsKey(key))
			{
				CompositeImage bmp = imageUtil.resourceImagesByKeys[key];
				int x = 0;
				int y = 0;
				int width = bmp.width;
				int height = bmp.height;
				if (imageUtil.texturePartitioningInformation.ContainsKey(key))
				{
					int[] location = imageUtil.texturePartitioningInformation[key];
					x = location[1];
					y = location[2];
					width = location[3];
					height = location[4];
				}
				return CrayonWrapper.v_instantiateImage(bmp, x, y, width, height, false, false);
			}
			return null;
		}
	}
}
