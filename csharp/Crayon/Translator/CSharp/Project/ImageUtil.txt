using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;

namespace %%%PROJECT_ID%%%
{
	internal static class ImageUtil
	{
		private static ImageSheetStatus imageUtil { get { return TranslationHelper.ProgramData.imageSheetStatus; } }

		public static bool PerformWorkNugget()
		{
			if (imageUtil.tileLoadQueue.Count == 0) return false;

			List<string> images = new List<string>();
			// TODO: need to redo the groupIdCompletionMarker because JavaScript can download images in the wrong order.
			List<string> groupIdCompletionMarker = new List<string>();

			// Grab N images that need to be loaded.
			while (imageUtil.tileLoadQueue.Count > 0 && images.Count < TransitionaryCrayonHelper.IMAGE_SHEET_TILES_LOADED_PER_FRAME)
			{
				string[] parts = imageUtil.tileLoadQueue[0];
				imageUtil.tileLoadQueue.RemoveAt(0);
				string path = parts[0];
				string groupIdCompleted = parts[1];
				images.Add(path);
				if (groupIdCompletionMarker.Count > 0 && groupIdCompletionMarker[groupIdCompletionMarker.Count - 1] == groupIdCompleted)
				{
					groupIdCompletionMarker.Insert(groupIdCompletionMarker.Count - 1, null);
				}
				else
				{
					// note: if multiple background workers are added, this logic fails as one background worker could encounter 
					// the marker before another background worker has finished loading some of the tiles for the group
					groupIdCompletionMarker.Add(groupIdCompleted);
				}
			}

			for (int i = 0; i < images.Count; ++i)
			{
				string image = images[i];
				string groupNameCompleted = groupIdCompletionMarker[i];
				Bitmap bmp = ResourceReader.ReadImageFile("GeneratedFiles/spritesheets/" + image + ".png", true);

				imageUtil.tilesByName[image] = bmp;
				if (groupNameCompleted != null)
				{
					int groupId = imageUtil.groupNameToId[groupNameCompleted];
					// filter the tilesByName lookup to just the ones in this group now that it's done loading.
					string[] genNamesInGroup = imageUtil.generatedTileNamesByGroupId[groupId];
					Dictionary<string, object> tilesInGroupByGenName = new Dictionary<string, object>();
					foreach (string genName in genNamesInGroup)
					{
						tilesInGroupByGenName[genName] = imageUtil.tilesByName[genName];
					}

					// and create a virtualization grid for this group. 
					// This is a mapping of image paths to bitmap+location within the bitmap
					List<SpriteSheetItemDescriptor> sheetMembers = CrayonWrapper.v_getSpriteSheetMembers(imageUtil, groupNameCompleted);
					ImageSheetVirtualizationGrid grid = TransitionaryCrayonHelper.IntantiateVirtualizationGrid(
							groupNameCompleted,
							imageUtil.spriteSheetItemDescriptorsByGroupId[groupId],
							tilesInGroupByGenName,
							imageUtil.groupNameToId);
					imageUtil.virtualizationGrids.Add(groupNameCompleted, grid);

					foreach (string path in grid.paths)
					{
						imageUtil.fileToVirtualizationGrid[path] = grid;
					}
				}
			}

			return true;
		}

		public static int GetImageErrorCode(string key)
		{
			throw new NotImplementedException();
		}

		// will act like the image isn't there if a sprite sheet isn't loaded
		public static bool LoadImageFromEmbeddedResource(string key, string path)
		{
			if (imageUtil.fileToVirtualizationGrid.ContainsKey(path))
			{
				ImageSheetVirtualizationGrid grid = imageUtil.fileToVirtualizationGrid[path];
				int[] location = grid.imageLocations[path];
				imageUtil.resourceImagesByKeys[key] = grid.sheets[location[0]];
				imageUtil.texturePartitioningInformation[key] = location;
				return true;
			}

			Bitmap bmp = ResourceReader.ReadImageFile(path, false);
			if (bmp == null)
			{
				return false;
			}
			imageUtil.resourceImagesByKeys[key] = TransitionaryCrayonHelper.InstantiateCompositeImage(bmp);
			return true;
		}

		// TODO: retry counter support
		public static void DownloadImageFromInternetTubes(string key, string url)
		{
			BackgroundWorker bgWorker = new BackgroundWorker();
			bgWorker.DoWork += (sender, args) =>
			{
				System.Net.WebClient wc = new System.Net.WebClient();
				try
				{
					byte[] imageBytes = wc.DownloadData(url);
					Bitmap bmp = new Bitmap(new System.IO.MemoryStream(imageBytes));
					bmp.SetResolution(96, 96);
					args.Result = bmp;
				}
				catch (Exception)
				{
					args.Result = null;
				}
			};
			bgWorker.RunWorkerCompleted += (sender, args) =>
			{
				// TODO: more in-depth error codes than "2"
				object bmp = args.Result;
				imageUtil.downloadedImagesByKey[key] = args.Result;
				imageUtil.downloadedImagesErrorCodes[key] = bmp == null ? 2 : 1;
			};
			bgWorker.RunWorkerAsync();
		}

		public static void LoadImageFromUserData(string key, string path)
		{
			throw new NotImplementedException();
		}

		public static int IsImageLoaded(string key)
		{
			throw new NotImplementedException();
		}

		public static bool LoadSheet(string groupName)
		{
			bool sheetExists = false;
			bool loaderRequired = false;

			sheetExists = imageUtil.groupNameToId.ContainsKey(groupName);
			if (sheetExists)
			{
				int groupId = imageUtil.groupNameToId[groupName];
				if (imageUtil.sheetStatus[groupId] == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_NOT_LOADED)
				{
					imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING;
					int[] tiles = imageUtil.tilesPerId[groupId];
					for (int i = 0; i < tiles.Length; ++i)
					{
						int tileId = imageUtil.tilesPerId[groupId][i];
						imageUtil.tileLoadQueue.Add(new string[] { groupId + "_" + tileId, tiles.Length - 1 == i ? groupName : null });
					}
					loaderRequired = imageUtil.tileLoadQueue.Count > 0;
					if (!loaderRequired)
					{
						// This shouldn't really happen
						imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
					}
				}
			}

			return sheetExists;
		}

		private static void EnsureSheetStatusUpToDate(int id)
		{
			if (imageUtil.sheetStatus[id] == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING)
			{
				bool allLoaded = true;
				foreach (int tileId in imageUtil.tilesPerId[id])
				{
					if (!imageUtil.tilesByName.ContainsKey(id + "_" + tileId))
					{
						allLoaded = false;
						break;
					}
				}
				if (allLoaded)
				{
					imageUtil.sheetStatus[id] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
				}
			}
		}

		public static int IsImageSheetLoaded(string groupId)
		{
			int id = -1;
			imageUtil.groupNameToId.TryGetValue(groupId, out id);

			int status = 2; // error code
			if (id != -1)
			{
				EnsureSheetStatusUpToDate(id);

				switch (imageUtil.sheetStatus[id])
				{
					case TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED: status = 1; break;
					case TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING: status = 0; break;
					default: status = 2; break;
				}
			}
			return status;
		}

		public static int GetSheetErrorCode(string groupId)
		{
			return 0;
		}

		public static int GetNumTiles(string groupName)
		{
			int groupId;
			if (imageUtil.groupNameToId.TryGetValue(groupName, out groupId))
			{
				return imageUtil.tilesPerId[groupId].Length;
			}
			return -1;
		}

		public static int GetNumTilesLoaded(string groupName)
		{
			int groupId;
			if (imageUtil.groupNameToId.TryGetValue(groupName, out groupId))
			{
				int tileCount = 0;
				foreach (int tileId in imageUtil.tilesPerId[groupId])
				{
					if (imageUtil.tilesByName.ContainsKey(groupId + "_" + tileId))
					{
						++tileCount;
					}
				}
				return tileCount;
			}
			return -1;
		}

	}
}
