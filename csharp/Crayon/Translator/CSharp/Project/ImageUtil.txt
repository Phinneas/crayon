using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;

namespace %%%PROJECT_ID%%%
{
	public static class TransitionaryCrayonHelper
	{
		public static CompositeImage InstantiateCompositeImage(object nativeBitmap)
		{
			CompositeImage output = new CompositeImage(
				nativeBitmap,
				((Bitmap)nativeBitmap).Width,
				((Bitmap)nativeBitmap).Height,
				-1,
				false);
			return output;
		}

		public static bool LoadCompositeImageResource(CompositeImage compositeImage)
		{
			compositeImage.glTextureId = GlUtil.ForceLoadTexture((Bitmap)compositeImage.nativeBitmap);
			compositeImage.loaded = true;
			return true;
		}

		public static ImageSheetVirtualizationGrid IntantiateVirtualizationGrid(
			string groupName,
			List<SpriteSheetItemDescriptor> spriteSheetItemDescriptors,
			Dictionary<string, object> nativeTileBitmapsByGeneratedName,
			Dictionary<string, int> groupNameToId)
		{
			int groupId = groupNameToId[groupName];

			Dictionary<int, Bitmap> tiles = new Dictionary<int, Bitmap>();
			Dictionary<int, Graphics> sheetGraphics = new Dictionary<int, Graphics>();

			// [ tile ID, x, y, width, height ]
			Dictionary<string, int[]> locations = new Dictionary<string, int[]>();

			List<string> paths = new List<string>();

			Dictionary<int, Bitmap> nonSolitarySheets = new Dictionary<int, Bitmap>();
			Dictionary<int, Bitmap> solitarySheets = new Dictionary<int, Bitmap>();

			int biggestSheetId = 0;
			foreach (SpriteSheetItemDescriptor item in spriteSheetItemDescriptors)
			{
				string filename = item.filePath;
				paths.Add(filename);
				int x = item.x;
				int y = item.y;
				int width = item.width;
				int height = item.height;
				int tileId = item.tileId;
				if (tileId > biggestSheetId)
				{
					biggestSheetId = tileId;
				}
				string generatedName = groupId + "_" + tileId;

				if (item.solitary)
				{
					solitarySheets[tileId] = (Bitmap)nativeTileBitmapsByGeneratedName[generatedName];
					locations[filename] = new int[] { tileId, 0, 0, item.width, item.height };
				}
				else
				{
					int col, row;
					int roundedId = tileId / 16 * 16;
					if (!nonSolitarySheets.ContainsKey(roundedId))
					{
						Bitmap bigSheet = new Bitmap(1024, 1024, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
						nonSolitarySheets[roundedId] = bigSheet;
						bigSheet.SetResolution(96, 96);
						sheetGraphics[roundedId] = Graphics.FromImage(bigSheet);

						for (int i = 0; i < 16; ++i)
						{
							int interiorTileId = roundedId + i;
							string interiorTileGeneratedName = groupId + "_" + interiorTileId;
							col = i % 4;
							row = i / 4;
							if (nativeTileBitmapsByGeneratedName.ContainsKey(interiorTileGeneratedName))
							{
								sheetGraphics[roundedId].DrawImage(
									(Bitmap)nativeTileBitmapsByGeneratedName[interiorTileGeneratedName],
									col * 256,
									row * 256);
							}
						}
					}

					col = (tileId - roundedId) % 4;
					row = (tileId - roundedId) / 4;

					locations[filename] = new int[] { roundedId, col * 256 + item.x, row * 256 + item.y, item.width, item.height };
				}
			}

			// Go through and further consolidate things if possible. 
			if (GlUtil.MaxTextureSize > 1024 && nonSolitarySheets.Count > 1)
			{
				int unitLength = GlUtil.MaxTextureSize / 1024;
				int maxSheetsPerMegaSheet = unitLength * unitLength;
				int sheetCount = nonSolitarySheets.Count;

				// Start making a list of ID groupings that don't exceed the maximum capacity of a megasheet.
				List<List<int>> megaSheetMapping = new List<List<int>>();
				foreach (int sheetIdToCombine in nonSolitarySheets.Keys.OrderBy<int, int>(i => i))
				{
					if (megaSheetMapping.Count == 0 || megaSheetMapping[megaSheetMapping.Count - 1].Count == maxSheetsPerMegaSheet)
					{
						megaSheetMapping.Add(new List<int>());
					}
					megaSheetMapping[megaSheetMapping.Count - 1].Add(sheetIdToCombine);
				}

				// now that the members of the mega sheets are fully determined, create the images.
				int megaSheetId = biggestSheetId;
				Dictionary<int, Bitmap> megaSheetById = new Dictionary<int, Bitmap>();
				Dictionary<int, int[]> oldSheetOffsetInformation = new Dictionary<int, int[]>();
				foreach (List<int> megaSheetMemberSheetIds in megaSheetMapping)
				{
					++megaSheetId;
					int totalMembers = megaSheetMemberSheetIds.Count;
					int imageUnitWidth = (int)(Math.Sqrt(totalMembers - 1) + 1);
					int imageWidth = GlUtil.NextPowerOf2(imageUnitWidth * 1024);
					Bitmap megaSheetBitmap = new Bitmap(imageWidth, imageWidth);
					megaSheetBitmap.SetResolution(96, 96);
					megaSheetById[megaSheetId] = megaSheetBitmap;
					Graphics graphics = Graphics.FromImage(megaSheetBitmap);

					for (int i = 0; i < megaSheetMemberSheetIds.Count; ++i)
					{
						int sheetId = megaSheetMemberSheetIds[i];
						// Allocate the ID's in this compact square pattern:
						// 0  1  4  9
						// 3  2  5  10
						// 8  7  6  11
						// 15 14 13 12
						// etc
						// "gen"eration refers to the layer # of the L shape that the sheet is occupying. 
						// Arithmetic magic.
						int gen = (int)Math.Floor(Math.Sqrt(i));
						int col = gen;
						int row = i - gen * gen;
						if (row > gen)
						{
							int adj = row - gen;
							col -= adj;
							row -= adj;
						}
						int x = col * 1024;
						int y = row * 1024;
						graphics.DrawImage(nonSolitarySheets[sheetId], x, y);
						oldSheetOffsetInformation[sheetId] = new int[] { megaSheetId, x, y };
					}

					graphics.Flush();
				}

				// now update the location information to reflect the new sheet ID's and locations
				foreach (int[] locationInfo in locations.Values)
				{
					int oldSheetId = locationInfo[0];
					if (oldSheetOffsetInformation.ContainsKey(oldSheetId))
					{
						int[] updatedInfo = oldSheetOffsetInformation[oldSheetId];
						locationInfo[0] = updatedInfo[0];
						locationInfo[1] += updatedInfo[1];
						locationInfo[2] += updatedInfo[2];
					}
				}
				// replace the non solitary sheets with the new mega sheets.
				nonSolitarySheets = megaSheetById;
			}

			Dictionary<int, CompositeImage> sheets = new Dictionary<int, CompositeImage>();
			Dictionary<int, Bitmap> allSheets = nonSolitarySheets;
			foreach (int sheetId in solitarySheets.Keys)
			{
				allSheets[sheetId] = solitarySheets[sheetId];
			}

			foreach (int sheetId in allSheets.Keys)
			{
				sheets[sheetId] = TransitionaryCrayonHelper.InstantiateCompositeImage(allSheets[sheetId]);
			}

			return new ImageSheetVirtualizationGrid(
				locations,
				sheets,
				groupName,
				groupId,
				paths.ToArray());
		}
	}

	internal static class ImageUtil
	{
		private const int TILES_LOADED_PER_FRAME = 1;

		private const int STATUS_NOT_LOADED = 0;
		private const int STATUS_LOADING = 1;
		private const int STATUS_LOADED = 2;

		private static object mutex = new object();
		private static bool isBackgroundLoaderActive = false;

		private static object downloaderMutex = new object();
		private static Dictionary<string, Bitmap> downloadedImagesByKey = new Dictionary<string, Bitmap>();
		private static Dictionary<string, int> downloadedImagesErrorCodes = new Dictionary<string, int>();

		private static Dictionary<string, Bitmap> tilesByName = new Dictionary<string, Bitmap>();
		private static Queue<string[]> tileLoadQueue = new Queue<string[]>();
		private static Dictionary<int, int[]> tilesPerId = new Dictionary<int, int[]>();
		private static Dictionary<int, int> sheetStatus = new Dictionary<int, int>();
		private static Dictionary<string, int> groupNameToId = new Dictionary<string, int>();
		private static Dictionary<string, ImageSheetVirtualizationGrid> virtualizationGrids = new Dictionary<string, ImageSheetVirtualizationGrid>();
		private static Dictionary<string, ImageSheetVirtualizationGrid> fileToVirtualizationGrid = new Dictionary<string, ImageSheetVirtualizationGrid>();
		private static Dictionary<int, List<SpriteSheetItemDescriptor>> spriteSheetItemDescriptorsByGroupId = new Dictionary<int, List<SpriteSheetItemDescriptor>>();
		private static Dictionary<int, string[]> generatedTileNamesByGroupId = new Dictionary<int, string[]>();

		// These 2 lookups are to be treated as one dictionary:
		// image key => [bitmap, x, y, width, height]
		private static Dictionary<string, CompositeImage> resourceImagesByKeys = new Dictionary<string, CompositeImage>();
		private static Dictionary<string, int[]> texturePartitioningInformation = new Dictionary<string, int[]>();

		public static void Initialize()
		{
			lock (mutex)
			{
				SpriteSheetData ssd = TranslationHelper.ProgramData.spriteSheetData;
				foreach (string groupId in ssd.groupIdsByName.Keys)
				{
					int id = ssd.groupIdsByName[groupId];
					groupNameToId[groupId] = id;
					sheetStatus[id] = STATUS_NOT_LOADED;
					tilesPerId[id] = ssd.tileIdsByGroupId[id].Keys.OrderBy(k => k).ToArray();
				}

				foreach (SpriteSheetItemDescriptor ssid in ssd.files.Values)
				{
					List<SpriteSheetItemDescriptor> ssidForGroup;
					if (!spriteSheetItemDescriptorsByGroupId.TryGetValue(ssid.groupId, out ssidForGroup))
					{
						ssidForGroup = new List<SpriteSheetItemDescriptor>();
						spriteSheetItemDescriptorsByGroupId[ssid.groupId] = ssidForGroup;
					}
					ssidForGroup.Add(ssid);
				}

				foreach (int groupId in ssd.tileIdsByGroupId.Keys)
				{
					generatedTileNamesByGroupId[groupId] = ssd.tileIdsByGroupId[groupId].Keys
						.Select<int, string>(tileId => groupId + "_" + tileId)
						.ToArray();
				}
			}
		}

		private static void EnsureBackgroundLoaderRunning()
		{
			BackgroundWorker bgWorker = null;
			lock (mutex)
			{
				if (!isBackgroundLoaderActive)
				{
					bgWorker = new BackgroundWorker();
					bgWorker.DoWork += bgWorker_DoWork;
					isBackgroundLoaderActive = true;
				}
			}
			if (bgWorker != null)
			{
				bgWorker.RunWorkerAsync();
			}
		}

		private static void bgWorker_DoWork(object sender, DoWorkEventArgs e)
		{
			while (true)
			{
				List<string> images = new List<string>();
				List<string> groupIdCompletionMarker = new List<string>();
				lock (mutex)
				{
					while (tileLoadQueue.Count > 0 && images.Count < TILES_LOADED_PER_FRAME)
					{
						string[] parts = tileLoadQueue.Dequeue();
						string path = parts[0];
						string groupIdCompleted = parts[1];
						images.Add(path);
						if (groupIdCompletionMarker.Count > 0 && groupIdCompletionMarker[groupIdCompletionMarker.Count - 1] == groupIdCompleted)
						{
							groupIdCompletionMarker.Insert(groupIdCompletionMarker.Count - 1, null);
						}
						else
						{
							// note: if multiple background workers are added, this logic fails as one background worker could encounter 
							// the marker before another background worker has finished loading some of the tiles for the group
							groupIdCompletionMarker.Add(groupIdCompleted);
						}
					}
				}

				// TODO: go through and make variable names consistent (groupId vs groupName)

				for (int i = 0; i < images.Count; ++i)
				{
					string image = images[i];
					string groupNameCompleted = groupIdCompletionMarker[i];
					Bitmap bmp = ResourceReader.ReadImageFile("GeneratedFiles/spritesheets/" + image + ".png", true);
					lock (mutex)
					{
						tilesByName[image] = bmp;
						if (groupNameCompleted != null)
						{
							int groupId = groupNameToId[groupNameCompleted];
							// filter the tilesByName lookup to just the ones in this group now that it's done loading.
							string[] genNamesInGroup = generatedTileNamesByGroupId[groupId];
							Dictionary<string, object> tilesInGroupByGenName = new Dictionary<string, object>();
							foreach (string genName in genNamesInGroup)
							{
								tilesInGroupByGenName[genName] = tilesByName[genName];
							}

							// and create a virtualization grid for this group. 
							// This is a mapping of image paths to bitmap+location within the bitmap
							ICollection<SpriteSheetItemDescriptor> sheetMembers = GetSpriteSheetMembers(groupNameCompleted);
							ImageSheetVirtualizationGrid grid = TransitionaryCrayonHelper.IntantiateVirtualizationGrid(
									groupNameCompleted,
									spriteSheetItemDescriptorsByGroupId[groupId],
									tilesInGroupByGenName,
									groupNameToId);
							virtualizationGrids.Add(groupNameCompleted, grid);

							foreach (string path in grid.paths)
							{
								fileToVirtualizationGrid[path] = grid;
							}
						}
					}
				}

				bool stahp = false;
				lock (mutex)
				{
					stahp = tileLoadQueue.Count == 0;
				}

				if (stahp) break;
			}

			lock (mutex)
			{
				isBackgroundLoaderActive = false;
			}
		}

		private static ICollection<SpriteSheetItemDescriptor> GetSpriteSheetMembers(string groupName)
		{
			int groupId = groupNameToId[groupName];
			return spriteSheetItemDescriptorsByGroupId[groupId].ToArray();
		}

		public static int GetImageErrorCode(string key)
		{
			throw new NotImplementedException();
		}

		// will act like the image isn't there if a sprite sheet isn't loaded
		public static bool LoadImageFromEmbeddedResource(string key, string path)
		{
			bool spriteSheetItem = false;
			lock (mutex)
			{
				if (fileToVirtualizationGrid.ContainsKey(path))
				{
					spriteSheetItem = true;
					ImageSheetVirtualizationGrid grid = fileToVirtualizationGrid[path];
					int[] location = grid.imageLocations[path];
					resourceImagesByKeys[key] = grid.sheets[location[0]];
					texturePartitioningInformation[key] = location;
				}
			}

			if (spriteSheetItem)
			{
				return true;
			}
			else
			{
				Bitmap bmp = ResourceReader.ReadImageFile(path, false);
				if (bmp == null)
				{
					return false;
				}
				resourceImagesByKeys[key] = TransitionaryCrayonHelper.InstantiateCompositeImage(bmp);
				return true;
			}
		}

		// TODO: retry counter support
		public static void DownloadImageFromInternetTubes(string key, string url)
		{
			BackgroundWorker bgWorker = new BackgroundWorker();
			bgWorker.DoWork += (sender, args) =>
			{
				System.Net.WebClient wc = new System.Net.WebClient();
				try
				{
					byte[] imageBytes = wc.DownloadData(url);
					Bitmap bmp = new Bitmap(new System.IO.MemoryStream(imageBytes));
					bmp.SetResolution(96, 96);
					lock (downloaderMutex)
					{
						downloadedImagesByKey[key] = bmp;
						downloadedImagesErrorCodes[key] = 1;
					}
				}
				catch (Exception)
				{
					// TODO: figure out error codes
					lock (downloaderMutex)
					{
						downloadedImagesErrorCodes[key] = 2;
					}
				}
			};
			bgWorker.RunWorkerAsync();
		}

		public static void LoadImageFromUserData(string key, string path)
		{
			throw new NotImplementedException();
		}

		public static int IsImageLoaded(string key)
		{
			throw new NotImplementedException();
		}

		public static bool LoadSheet(string groupName)
		{
			bool sheetExists = false;
			bool loaderRequired = false;
			lock (mutex)
			{
				sheetExists = groupNameToId.ContainsKey(groupName);
				if (sheetExists)
				{
					int groupId = groupNameToId[groupName];
					if (sheetStatus[groupId] == STATUS_NOT_LOADED)
					{
						sheetStatus[groupId] = STATUS_LOADING;
						int[] tiles = tilesPerId[groupId];
						for (int i = 0; i < tiles.Length; ++i)
						{
							int tileId = tilesPerId[groupId][i];
							tileLoadQueue.Enqueue(new string[] { groupId + "_" + tileId, tiles.Length - 1 == i ? groupName : null });
						}
						loaderRequired = tileLoadQueue.Count > 0;
						if (!loaderRequired)
						{
							// This shouldn't really happen
							sheetStatus[groupId] = STATUS_LOADED;
						}
					}
				}
			}

			if (loaderRequired)
			{
				EnsureBackgroundLoaderRunning();
			}
			return sheetExists;
		}

		private static void EnsureSheetStatusUpToDate(int id)
		{
			lock (mutex)
			{
				if (sheetStatus[id] == STATUS_LOADING)
				{
					bool allLoaded = true;
					foreach (int tileId in tilesPerId[id])
					{
						if (!tilesByName.ContainsKey(id + "_" + tileId))
						{
							allLoaded = false;
							break;
						}
					}
					if (allLoaded)
					{
						sheetStatus[id] = STATUS_LOADED;
					}
				}
			}
		}

		public static int IsImageSheetLoaded(string groupId)
		{
			int id = -1;
			lock (mutex)
			{
				groupNameToId.TryGetValue(groupId, out id);
			}

			int status = 2; // error code
			if (id != -1)
			{
				EnsureSheetStatusUpToDate(id);

				lock (mutex)
				{
					switch (sheetStatus[id])
					{
						case STATUS_LOADED: status = 1; break;
						case STATUS_LOADING: status = 0; break;
						default: status = 2; break;
					}
				}
			}
			return status;
		}

		public static int GetSheetErrorCode(string groupId)
		{
			return 0;
		}

		public static int GetNumTiles(string groupName)
		{
			int tileCount = -1;
			lock (mutex)
			{
				int groupId;
				if (groupNameToId.TryGetValue(groupName, out groupId))
				{
					tileCount = tilesPerId[groupId].Length;
				}
			}
			return tileCount;
		}

		public static int GetNumTilesLoaded(string groupName)
		{
			EnsureBackgroundLoaderRunning();

			int tileCount = -1;
			lock (mutex)
			{
				int groupId;
				if (groupNameToId.TryGetValue(groupName, out groupId))
				{
					tileCount = 0;
					foreach (int tileId in tilesPerId[groupId])
					{
						if (tilesByName.ContainsKey(groupId + "_" + tileId))
						{
							++tileCount;
						}
					}
				}
			}
			return tileCount;
		}

		private static Dictionary<string, Image> loadedImagesByKey = new Dictionary<string, Image>();
		public static Image GetImageByKey(string key)
		{
			if (resourceImagesByKeys.ContainsKey(key))
			{
				CompositeImage bmp = resourceImagesByKeys[key];
				int x = 0;
				int y = 0;
				int width = bmp.width;
				int height = bmp.height;
				if (texturePartitioningInformation.ContainsKey(key))
				{
					int[] location = texturePartitioningInformation[key];
					x = location[1];
					y = location[2];
					width = location[3];
					height = location[4];
				}
				return new Image(bmp, x, y, width, height, false, false);
			}
			return null;
		}
	}
}
