using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;

namespace %%%PROJECT_ID%%%
{
	internal static class ImageUtil
	{
		private static ImageSheetStatus imageUtil { get { return TranslationHelper.ProgramData.imageSheetStatus; } }

		// Fire requests to load tiles
		public static void PerformWorkNuggetPostFrame()
		{
			List<TileLoadRequest> queue = imageUtil.tileLoadQueue;

			// nothing to do
			if (queue.Count > 0)
			{
				// All requests are populated into the tile load queue when the user invokes the loading of a sheet.
				// This loop ensures that at least IMAGE_SHEET_TILES_LOADED_PER_FRAME downloads are active during the gap between frames.
				int activeDownloads = 0;
				for (int i = 0; i < queue.Count && activeDownloads < TransitionaryCrayonHelper.IMAGE_SHEET_TILES_LOADED_PER_FRAME; ++i)
				{
					TileLoadRequest request = queue[i];
					if (request.status == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_NOT_LOADED)
					{
						ImageUtil.InitiateTileLoading(request);
						activeDownloads++;
					}
					else if (request.status == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED)
					{
						// should this be an assert?
					}
				}
			}
		}

		public static void InitiateTileLoading(TileLoadRequest request)
		{
			// In C#, this is synchronous...
			request.nativeResource = ResourceReader.ReadImageFile("GeneratedFiles/spritesheets/" + request.path + ".png", true);
			// ...and so you immediately want to mark the status as loaded.
			request.status = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
			// TODO: conditional logic for aysnchronous downloads that have a handler that basically do the same thing.
		}

		public static bool AreAllTilesLoadedForGroupId(ImageSheetStatus iss, int groupId)
		{
			int[] tileIds = iss.tilesPerId[groupId];
			Dictionary<string, object> tilesByName = iss.tilesByName;
			for (int i = tileIds.Length - 1; i >= 0; --i)
			{
				int tileId = tileIds[i];
				string genName = groupId + "_" + tileId;
				if (!tilesByName.ContainsKey(genName))
				{
					return false;
				}
			}
			return true;
		}

		public static void FinalizeGroupLoading(int groupId, string groupName)
		{
			// filter the tilesByName lookup to just the ones in this group now that it's done loading.
			string[] genNamesInGroup = imageUtil.generatedTileNamesByGroupId[groupId];
			Dictionary<string, object> tilesInGroupByGenName = new Dictionary<string, object>();
			foreach (string genName in genNamesInGroup)
			{
				tilesInGroupByGenName[genName] = imageUtil.tilesByName[genName];
			}

			// and create a virtualization grid for this group. 
			// This is a mapping of image paths to bitmap+location within the bitmap
			List<SpriteSheetItemDescriptor> sheetMembers = CrayonWrapper.v_getSpriteSheetMembers(imageUtil, groupName);
			ImageSheetVirtualizationGrid grid = TransitionaryCrayonHelper.IntantiateVirtualizationGrid(
					groupName,
					imageUtil.spriteSheetItemDescriptorsByGroupId[groupId],
					tilesInGroupByGenName,
					imageUtil.groupNameToId);
			imageUtil.virtualizationGrids.Add(groupName, grid);

			foreach (string path in grid.paths)
			{
				imageUtil.fileToVirtualizationGrid[path] = grid;
			}

			imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
		}

		// Check to see if any tiles have been loaded
		public static bool PerformWorkNuggetPreFrame()
		{
			List<TileLoadRequest> queue = imageUtil.tileLoadQueue;
			if (queue.Count == 0) return false;

			for (int i = 0; i < queue.Count; ++i)
			{
				TileLoadRequest request = queue[i];
				if (request.status == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED)
				{
					// [down]load complete. Add to the ImageSheetStatus and figure out if this was the last one for the group.
					imageUtil.tilesByName[request.path] = request.nativeResource;
					int groupId = request.groupId;
					if (AreAllTilesLoadedForGroupId(imageUtil, groupId))
					{
						FinalizeGroupLoading(groupId, request.groupName);
					}
					queue.RemoveAt(i);
					--i;
				}
			}

			return true;
		}

		public static int GetImageErrorCode(string key)
		{
			throw new NotImplementedException();
		}

		// will act like the image isn't there if a sprite sheet isn't loaded
		public static bool LoadImageFromEmbeddedResource(string key, string path)
		{
			if (imageUtil.fileToVirtualizationGrid.ContainsKey(path))
			{
				ImageSheetVirtualizationGrid grid = imageUtil.fileToVirtualizationGrid[path];
				int[] location = grid.imageLocations[path];
				imageUtil.resourceImagesByKeys[key] = grid.sheets[location[0]];
				imageUtil.texturePartitioningInformation[key] = location;
				return true;
			}

			Bitmap bmp = ResourceReader.ReadImageFile(path, false);
			if (bmp == null)
			{
				return false;
			}
			imageUtil.resourceImagesByKeys[key] = CrayonWrapper.v_createCompositeImage(bmp);
			return true;
		}

		// TODO: retry counter support
		public static void DownloadImageFromInternetTubes(string key, string url)
		{
			BackgroundWorker bgWorker = new BackgroundWorker();
			bgWorker.DoWork += (sender, args) =>
			{
				System.Net.WebClient wc = new System.Net.WebClient();
				try
				{
					byte[] imageBytes = wc.DownloadData(url);
					Bitmap bmp = new Bitmap(new System.IO.MemoryStream(imageBytes));
					bmp.SetResolution(96, 96);
					args.Result = bmp;
				}
				catch (Exception)
				{
					args.Result = null;
				}
			};
			bgWorker.RunWorkerCompleted += (sender, args) =>
			{
				// TODO: more in-depth error codes than "2"
				object bmp = args.Result;
				imageUtil.downloadedImagesByKey[key] = args.Result;
				imageUtil.downloadedImagesErrorCodes[key] = bmp == null ? 2 : 1;
			};
			bgWorker.RunWorkerAsync();
		}

		public static void LoadImageFromUserData(string key, string path)
		{
			throw new NotImplementedException();
		}

		public static int IsImageLoaded(string key)
		{
			throw new NotImplementedException();
		}

		public static bool LoadSheet(string groupName)
		{
			bool sheetExists = false;

			sheetExists = imageUtil.groupNameToId.ContainsKey(groupName);
			if (sheetExists)
			{
				int groupId = imageUtil.groupNameToId[groupName];
				if (imageUtil.sheetStatus[groupId] == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_NOT_LOADED)
				{
					imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING;
					int[] tiles = imageUtil.tilesPerId[groupId];
					for (int i = 0; i < tiles.Length; ++i)
					{
						int tileId = imageUtil.tilesPerId[groupId][i];
						string tileGenName = groupId + "_" + tileId;
						imageUtil.tileLoadQueue.Add(
							new TileLoadRequest(
								tileGenName,
								TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_NOT_LOADED,
								groupId,
								groupName,
								tileId,
								null));
					}

					// If for some reason an empty sheet somehow was present in the metadata, ensure that it doesn't
					// report that it's loading indefinitely by marking it instantly loaded...
					if (tiles.Length == 0)
					{
						imageUtil.sheetStatus[groupId] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
					}
				}
			}

			return sheetExists;
		}

		private static void EnsureSheetStatusUpToDate(int id)
		{
			if (imageUtil.sheetStatus[id] == TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING)
			{
				bool allLoaded = true;
				foreach (int tileId in imageUtil.tilesPerId[id])
				{
					if (!imageUtil.tilesByName.ContainsKey(id + "_" + tileId))
					{
						allLoaded = false;
						break;
					}
				}
				if (allLoaded)
				{
					imageUtil.sheetStatus[id] = TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED;
				}
			}
		}

		public static int IsImageSheetLoaded(string groupId)
		{
			int id = -1;
			imageUtil.groupNameToId.TryGetValue(groupId, out id);

			int status = 2; // error code
			if (id != -1)
			{
				EnsureSheetStatusUpToDate(id);

				switch (imageUtil.sheetStatus[id])
				{
					case TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADED: status = 1; break;
					case TransitionaryCrayonHelper.IMAGE_SHEET_STATUS_LOADING: status = 0; break;
					default: status = 2; break;
				}
			}
			return status;
		}

		public static int GetSheetErrorCode(string groupId)
		{
			return 0;
		}

		public static int GetNumTiles(string groupName)
		{
			int groupId;
			if (imageUtil.groupNameToId.TryGetValue(groupName, out groupId))
			{
				return imageUtil.tilesPerId[groupId].Length;
			}
			return -1;
		}

		public static int GetNumTilesLoaded(string groupName)
		{
			int groupId;
			if (imageUtil.groupNameToId.TryGetValue(groupName, out groupId))
			{
				int tileCount = 0;
				foreach (int tileId in imageUtil.tilesPerId[groupId])
				{
					if (imageUtil.tilesByName.ContainsKey(groupId + "_" + tileId))
					{
						++tileCount;
					}
				}
				return tileCount;
			}
			return -1;
		}

	}
}
